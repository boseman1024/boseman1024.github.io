<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Kuma2x">
  
  
  
  <link rel="prev" href="https://boseman1024.github.io/2018/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" />
  <link rel="next" href="https://boseman1024.github.io/2018/top-interview-questions-easy-1/" />
  <link rel="canonical" href="https://boseman1024.github.io/2018/top-interview-questions-easy-2/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Top Interview Questions-Easy-② | KUMA2X
       
  </title>
  <meta name="title" content="Top Interview Questions-Easy-② | KUMA2X">
    

  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://boseman1024.github.io/"
    },
    "articleSection" : "posts",
    "name" : "Top Interview Questions-Easy-②",
    "headline" : "Top Interview Questions-Easy-②",
    "description" : "Dynamic Programming Climbing Stairs 爬楼梯，实质为斐波那契数列 You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
 Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
 1 step + 1 step",
    "inLanguage" : "en-us",
    "author" : "Kuma2x",
    "creator" : "Kuma2x",
    "publisher": "Kuma2x",
    "accountablePerson" : "Kuma2x",
    "copyrightHolder" : "Kuma2x",
    "copyrightYear" : "2018",
    "datePublished": "2018-09-27 15:08:22 &#43;0000 UTC",
    "dateModified" : "2018-09-27 15:08:22 &#43;0000 UTC",
    "url" : "https://boseman1024.github.io/2018/top-interview-questions-easy-2/",
    "wordCount" : "3312",
    "keywords" : [ "数据结构与算法","LeetCode","JAVA", "KUMA2X"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://boseman1024.github.io/">KUMA2X</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://boseman1024.github.io/">KUMA2X</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Top Interview Questions-Easy-②</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://boseman1024.github.io/" rel="author">Kuma2x</a> with ♥ 
                <span class="post-time">
                on <time datetime=2018-09-27 itemprop="datePublished">September 27, 2018</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://boseman1024.github.io/categories/%E7%9D%81%E7%9C%BC%E7%9E%8E/"> 睁眼瞎 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          

<h1 id="dynamic-programming">Dynamic Programming</h1>

<h2 id="climbing-stairs">Climbing Stairs</h2>

<h2 id="爬楼梯-实质为斐波那契数列">爬楼梯，实质为斐波那契数列</h2>

<p>You are climbing a stair case. It takes n steps to reach to the top.</p>

<p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p>

<p><em>Note:</em> Given n will be a positive integer.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: 2</p>

<p>Output: 2</p>

<p>Explanation: There are two ways to climb to the top.</p>

<ol>
<li><p>1 step + 1 step</p></li>

<li><p>2 steps</p></li>
</ol>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: 3</p>

<p>Output: 3</p>

<p>Explanation: There are three ways to climb to the top.</p>

<ol>
<li><p>1 step + 1 step + 1 step</p></li>

<li><p>1 step + 2 steps</p></li>

<li><p>2 steps + 1 step</p></li>
</ol>
</blockquote>

<h3 id="解答">解答：</h3>

<pre><code class="language-java">class Solution {
    /*斐波那契数列：
    * f(0)=1
    * f(1)=2
    * f(n)=f(n-1)+f(n-2)  n&gt;1
    *
    * 若一次可爬1、2、…、n级台阶，则爬上一个n级台阶一共有f(n)=2^(n-1)种跳法
    */
    public int climbStairs(int n) {
        if(n&lt;=1){return n;}
        int one = 1;
        int two = 2;
        int ways  = 2;
        for(int i=2;i&lt;n;i++){
            ways = one+two;
            one = two;
            two = ways;
        }
        return ways;
    }
}
</code></pre>

<h2 id="maximum-subarray">Maximum Subarray</h2>

<h2 id="数组中连续数的最大和">数组中连续数的最大和</h2>

<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],</p>

<p>Output: 6</p>

<p>Explanation: [4,-1,2,1] has the largest sum = 6.</p>
</blockquote>

<h3 id="解答-1">解答：</h3>

<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length&lt;1||nums==null) {return 0;}
        int sum = nums[0];
        int temp = 0;
        for(int i:nums){
            temp+=i;
            sum = Math.max(sum,temp);
            temp = temp&lt;0?0:temp;
        }
        return sum;
    }
}
</code></pre>

<h2 id="best-time-to-buy-and-sell-stock">Best Time to Buy and Sell Stock</h2>

<h2 id="买卖股票的最佳时间">买卖股票的最佳时间</h2>

<p>Say you have an array for which the ith element is the price of a given stock on day i.</p>

<p>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>

<p>Note that you cannot sell a stock before you buy one.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: [7,1,5,3,6,4]</p>

<p>Output: 5</p>

<p>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</p>

<p>Not 7-1 = 6, as selling price needs to be larger than buying price.</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: [7,6,4,3,1]</p>

<p>Output: 0</p>

<p>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
</blockquote>

<h3 id="解答-2">解答：</h3>

<pre><code class="language-java">class Solution {
    //2ms
    public int maxProfit(int[] prices) {
        int max = 0;
        int minPrice = Integer.MAX_VALUE;
        for(int i:prices){
            minPrice = Math.min(i,minPrice);
            max = Math.max(max,i-minPrice);
        }
        return max;
    }
    //400ms+
    public int maxProfit(int[] prices) {
        int max = 0;
        for(int i=0;i&lt;prices.length;i++){
            for(int j=i+1;j&lt;prices.length;j++){
                if(prices[i]&lt;prices[j]){
                    max = Math.max(max,prices[j]-prices[i]);
                }
            }
        }
        return max;
    }
}
</code></pre>

<hr />

<h1 id="others">Others</h1>

<h2 id="valid-parentheses">Valid Parentheses</h2>

<h2 id="检验优先级">检验优先级</h2>

<p>Given a string containing just the characters &lsquo;(&rsquo;, &lsquo;)&rsquo;, &lsquo;{&rsquo;, &lsquo;}&rsquo;, &lsquo;[&rsquo; and &lsquo;]&rsquo;, determine if the input string is valid.</p>

<p>An input string is valid if:</p>

<ul>
<li><p>Open brackets must be closed by the same type of brackets.</p></li>

<li><p>Open brackets must be closed in the correct order.</p></li>
</ul>

<p>Note that an empty string is also considered valid.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: &ldquo;()&rdquo;</p>

<p>Output: true</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: &ldquo;()[]{}&rdquo;</p>

<p>Output: true</p>
</blockquote>

<p><em>Example 3:</em></p>

<blockquote>
<p>Input: &ldquo;(]&rdquo;</p>

<p>Output: false</p>
</blockquote>

<p><em>Example 4:</em></p>

<blockquote>
<p>Input: &ldquo;([)]&rdquo;</p>

<p>Output: false</p>
</blockquote>

<p><em>Example 5:</em></p>

<blockquote>
<p>Input: &ldquo;{[]}&rdquo;</p>

<p>Output: true</p>
</blockquote>

<h3 id="解答-3">解答：</h3>

<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        char[] chs =  s.toCharArray();
        //使用堆栈，栈中仅存')、}、]',出栈时核验是否匹配
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        for (char c : s.toCharArray()) {
            if (c == '(') {stack.push(')');
            } else if (c =='{') {stack.push('}');
            } else if (c =='[') {stack.push(']');
            } else if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }
        return stack.isEmpty();
        //使用Deque双向队列
        Deque&lt;Character&gt; box = new ArrayDeque&lt;&gt;();
        Map&lt;Character,Character&gt; map = new HashMap&lt;&gt;();
        map.put(')','(');
        map.put('}','{');
        map.put(']','[');
        for(char c:chs) {
            if(c=='('||c=='{'||c=='[') {
                box.addFirst(c);
            }else {
                char first = box.size()&gt;0?box.peekFirst():' ';
                if(first==']'||first=='}'||first==')') {
                    return false;
                }else if(first==map.get(c)) {
                    box.removeFirst();
                }else {
                    box.addLast(c);
                }
            }
        }
        return box.size()==0;
    }
}
</code></pre>

<h2 id="pascal-s-triangle">Pascal&rsquo;s Triangle</h2>

<h2 id="杨辉三角形-帕斯卡三角形">杨辉三角形、帕斯卡三角形</h2>

<p>Given a non-negative integer numRows, generate the first numRows of Pascal&rsquo;s triangle.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif"></p>

<p>In Pascal&rsquo;s triangle, each number is the sum of the two numbers directly above it.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: 5</p>

<p>Output:[</p>

<ul>
<li><p>[1],</p></li>

<li><p>[1,1],</p></li>

<li><p>[1,2,1],</p></li>

<li><p>[1,3,3,1],</p></li>

<li><p>[1,4,6,4,1]]</p></li>
</ul>
</blockquote>

<h3 id="解答-4">解答：</h3>

<pre><code class="language-java">class Solution {
    public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) {
        List&lt;List&lt;Integer&gt;&gt; all = new ArrayList&lt;&gt;();
        if(numRows&lt;=0){return all;}
        all.add(new ArrayList&lt;&gt;());
        all.get(0).add(1);
        if(numRows==1){return all;}
        all.add(new ArrayList&lt;&gt;());
        all.get(1).add(1);
        all.get(1).add(1);
        if(numRows==2){return all;}
        for(int i=3;i&lt;=numRows;i++){
            all.add(new ArrayList&lt;&gt;());
            List&lt;Integer&gt; now = all.get(i-1);
            now.add(1);
            List&lt;Integer&gt; pre = all.get(i-2);
            for(int j=1;j&lt;i-1;j++){
                now.add(pre.get(j-1)+pre.get(j));
            }
            now.add(1);
        }
        return all;
    }
}
</code></pre>

<h2 id="hamming-distance">Hamming Distance</h2>

<h2 id="汉明距离">汉明距离</h2>

<p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>

<p>Given two integers x and y, calculate the Hamming distance.</p>

<p><em>Note:</em> 0 ≤ x, y &lt; 2^31.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: x = 1, y = 4</p>

<p>Output: 2</p>

<p>Explanation:</p>

<p>1   (0 0 0 1)</p>

<p>4   (0 1 0 0)</p>

<ul>
<li>↑   ↑</li>
</ul>

<p>The above arrows point to positions where the corresponding bits are different.</p>
</blockquote>

<h3 id="解答-5">解答：</h3>

<pre><code class="language-java">class Solution {
    public int hammingDistance(int x, int y) {
        //得到x,y的异或值
        int val = x^y;
        //计算1的个数，方法同Number of 1 Bits
        return Integer.bitCount(val);
    }
}
</code></pre>

<h2 id="number-of-1-bits">Number of 1 Bits</h2>

<h2 id="二进制数中1的个数">二进制数中1的个数</h2>

<p>Write a function that takes an unsigned integer and returns the number of &lsquo;1&rsquo; bits it has (also known as the Hamming weight).</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: 11</p>

<p>Output: 3</p>

<p>Explanation: Integer 11 has binary representation 00000000000000000000000000001011</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: 128
Output: 1
Explanation: Integer 128 has binary representation 00000000000000000000000010000000</p>
</blockquote>

<h3 id="解答-6">解答：</h3>

<pre><code class="language-java">public class Solution {
    public int hammingWeight(int n) {
        /**与运算
        *1：0000 0001
        *2：0000 0010
        *3：0000 0011
        *4：0000 0100
        *5：0000 0101
        *6：0000 0110
        *7：0000 0111
        *8：0000 1000
        *9：0000 1001
        *10：0000 1010
        *11：0000 1011
        *------------
        *0000 1010  = 10 = 11&amp;10
        *0000 1000  =  8 = 10&amp;9
        *0000 0000  =  0 = 8&amp;7
        */ 
        int sum = 0;
        while(n!=0){
            sum++;
            n&amp;=n-1;
        }
        return sum;
        //java API，返回1的个数
        return Integer.bitCount(n);
        // 转换为String判断每一位是否为1
        if (n==0) {return 0;}
        char[] chs = Integer.toBinaryString(n).toCharArray();
        int count = 0;
        for (int i=0; i &lt; chs.length; i++) {
            if (chs[i]=='1'){count++;}
        }
        return count;
    }
}
</code></pre>

<h2 id="missing-number">Missing Number</h2>

<p>Given an array containing n distinct numbers taken from 0, 1, 2, &hellip;, n, find the one that is missing from the array.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: [3,0,1]</p>

<p>Output: 2</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: [9,6,4,2,3,5,7,0,1]</p>

<p>Output: 8</p>
</blockquote>

<h3 id="解答-7">解答：</h3>

<pre><code class="language-java">class Solution {
    //0+1+2+……+n = n*(n+1)/2
    public int missingNumber(int[] nums) {
        int sum = nums.length*(nums.length+1)/2;
        for(int i=0;i&lt;nums.length;i++){sum-=nums[i];}
        return sum;
    }
}
</code></pre>

<h2 id="reverse-bits">Reverse Bits</h2>

<h2 id="反转二进制">反转二进制</h2>

<p>Reverse bits of a given 32 bits unsigned integer.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: 43261596</p>

<p>Output: 964176192</p>

<p>Explanation:</p>

<p>43261596 represented in binary as 00000010100101000001111010011100,</p>

<p>return 964176192 represented in binary as 00111001011110000010100101000000.</p>
</blockquote>

<h3 id="解答-8">解答</h3>

<pre><code class="language-java">public class Solution {
    //位运算？不会
    // you need treat n as an unsigned value
    //转换为二进制字符串，不足位数前补0，反转字符串
    public int reverseBits(int n) {
        String s = Integer.toBinaryString(n);
        int length = s.length();
        for(int i=0;i&lt;(32-length);i++) {s='0'+s;}
        String sb = new StringBuilder(s).reverse().toString();
        return (int)Long.parseLong(sb,2);
    }
}
</code></pre>

<hr />

<h1 id="tree">Tree</h1>

<h2 id="symmetric-tree">Symmetric Tree</h2>

<h2 id="镜像二叉树树">镜像二叉树树</h2>

<p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>

<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric</p>

<p>But the following <code>[1,2,2,null,3,null,3]</code> is not</p>

<h3 id="解答-9">解答：</h3>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //8ms
    public boolean isSymmetric(TreeNode root) {
        return isSymmetric(root,root);
    }
    public boolean isSymmetric(TreeNode left,TreeNode right){
        if(left==null&amp;&amp;right==null){return true;}
        if(left==null||right==null){return false;}
        if(left.val!=right.val){return false;}
        return isSymmetric(left.left,right.right)&amp;&amp;isSymmetric(left.right,right.left);
    }
    //-----------------------------------------------
    //先将二叉树化为按层划分的集合，再做镜像校验
    List&lt;List&lt;Integer&gt;&gt; all;
    public boolean isSymmetric(TreeNode root) {
        if(root==null){return true;}
        all = new ArrayList&lt;&gt;();
        get(root,0);
        //检验镜像
        for(List&lt;Integer&gt; list:all){
            int i=0;
            while(list.size()&gt;1&amp;&amp;i&lt;list.size()/2){
                if(list.get(i)!=list.get(list.size()-1-i)){
                    return false;
                }
                i++;
            }
        }
        return true;
    }
    //同Binary Tree Level Order Traversal，但node为空则向集合添加null
    public void get(TreeNode node,int depth){
        if(all.size()&lt;=depth){all.add(new ArrayList&lt;&gt;());}
        if(node==null){all.get(depth).add(null);return;
        }else{all.get(depth).add(node.val);}        
        depth++;
        get(node.left,depth);
        get(node.right,depth);
    }
}
</code></pre>

<h2 id="binary-tree-level-order-traversal">Binary Tree Level Order Traversal</h2>

<h2 id="二叉树分层遍历">二叉树分层遍历</h2>

<p>Given a binary tree, return the level order traversal of its nodes&rsquo; values. (ie, from left to right, level by level).</p>

<p>For example:
Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p>

<p>return its level order traversal as:</p>

<blockquote>
<p>[[3],</p>

<p>[9,20],</p>

<p>[15,7]]</p>
</blockquote>

<h3 id="解答-10">解答：</h3>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List&lt;List&lt;Integer&gt;&gt; all;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {
        all = new ArrayList&lt;&gt;();
        if(root==null){return all;}
        get(root,0);
        return all;
    }
    public void get(TreeNode node,int depth){
        if(node==null){return;}
        //深度depth的all不存在，则向all内添加List
        if(all.size()&lt;=depth){all.add(new ArrayList&lt;&gt;());}
        all.get(depth).add(node.val);
        depth++;
        get(node.left,depth);
        get(node.right,depth);
    }
}
</code></pre>

<h2 id="convert-sorted-array-to-binary-search-tree">Convert Sorted Array to Binary Search Tree</h2>

<h2 id="将排序后的数组构成二叉搜索树">将排序后的数组构成二叉搜索树</h2>

<p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.</p>

<p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Given the sorted array: [-10,-3,0,5,9],</p>

<p>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST</p>

<p>[0,-10,5,null,-3,null,9]</p>
</blockquote>

<h3 id="解答-11">解答：</h3>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums,0,nums.length-1);
    }
    public TreeNode toBST(int[] nums,int low,int high){
        if(low&gt;high){return null;}
        int mid = low+(high-low)/2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = toBST(nums,low,mid-1);
        node.right = toBST(nums,mid+1,high);
        return node;
    }
}
</code></pre>

<h2 id="validate-binary-search-tree">Validate Binary Search Tree</h2>

<h2 id="检验是否为二叉搜索树">检验是否为二叉搜索树</h2>

<p>Given a binary tree, determine if it is a valid binary search tree (BST).</p>

<p>Assume a BST is defined as follows:</p>

<ul>
<li><p>The left subtree of a node contains only nodes with keys less than the node&rsquo;s key.</p></li>

<li><p>The right subtree of a node contains only nodes with keys greater than the node&rsquo;s key.</p></li>

<li><p>Both the left and right subtrees must also be binary search trees.</p></li>
</ul>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: [2,1,3]</p>

<p>Output: true</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: [5,1,4,null,null,3,6]</p>

<p>Output: false</p>

<p>Explanation: The input is: [5,1,4,null,null,3,6]. The root node&rsquo;s value is 5 but its right child&rsquo;s value is 4.</p>
</blockquote>

<h3 id="解答-12">解答：</h3>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //0ms
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
    public boolean helper(TreeNode node,Integer upper,Integer lower) {
        if(node == null){return true;}
        if(upper != null &amp;&amp; node.val &gt;= upper){return false;}
        if(lower != null &amp;&amp; node.val &lt;= lower){return false;}
        return helper(node.left,node.val,lower) &amp;&amp; helper(node.right, upper,node.val);
    } 
    //使用堆栈，6ms
    Stack&lt;Integer&gt; stack;
    public boolean isValidBST(TreeNode root) {
        if(root==null){return true;}
        stack = new Stack&lt;&gt;();
        get(root);
        while(!stack.isEmpty()){
            int pop = stack.pop();
            if(!stack.isEmpty()&amp;&amp;pop&lt;=stack.peek()){return false;}
        }
        return true;
    }
    public void get(TreeNode node){
        if(node!=null){
            get(node.left);
            stack.add(node.val);
            get(node.right);
        }
    }
}
</code></pre>

<h2 id="maximum-depth-of-binary-tree">Maximum Depth of Binary Tree</h2>

<h2 id="二叉树的最大深度">二叉树的最大深度</h2>

<p>Given a binary tree, find its maximum depth.</p>

<p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>

<p><em>Note:</em> A leaf is a node with no children.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Given binary tree [3,9,20,null,null,15,7],</p>

<p>return its depth = 3.</p>
</blockquote>

<h3 id="解答-13">解答：</h3>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){return 0;}
        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
    }
}
</code></pre>

<hr />

<h1 id="math">Math</h1>

<h2 id="roman-to-integer">Roman to Integer</h2>

<h2 id="罗马数字转换">罗马数字转换</h2>

<p>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p>

<p>I=1,V=5,X=10,L=50,C=100,D=500,M=1000</p>

<p>For example, two is written as II in Roman numeral, just two one&rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p>

<p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p>

<ul>
<li><p>I can be placed before V (5) and X (10) to make 4 and 9.</p></li>

<li><p>X can be placed before L (50) and C (100) to make 40 and 90.</p></li>

<li><p>C can be placed before D (500) and M (1000) to make 400 and 900.</p></li>
</ul>

<p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: &ldquo;III&rdquo;</p>

<p>Output: 3</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: &ldquo;IV&rdquo;</p>

<p>Output: 4</p>
</blockquote>

<p><em>Example 3:</em></p>

<blockquote>
<p>Input: &ldquo;IX&rdquo;</p>

<p>Output: 9</p>
</blockquote>

<p><em>Example 4:</em></p>

<blockquote>
<p>Input: &ldquo;LVIII&rdquo;</p>

<p>Output: 58</p>

<p>Explanation: L = 50, V= 5, III = 3.</p>
</blockquote>

<p><em>Example 5:</em></p>

<blockquote>
<p>Input: &ldquo;MCMXCIV&rdquo;</p>

<p>Output: 1994</p>

<p>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</p>
</blockquote>

<h3 id="解答-14">解答：</h3>

<pre><code class="language-java">class Solution {
    public int romanToInt(String s) {
        Map&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        int sum =0;
        int pre = 0;
        char[] chs = s.toCharArray();
        for(char c:chs){
            int num = map.get(c);
            if(num&gt;pre){sum = sum-2*pre+num;
            //num-pre再减去前一轮加上的pre = num-2*pre
            }else{sum+=num;}
            pre = num;
        }
        return sum;
    }
}
</code></pre>

<h2 id="fizz-buzz">Fizz Buzz</h2>

<h2 id="fizz-替代3的倍数-buzz-替代5的倍数">“Fizz”替代3的倍数，“Buzz”替代5的倍数</h2>

<p>Write a program that outputs the string representation of numbers from 1 to n.</p>

<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>

<p><em>Example:</em></p>

<blockquote>
<p>n = 15,</p>

<p>Return:</p>

<p>[&ldquo;1&rdquo;,&ldquo;2&rdquo;,&ldquo;Fizz&rdquo;,&ldquo;4&rdquo;,</p>

<p>&ldquo;Buzz&rdquo;,&ldquo;Fizz&rdquo;,&ldquo;7&rdquo;,&ldquo;8&rdquo;,</p>

<p>&ldquo;Fizz&rdquo;,&ldquo;Buzz&rdquo;,&ldquo;11&rdquo;,&ldquo;Fizz&rdquo;,</p>

<p>&ldquo;13&rdquo;,&ldquo;14&rdquo;,&ldquo;FizzBuzz&rdquo;]</p>
</blockquote>

<h3 id="解答-15">解答：</h3>

<pre><code class="language-java">class Solution {
    public List&lt;String&gt; fizzBuzz(int n) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for(int i=1;i&lt;=n;i++){
            boolean isThree = i%3==0;
            boolean isFive = i%5==0
            if(isThree&amp;&amp;isFive){list.add(&quot;FizzBuzz&quot;);
            }else if(isThree){list.add(&quot;Fizz&quot;);
            }else if(isFive){list.add(&quot;Buzz&quot;);
            }else{list.add(String.valueOf(i));
            }
        }
        return list;
    }
}
</code></pre>

<h2 id="count-primes">Count Primes</h2>

<h2 id="质数的个数">质数的个数</h2>

<p>Count the number of prime numbers <em>less than</em> a non-negative number, n.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: 10</p>

<p>Output: 4</p>

<p>Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.</p>
</blockquote>

<h3 id="解答-16">解答：</h3>

<pre><code class="language-java">class Solution {
    //筛法求素数：若已知一个数为素数，则该数的倍数均非素数。
    //21ms，筛法求素数
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        int count = 0;
        for(int i=2;i&lt;n;i++){
            if(isPrime[i]==false){
                count++;
                for(int j=2;j*i&lt;n;j++){isPrime[j*i]=true;}
            }
        }
        return count;
    }
    //120ms，筛法求素数
    public int countPrimes(int n) {
        if(n==0||n==1){return 0;}
        int[] num = new int[n];
        int[] result = new int[n];
        int count = 0;
        for(int i=2;i&lt;n;i++){
            //是素数，存入result
            if(num[i]==0){result[count++]=i;}
            //将所求素数的倍数设为1，均非素数
            for(int j=2*i;j&lt;n;j+=i){num[j]=1;}
        }
        return count;
    }
}
</code></pre>

<h2 id="power-of-three">Power of Three</h2>

<h2 id="是否为3的多次方数">是否为3的多次方数</h2>

<p>Given an integer, write a function to determine if it is a power of three.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: 27</p>

<p>Output: true</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: 0</p>

<p>Output: false</p>
</blockquote>

<p><em>Example 3:</em></p>

<blockquote>
<p>Input: 9</p>

<p>Output: true</p>
</blockquote>

<p><em>Example 4:</em></p>

<blockquote>
<p>Input: 45</p>

<p>Output: false</p>
</blockquote>

<h3 id="解答-17">解答：</h3>

<pre><code class="language-java">class Solution {
    public boolean isPowerOfThree(int n) {
        while(n&gt;0){
            if(n==1){return true;
            }else if(n%3==0){n /=3;
            }else{return false;}
        }
        return false;
    }
}
</code></pre>

<hr />

<h1 id="string">String</h1>

<h2 id="string-to-integer-atoi">String to Integer (atoi)</h2>

<h2 id="字符串转整型数">字符串转整型数</h2>

<p>Implement atoi which converts a string to an integer.</p>

<p>The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</p>

<p>The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</p>

<p>If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</p>

<p>If no valid conversion could be performed, a zero value is returned.</p>

<p><em>Note:</em></p>

<ul>
<li><p>Only the space character &lsquo; &rsquo; is considered as whitespace character.</p></li>

<li><p>Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.</p></li>
</ul>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: &ldquo;42&rdquo;</p>

<p>Output: 42</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: &ldquo;   -42&rdquo;</p>

<p>Output: -42</p>

<p>Explanation: The first non-whitespace character is &lsquo;-&rsquo;, which is the minus sign.</p>

<p>Then take as many numerical digits as possible, which gets 42.</p>
</blockquote>

<p><em>Example 3:</em></p>

<blockquote>
<p>Input: &ldquo;4193 with words&rdquo;</p>

<p>Output: 4193</p>

<p>Explanation: Conversion stops at digit &lsquo;3&rsquo; as the next character is not a numerical digit.</p>
</blockquote>

<p><em>Example 4:</em></p>

<blockquote>
<p>Input: &ldquo;words and 987&rdquo;</p>

<p>Output: 0</p>

<p>Explanation: The first non-whitespace character is &lsquo;w&rsquo;, which is not a numerical</p>

<p>digit or a +/- sign. Therefore no valid conversion could be performed.</p>
</blockquote>

<p><em>Example 5:</em></p>

<blockquote>
<p>Input: &ldquo;-91283472332&rdquo;</p>

<p>Output: -2147483648</p>

<p>Explanation: The number &ldquo;-91283472332&rdquo; is out of the range of a 32-bit signed integer.</p>

<p>Thefore INT_MIN (−231) is returned.</p>
</blockquote>

<h3 id="解答-18">解答：</h3>

<pre><code class="language-java">class Solution {
    public int myAtoi(String str) {
        if(str.trim().length()&lt;1||str==null){return 0;}
        str = str.trim();
        char c = str.charAt(0);
        boolean flag = false;
        if(c=='-') {
            flag = true;
            str = str.substring(1,str.length());
        }else if(c=='+'){str = str.substring(1,str.length());
        }else if(c&lt;'0'||c&gt;'9'){return 0;}
        //&quot;-+2&quot;
        if(str.length()&lt;1||str.charAt(0)&lt;'0'||str.charAt(0)&gt;'9'){return 0;}
        //&quot; 0000000123&quot;
        boolean isZero = true;
        int zeroNum = 0;
        for(int i=0;i&lt;str.length();i++) {
            char num = str.charAt(i);
            if(isZero&amp;&amp;num=='0') {zeroNum++;
            }else {isZero = false;}
            if(num&lt;'0'||num&gt;'9'){
                str = str.substring(0,i);
                break;
            }
        }
        str = str.substring(zeroNum, str.length());
        //&quot;000000000&quot;
        if(str.length()&lt;1) {return 0;}
        //&quot;200000000000000000000&quot;，防止溢出
        String MAX = String.valueOf(Integer.MAX_VALUE);
        String MIN = String.valueOf(Integer.MIN_VALUE);
        if(!flag&amp;&amp;str.length()&gt;MAX.length()) {return Integer.MAX_VALUE;
        }else if(flag&amp;&amp;str.length()&gt;MIN.length()-1){return Integer.MIN_VALUE;
        }
        long result = flag?-1*Long.parseLong(str):Long.parseLong(str);
        result = result&gt;Integer.MAX_VALUE?Integer.MAX_VALUE:result;
        result = result&lt;Integer.MIN_VALUE?Integer.MIN_VALUE:result;
        return (int)result;
    }
}
</code></pre>

<h2 id="longest-common-prefix">Longest Common Prefix</h2>

<h2 id="求最长共同的前缀">求最长共同的前缀</h2>

<p>Write a function to find the longest common prefix string amongst an array of strings.</p>

<p>If there is no common prefix, return an empty string &ldquo;&rdquo;.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: [&ldquo;flower&rdquo;,&ldquo;flow&rdquo;,&ldquo;flight&rdquo;]</p>

<p>Output: &ldquo;fl&rdquo;</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: [&ldquo;dog&rdquo;,&ldquo;racecar&rdquo;,&ldquo;car&rdquo;]</p>

<p>Output: &ldquo;&rdquo;</p>

<p>Explanation: There is no common prefix among the input strings.</p>
</blockquote>

<p>*Note:*All given inputs are in lowercase letters a-z.</p>

<h3 id="解答-19">解答：</h3>

<pre><code class="language-java">class Solution {
    //排序后比较头尾
    public String longestCommonPrefix(String[] strs) {
        if(strs.length==0||strs==null){return &quot;&quot;;}
        Arrays.sort(strs);
        String pre = &quot;&quot;;
        for(int i=0;i&lt;strs[0].length();i++){
            if(strs[0].charAt(i)==strs[strs.length-1].charAt(i)){
                pre += strs[0].charAt(i);
            }else{return pre;}
        }
        return pre;
    }
    //不断截取长度-1的字符串，直至符合
    public String longestCommonPrefix(String[] strs) {
        if(strs.length==0||strs==null){return &quot;&quot;;}
        String pre=strs[0];
        for(int i =0;i&lt;strs.length;i++){
            while(strs[i].indexOf(pre)!=0){
                pre = pre.substring(0,pre.length()-1);
            }
        }
        return pre;
    }
}
</code></pre>

<h2 id="implement-strstr">Implement strStr()</h2>

<h2 id="若字符串needle是haystack的子串-求其在haystack的索引">若字符串needle是haystack的子串，求其在haystack的索引</h2>

<p>Implement strStr().</p>

<p>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: haystack = &ldquo;hello&rdquo;, needle = &ldquo;ll&rdquo;</p>

<p>Output: 2</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: haystack = &ldquo;aaaaa&rdquo;, needle = &ldquo;bba&rdquo;</p>

<p>Output: -1</p>
</blockquote>

<h3 id="解答-20">解答：</h3>

<pre><code class="language-java">class Solution {
    //java API
    public int strStr(String haystack, String needle) {
        return haystack.indexOf(needle);
    }
}
</code></pre>

<h2 id="valid-anagram">Valid Anagram</h2>

<h2 id="检验s-t是否由颠倒字母顺序而构成">检验s、t是否由颠倒字母顺序而构成</h2>

<p>Given two strings s and t , write a function to determine if t is an anagram of s.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: s = &ldquo;anagram&rdquo;, t = &ldquo;nagaram&rdquo;</p>

<p>Output: true</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: s = &ldquo;rat&rdquo;, t = &ldquo;car&rdquo;</p>

<p>Output: false</p>
</blockquote>

<p>*Note:*You may assume the string contains only lowercase alphabets.</p>

<h3 id="解答-21">解答：</h3>

<pre><code class="language-java">class Solution {
    //存入字母表，判断字母表个数，1ms
    public boolean isAnagram(String s, String t) {
        if(s.length()!=t.length()){return false;}
        int[] charMap = new int[26];
        char[] sc = s.toCharArray();
        char[] tc  = t.toCharArray();
        for(char csc:sc){charMap[csc-'a']++;}
        for(char ctc:tc){charMap[ctc-'a']--;}
        for(int i:charMap){
            if(i!=0){return false;}
        }
        return true;
    }
    //转数组并排序比较是否匹配
    public boolean isAnagram(String s, String t) {
        if(s.length()!=t.length()){return false;}
        char[] sc = s.toCharArray();
        char[] tc  = t.toCharArray();
        Arrays.sort(sc);
        Arrays.sort(tc);
        return Arrays.equals(sc,tc);
    }
}
</code></pre>

<h2 id="first-unique-character-in-a-string">First Unique Character in a String</h2>

<h2 id="找出字符串中仅出现1次的字母">找出字符串中仅出现1次的字母</h2>

<p>Given a string, find the first non-repeating character in it and return it&rsquo;s index. If it doesn&rsquo;t exist, return -1.</p>

<p><em>Note:</em> You may assume the string contain only lowercase letters.</p>

<p><em>Examples:</em></p>

<blockquote>
<p>s = &ldquo;leetcode&rdquo;</p>

<p>return 0.</p>

<p>s = &ldquo;loveleetcode&rdquo;,</p>

<p>return 2.</p>
</blockquote>

<h3 id="解答-22">解答：</h3>

<pre><code class="language-java">class Solution {
    public int firstUniqChar(String s) {
        for(int i=0;i&lt;s.length();i++) {
            if(s.indexOf(s.charAt(i))==s.lastIndexOf(s.charAt(i))) {
                return i;
            }
        }
        return -1;
    }
}
</code></pre>

<h2 id="valid-palindrome">Valid Palindrome</h2>

<h2 id="回文">回文</h2>

<h3 id="解答-23">解答：</h3>

<pre><code class="language-java">public boolean isPalindrome(String s) {
    char[] str = s.toLowerCase().toCharArray();
    int i=0;
    int j=str.length-1;
    while(i&lt;j) {
        while(i&lt;str.length&amp;&amp;!isChar(str[i])) {
            i++;
        }
        while(j&gt;=0&amp;&amp;!isChar(str[j])) {
            j--;
        }
        if(i&lt;j&amp;&amp;str[i]!=str[j]) {
            return false;
        }
        i++;
        j--;
    }
    return true;
}
public boolean isChar(char c) {
    return ('a'&lt;=c&amp;&amp;c&lt;='z')||('A'&lt;=c&amp;&amp;c&lt;='Z')||(c&gt;='0'&amp;&amp;c&lt;='9');
}
</code></pre>

<h2 id="reverse-integer">Reverse Integer</h2>

<h2 id="反转整型">反转整型</h2>

<p>Given a 32-bit signed integer, reverse digits of an integer.</p>

<p><em>Note:</em>
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p>

<h3 id="解答-24">解答：</h3>

<pre><code class="language-java">class Solution {
    public int reverse(int x) {
        //数值
        if(x&gt;Integer.MAX_VALUE||x&lt;Integer.MIN_VALUE){
            return 0;
        }
        long num = 0;
        while(x!=0) {
            num*=10;
            num += x%10;
            x /= 10;
        }
        if(num&lt;=Integer.MAX_VALUE&amp;&amp;num&gt;=Integer.MIN_VALUE){
            return (int)num;
        }
        return 0;
        //转换字符串
        boolean flag = false;
        long num = x;
        if(num&lt;0) {
            num *=-1;
            flag = true;
        }
        String str = new StringBuffer(String.valueOf(num)).reverse().toString();
        num = Long.parseLong(str);
        if(num&gt;Integer.MAX_VALUE ||num&lt;Integer.MIN_VALUE ){
            return 0;
        }else if(flag) {
            num*=-1;
        }
        return (int)num;
    }
}
</code></pre>

<h2 id="reverse-string">Reverse String</h2>

<h2 id="反转字符串">反转字符串</h2>

<h3 id="解答-25">解答：</h3>

<pre><code class="language-java">public String reverseString(String s) {
    return new StringBuffer(s).reverse().toString();
}
</code></pre>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Kuma2x </span>
                </p>
            
           
           
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://boseman1024.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                    #数据结构与算法</a></span>
            
            <span class="tag"><a href="https://boseman1024.github.io/tags/leetcode/">
                    #LeetCode</a></span>
            
            <span class="tag"><a href="https://boseman1024.github.io/tags/java/">
                    #JAVA</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://boseman1024.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://boseman1024.github.io/2018/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/" class="prev" rel="prev" title="排序算法整理"><i class="iconfont icon-left"></i>&nbsp;排序算法整理</a>
         
        
        <a href="https://boseman1024.github.io/2018/top-interview-questions-easy-1/" class="next" rel="next" title="Top Interview Questions-Easy-①">Top Interview Questions-Easy-①&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2018 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://boseman1024.github.io/">Kuma2x</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
