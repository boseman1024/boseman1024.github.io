<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Kuma2x">
  
  
  
  <link rel="prev" href="https://boseman1024.github.io/2018/top-interview-questions-easy-1/" />
  
  <link rel="canonical" href="https://boseman1024.github.io/2018/top-interview-questions-medium-1/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Top Interview Questions-Medium-① | KUMA2X
       
  </title>
  <meta name="title" content="Top Interview Questions-Medium-① | KUMA2X">
    

  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https://boseman1024.github.io/"
    },
    "articleSection" : "posts",
    "name" : "Top Interview Questions-Medium-①",
    "headline" : "Top Interview Questions-Medium-①",
    "description" : "Trees and Graphs Number of Islands 求出岛屿个数 Given a 2d grid map of *&lsquo;1&rsquo;*s (land) and &lsquo;0&rsquo;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
无向图遍历，1为可移动区域
Example 1:
 Input:
11110
11010
11000
00000
Output: 1
 Example 2:
 Input:",
    "inLanguage" : "en-us",
    "author" : "Kuma2x",
    "creator" : "Kuma2x",
    "publisher": "Kuma2x",
    "accountablePerson" : "Kuma2x",
    "copyrightHolder" : "Kuma2x",
    "copyrightYear" : "2018",
    "datePublished": "2018-09-29 22:59:34 &#43;0000 UTC",
    "dateModified" : "2018-09-29 22:59:34 &#43;0000 UTC",
    "url" : "https://boseman1024.github.io/2018/top-interview-questions-medium-1/",
    "wordCount" : "2082",
    "keywords" : [ "数据结构与算法","LeetCode","JAVA", "KUMA2X"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://boseman1024.github.io/">KUMA2X</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://boseman1024.github.io/">KUMA2X</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Top Interview Questions-Medium-①</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://boseman1024.github.io/" rel="author">Kuma2x</a> with ♥ 
                <span class="post-time">
                on <time datetime=2018-09-29 itemprop="datePublished">September 29, 2018</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://boseman1024.github.io/categories/%E7%9D%81%E7%9C%BC%E7%9E%8E/"> 睁眼瞎 </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          

<h1 id="trees-and-graphs">Trees and Graphs</h1>

<h2 id="number-of-islands">Number of Islands</h2>

<h2 id="求出岛屿个数">求出岛屿个数</h2>

<p>Given a 2d grid map of *&lsquo;1&rsquo;*s (land) and <em>&lsquo;0&rsquo;s</em> (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p>

<p>无向图遍历，1为可移动区域</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input:</p>

<p>11110</p>

<p>11010</p>

<p>11000</p>

<p>00000</p>

<p>Output: 1</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input:</p>

<p>11000</p>

<p>11000</p>

<p>00100</p>

<p>00011</p>

<p>Output: 3</p>
</blockquote>

<h3 id="解答">解答：</h3>

<pre><code class="language-java">class Solution {
    public int numIslands(char[][] grid) {
        int rows = grid.length;
        if(rows==0){return 0;}
        int cols = grid[0].length;
        int count=0;
        for(int i=0;i&lt;rows;i++){
            for(int j=0;j&lt;cols;j++){
                if(grid[i][j]=='1'){
                    dfs(grid,i,j,rows,cols);
                    count++;
                }
            }
        }
        return count;
    }
    //深度搜索
    public void dfs(char[][] grid,int i,int j,int rows,int cols){
        if(i&lt;0||j&lt;0||i&gt;=rows||j&gt;=cols||grid[i][j]=='0'){return;}
        //剩下的grid[i][j]都为1
        //将已访问点设为0
        grid[i][j]='0';
        dfs(grid,i,j+1,rows,cols);
        dfs(grid,i,j-1,rows,cols);
        dfs(grid,i+1,j,rows,cols);
        dfs(grid,i-1,j,rows,cols);
    }
}
</code></pre>

<h2 id="kth-smallest-element-in-a-bst">Kth Smallest Element in a BST</h2>

<h2 id="找出第k小的数">找出第K小的数</h2>

<p>Given a binary search tree, write a function <em>kthSmallest</em> to find the kth smallest element in it.</p>

<p><em>Note:</em></p>

<p>You may assume k is always valid, 1 ≤ k ≤ BST&rsquo;s total elements.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: root = [3,1,4,null,2], k = 1</p>

<p>Output: 1</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: root = [5,3,6,2,4,null,null,1], k = 3</p>

<p>Output: 3</p>
</blockquote>

<h3 id="解答-1">解答：</h3>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //中序遍历找出第K小的数
    public int kthSmallest(TreeNode root, int k) {
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        stack.push(root);
        TreeNode node = root;
        while(node!=null||!stack.empty()){
            while(node!=null){
                stack.push(node);
                node = node.left;
            }
            if(!stack.empty()){
                node = stack.pop();
                k--;
                if(k==0){
                    return node.val;
                }
                node = node.right;
            }
        }
        return root.val;
        
    }
}
</code></pre>

<h2 id="binary-tree-inorder-traversal">Binary Tree Inorder Traversal</h2>

<h2 id="二叉树非递归中序遍历">二叉树非递归中序遍历</h2>

<p>Given a binary tree, return the inorder traversal of its nodes&rsquo; values.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: [1,null,2,3]</p>

<p>Output: [1,3,2]</p>
</blockquote>

<p><em>Follow up:</em> Recursive solution is trivial, could you do it iteratively?</p>

<h3 id="解答-2">解答：</h3>

<pre><code class="language-java">/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        TreeNode node=root;
        while(node!=null||!stack.empty()){
            while(node!=null){
                stack.push(node);
                node = node.left;
            }
            if(!stack.empty()){
                node = stack.pop();
                list.add(node.val);
                node = node.right;
            }
        }
        return list;
    }
}
</code></pre>

<h1 id="sorting-and-searching">Sorting and Searching</h1>

<h2 id="find-peak-element">Find Peak Element</h2>

<h2 id="找出一个大于前后的数">找出一个大于前后的数</h2>

<p>A peak element is an element that is greater than its neighbors.</p>

<p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p>

<p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p>

<p>You may imagine that nums[-1] = nums[n] = -∞.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: nums = [1,2,3,1]</p>

<p>Output: 2</p>

<p>Explanation: 3 is a peak element and your function should return the index number 2.</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: nums = [1,2,1,3,5,6,4]</p>

<p>Output: 1 or 5</p>

<p>Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</p>
</blockquote>

<h3 id="解答-3">解答：</h3>

<pre><code class="language-java">class Solution {
    //二分查找，时间O(logN)
    
    //时间O(N)
    public int findPeakElement(int[] nums) {
        if(nums.length==1){return 0;}
        //从nums[1]开始，与前一位比较，若小于前一位，则nums[i-1]为峰顶。
        //返回遇到的第一个顶峰。
        for(int i=1;i&lt;nums.length;i++){
            if(nums[i]&lt;nums[i-1]){return i-1;}
        }
        //最后只剩下数组最后一位数
        return nums.length-1;
    }
}
</code></pre>

<h2 id="kth-largest-element-in-an-array">Kth Largest Element in an Array</h2>

<h2 id="找出数组中第k大的数">找出数组中第k大的数</h2>

<p>Find the *k*th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: [3,2,1,5,6,4] and k = 2</p>

<p>Output: 5</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: [3,2,3,1,2,4,5,5,6] and k = 4</p>

<p>Output: 4</p>
</blockquote>

<p><em>Note:</em> You may assume k is always valid, 1 ≤ k ≤ array&rsquo;s length.</p>

<h3 id="解答-4">解答：</h3>

<pre><code class="language-java">class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length-k];
        //Quick Select is the fastest
        //快速选择
        
    }
}
</code></pre>

<h2 id="search-in-rotated-sorted-array">Search in Rotated Sorted Array</h2>

<h2 id="找出一个数在旋转有序数组中的索引">找出一个数在旋转有序数组中的索引</h2>

<p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p>

<p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p>

<p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p>

<p>You may assume no duplicate exists in the array.</p>

<p>Your algorithm&rsquo;s runtime complexity must be in the order of O(log n).</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 0</p>

<p>Output: 4</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: nums = [4,5,6,7,0,1,2], target = 3</p>

<p>Output: -1</p>
</blockquote>

<h3 id="解答-5">解答：</h3>

<pre><code class="language-java">class Solution {
    public int search(int[] nums, int target) {
        //找出旋转轴，判断旋转轴与目标的大小，决定目标处于旋转轴哪个区间
        //二分查找
        if(nums.length==0){return -1;}
        int rotatedIndex = binarySearchRotatedIndex(nums);
        int index=-1;
        if(nums[0]&lt;=target&amp;&amp;nums[rotatedIndex]&gt;=target){
            index = binarySearch(0,rotatedIndex,nums,target);
        }else{
            index = binarySearch(rotatedIndex+1,nums.length-1,nums,target);
        }
        return index;
    }
    public int binarySearchRotatedIndex(int[] nums){
        int low = 0;
        int high = nums.length-1;
        while(low&lt;=high){
            int mid = low+(high-low)/2;
            if(mid==nums.length-1){return mid;}
            if(nums[mid]&gt;nums[mid+1]){
                return mid;
            }
            if(nums[mid]&gt;=nums[low]){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        return low;
    }
    public int binarySearch(int low,int high,int[] nums,int target){
        while(low&lt;=high){
            int mid = low+(high-low)/2;
            if(nums[mid]&gt;target){
                high = mid - 1;
            }else if(nums[mid]&lt;target){
                low = mid + 1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
</code></pre>

<h2 id="top-k-frequent-elements">Top K Frequent Elements</h2>

<h2 id="找出最频繁出现的k个数">找出最频繁出现的K个数</h2>

<p>Given a non-empty array of integers, return the k most frequent elements.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: nums = [1,1,1,2,2,3], k = 2</p>

<p>Output: [1,2]</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: nums = [1], k = 1</p>

<p>Output: [1]</p>
</blockquote>

<p><em>Note:</em></p>

<ul>
<li><p>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.</p></li>

<li><p>Your algorithm&rsquo;s time complexity must be better than O(n log n), where n is the array&rsquo;s size.</p></li>
</ul>

<h3 id="解答-6">解答：</h3>

<pre><code class="language-java">class Solution {
    //24ms
    public List&lt;Integer&gt; topKFrequent(int[] nums, int k) {
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        //若nums长度等于k，直接返回
        if(nums.length==k){
            for(int i:nums){
                list.add(i);
            }
            return list;
        }
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        //修改TreeMap为降序，默认为升序
        Map&lt;Integer,List&lt;Integer&gt;&gt; mapTree = new TreeMap&lt;&gt;(new Comparator&lt;Integer&gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
             
        });
        //将每个数及对应个数放入map中
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        //map键值对换，其值为mapTree的键，其键加入mapTree的值
        for(int i:map.keySet()){
            List&lt;Integer&gt; keyList=mapTree.containsKey(map.get(i)) ? mapTree.get(map.get(i)) : new ArrayList&lt;&gt;();
            keyList.add(i);
            mapTree.put(map.get(i),keyList);
        }
        //遍历mapTree的值，取k个数返回
        for(List&lt;Integer&gt; keyList:mapTree.values()){
            for(int i=0;i&lt;keyList.size();i++){
                list.add(keyList.get(i));
                k--;
                if(k==0){return list;}
            }
        }
        return list;
    }
}
</code></pre>

<h2 id="sort-colors">Sort Colors</h2>

<h2 id="一次循环排序0-1-2">一次循环排序0、1、2</h2>

<p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p>

<p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>

<p><em>Note:</em> You are not suppose to use the library&rsquo;s sort function for this problem.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: [2,0,2,1,1,0]</p>

<p>Output: [0,0,1,1,2,2]</p>
</blockquote>

<p><em>Follow up:</em></p>

<ul>
<li>A rather straight forward solution is a two-pass algorithm using counting sort.</li>
</ul>

<p>First, iterate the array counting number of 0&rsquo;s, 1&rsquo;s, and 2&rsquo;s, then overwrite array with total number of 0&rsquo;s, then 1&rsquo;s and followed by 2&rsquo;s.</p>

<ul>
<li>Could you come up with a one-pass algorithm using only constant space?</li>
</ul>

<h3 id="解答-7">解答：</h3>

<pre><code class="language-java">class Solution {
    public void sortColors(int[] nums) {
        int low = 0;
        int high = nums.length-1;
        int i=0;
        while(i&lt;=high){
            //nums[i]=0|1,i进位
            if(nums[i]==0){
                //若nums[low]=1,交换后nums[low]=0,nums[i]=1,之后则i进位跳过1，若有0再交换使0永远再1之前
                nums[i]=nums[low];
                nums[low]=0;
                low++;
            }else if(nums[i]==2){
                //nums[i]==2,i不进位
                nums[i]=nums[high];
                nums[high]=2;
                high--;
                i--;
            }
            i++;
        }
    }
}
</code></pre>

<hr />

<h1 id="array-and-strings">Array and Strings</h1>

<h2 id="3sum">3Sum</h2>

<h2 id="找出三个和为0的数">找出三个和为0的数</h2>

<p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p>*Note:*The solution set must not contain duplicate triplets.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>

<p>A solution set is:
[[-1, 0, 1],[-1, -1, 2]]</p>
</blockquote>

<h3 id="解答-8">解答：</h3>

<pre><code class="language-java">class Solution {
    //TLE超时
    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {
        Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
        Arrays.sort(nums);
        for(int i=0;i&lt;nums.length;i++){
            for(int j=i+1;j&lt;nums.length;j++){
                if(nums[i]+nums[j]&gt;0){break;}
                for(int k=j+1;k&lt;nums.length;k++){
                    if(nums[i]+nums[j]+nums[k]&gt;0){break;}
                    if(nums[i]+nums[j]+nums[k]==0){
                        List&lt;Integer&gt; item = new ArrayList&lt;&gt;();
                        item.add(nums[i]);
                        item.add(nums[j]);
                        item.add(nums[k]);
                        Collections.sort(item);
                        set.add(item);
                    }
                }
            }
        }
        return new ArrayList(set);
    }
}
</code></pre>

<h2 id="increasing-triplet-subsequence">Increasing Triplet Subsequence</h2>

<p>Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.</p>

<p>Formally the function should:</p>

<blockquote>
<p>Return true if there exists i, j, k</p>

<p>such that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.</p>
</blockquote>

<p><em>Note:</em> Your algorithm should run in O(n) time complexity and O(1) space complexity.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: [1,2,3,4,5]</p>

<p>Output: true</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: [5,4,3,2,1]</p>

<p>Output: false</p>
</blockquote>

<h3 id="解答-9">解答：</h3>

<pre><code class="language-java">class Solution {
    public boolean increasingTriplet(int[] nums) {
        /* 适用于多个下标，不只ijk三个下标
        if(nums.length&lt;3){return false;}
        int[] ijk = new int[3];
        Arrays.fill(ijk,Integer.MAX_VALUE);
        for(int num:nums){
            for(int j=0;j&lt;3;j++){
                //比较k时，num已大于ij
                if(j==2){return true;}
                if(num&lt;=ijk[j]){
                    ijk[j]=num;
                    break;
                }
            }
        }
        return false;
        */
        int i = Integer.MAX_VALUE,j = Integer.MAX_VALUE;
        for(int num:nums){
            if(num&lt;=i){
                i=num;
            }else if(num&lt;=j){
                j=num;
            }else{
                return true;
            }
        }
        return false;
    }
}
</code></pre>

<h2 id="group-anagrams">Group Anagrams</h2>

<p>Given an array of strings, group anagrams together.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: [&ldquo;eat&rdquo;, &ldquo;tea&rdquo;, &ldquo;tan&rdquo;, &ldquo;ate&rdquo;, &ldquo;nat&rdquo;, &ldquo;bat&rdquo;],</p>

<p>Output:[[&ldquo;ate&rdquo;,&ldquo;eat&rdquo;,&ldquo;tea&rdquo;],</p>

<p>[&ldquo;nat&rdquo;,&ldquo;tan&rdquo;],</p>

<p>[&ldquo;bat&rdquo;]]</p>
</blockquote>

<p><em>Note:</em></p>

<ul>
<li><p>All inputs will be in lowercase.</p></li>

<li><p>The order of your output does not matter.</p></li>
</ul>

<h3 id="解答-10">解答：</h3>

<pre><code class="language-java">class Solution {
    //16ms，key为字母排序后的字符串，检验map中是否存在key
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        if(strs==null || strs.length==0) return null;
        HashMap&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;();
        for(String s : strs){
            char[] key=s.toCharArray();
            Arrays.sort(key);
            String st=String.valueOf(key);
            if(!map.containsKey(st)) map.put(st,new ArrayList());
            map.get(st).add(s);
        }
        return new ArrayList(map.values());        
    }
    //775 ms，每个字符串排序字母后比较每个List&lt;String&gt;的排序字母后的字符串
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {
        List&lt;List&lt;String&gt;&gt; group = new ArrayList&lt;&gt;();
            for(String s:strs){
                char[] temp = s.toCharArray();
                Arrays.sort(temp);
                String sortS = String.valueOf(temp);
                boolean have = false;
                for(List&lt;String&gt; list:group){
                    if(s.length()!=list.get(0).length()){continue;}
                    char[] chs = list.get(0).toCharArray();
                    Arrays.sort(chs);
                    String sortChs = String.valueOf(chs);
                    if(sortChs.equals(sortS)) {
                        have = true;
                        list.add(s);
                        break;
                    }
                }
                if(!have) {
                    List&lt;String&gt; newList = new ArrayList&lt;&gt;();
                    newList.add(s);
                    group.add(newList);
                }
          }
        return group;
    }
}
</code></pre>

<hr />

<h1 id="linked-list">Linked List</h1>

<h2 id="odd-even-linked-list">Odd Even Linked List</h2>

<p>Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.</p>

<p>You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p>

<p>Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</p>

<p>Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</p>
</blockquote>

<h3 id="解答-11">解答：</h3>

<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head!=null){
            ListNode odd=head,even=head.next,evenHead=even;
            while(even!=null&amp;&amp;even.next!=null){
                odd.next = odd.next.next; 
                even.next = even.next.next; 
                odd = odd.next;
                even = even.next;
            }
            odd.next = evenHead; 
        }
        return head;
    }
    public ListNode oddEvenList(ListNode head) {
        if(head==null||head.next==null||head.next.next==null){return head;}
        ListNode odd = new ListNode(head.val);
        ListNode startOdd = odd;
        ListNode even = new ListNode(head.val);
        ListNode startEven = even;
        int count=1;
        while(head!=null){
            if(count%2==1){
                odd.next = new ListNode(head.val);
                odd = odd.next;
            }else{
                even.next = new ListNode(head.val);
                even = even.next;
            }
            head=head.next;
            count++;
        }
        odd.next = startEven.next;
        return startOdd.next;
    }
}
</code></pre>

<h2 id="add-two-numbers">Add Two Numbers</h2>

<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>

<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</p>

<p>Output: 7 -&gt; 0 -&gt; 8</p>

<p>Explanation: 342 + 465 = 807.</p>
</blockquote>

<h3 id="解答-12">解答：</h3>

<pre><code class="language-java">/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode node = new ListNode(0);
        ListNode pre = node;
        int sum = 0;
        //l1=[6 7],l2=[6 7]
        while(l1!=null||l2!=null){
            if(l1!=null){
                sum+=l1.val;
                l1=l1.next;
            }
            if(l2!=null){
                sum+=l2.val;
                l2=l2.next;
            }
            /**
             *sum=12/pre.next=2
             *sum=1
             *sum=15/pre.next=5
             *sum=1
             */
            pre.next = new ListNode(sum%10);
            pre = pre.next;
            sum/=10;
        }
        //pre.next=sum=1
        if(sum==1){pre.next=new ListNode(1);}
        return node.next;
    }
}
</code></pre>

<hr />

<h1 id="math">Math</h1>

<h2 id="factorial-trailing-zeroes">Factorial Trailing Zeroes</h2>

<p>Given an integer n, return the number of trailing zeroes in n!.</p>

<p><em>Example 1:</em></p>

<blockquote>
<p>Input: 3</p>

<p>Output: 0</p>

<p>Explanation: 3! = 6, no trailing zero.</p>
</blockquote>

<p><em>Example 2:</em></p>

<blockquote>
<p>Input: 5</p>

<p>Output: 1</p>

<p>Explanation: 5! = 120, one trailing zero.</p>
</blockquote>

<p><em>Note:</em> Your solution should be in logarithmic time complexity.</p>

<h3 id="解答-13">解答：</h3>

<pre><code class="language-java">class Solution {
    /**
    * 1*2*3*…*n=1*2*3*(2*2)*5*(2*3)*(2*2*2)*(3*3)*(2*5)*…
    * 只有2*5所得结果尾部为0
    * 2的个数比5多
    * 可得0的个数 = n由多少个5的乘积组成
    */
    public int trailingZeroes(int n) {
        if(n==0){return 0;}
        return n/5+trailingZeroes(n/5);
    }
}
</code></pre>

<h2 id="happy-number">Happy Number</h2>

<p>Write an algorithm to determine if a number is &ldquo;happy&rdquo;.</p>

<p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>

<p><em>Example:</em></p>

<blockquote>
<p>Input: 19</p>

<p>Output: true</p>

<p>Explanation:</p>

<p>1^2 + 9^2 = 82</p>

<p>8^2 + 2^2 = 68</p>

<p>6^2 + 8^2 = 100</p>

<p>1^2 + 0^2 + 0^2 = 1</p>
</blockquote>

<h3 id="解答-14">解答：</h3>

<pre><code class="language-java">class Solution {
    public boolean isHappy(int n) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        while(n!=1){
            String s = String.valueOf(n);
            list.add(s);
            char[] chs = s.toCharArray();
            n=0;
            for(char c:chs){n+=Math.pow(Integer.parseInt(c+&quot;&quot;),2);}
            //若list中存在该数，则将陷入循环
            if(list.contains(String.valueOf(n))){return false;}
        }
        return true;
    }
}
</code></pre>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Kuma2x </span>
                </p>
            
           
           
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://boseman1024.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">
                    #数据结构与算法</a></span>
            
            <span class="tag"><a href="https://boseman1024.github.io/tags/leetcode/">
                    #LeetCode</a></span>
            
            <span class="tag"><a href="https://boseman1024.github.io/tags/java/">
                    #JAVA</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://boseman1024.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://boseman1024.github.io/2018/top-interview-questions-easy-1/" class="prev" rel="prev" title="Top Interview Questions-Easy-①"><i class="iconfont icon-left"></i>&nbsp;Top Interview Questions-Easy-①</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2018 - 2018</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://boseman1024.github.io/">Kuma2x</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
