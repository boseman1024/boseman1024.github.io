<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>轴心 on 轴心</title>
    <link>https://boseman1024.github.io/</link>
    <description>Recent content in 轴心 on 轴心</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Jan 2019 19:50:12 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>面试题总结</title>
      <link>https://boseman1024.github.io/2019/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 09 Jan 2019 19:50:12 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2019/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</guid>
      <description>

&lt;h1 id=&#34;计算机基础知识&#34;&gt;计算机基础知识&lt;/h1&gt;

&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是队列、栈、链表&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是树（平衡树,排序树,B树,B+树,R树,红黑树）、堆（大根堆、小根堆）、图（有向图、无向图、拓扑）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;栈和队列的相同和不同之处&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;栈通常采用的两种存储结构&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;两个栈实现队列，和两个队列实现栈&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;算法&#34;&gt;算法&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;排序都有哪几种方法？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;会写常用的排序算法，如快排，归并等。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;各种排序算法的时间复杂度和稳定性 ，重点快排。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;单链表的遍历和逆序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;深度优先搜索和广度优先搜索&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最小生成树&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常见Hash算法，哈希的原理和代价&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;全排列、贪心算法、KMP算法、hash算法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一致性Hash算法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;操作系统&#34;&gt;操作系统&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;虚拟内存管理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;换页算法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进程间通信&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进程同步：生产者消费者问题、哲学家就餐问题、读者写者问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;死锁的四个必要条件，避免方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Linux的一些基本命令，如ls、tail、chmod等&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;tcp,udp区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP请求和响应的全过程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP常见响应码：200、301、302、404、500&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;get和post的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;forward和redirect的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;osi七层模型&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;答：&lt;/em&gt; 物理层-数据链路层-网络层-传输层-会话层-表示层-应用层&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;tcp/ip四层模型及原理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TCP和UDP区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TCP的三次握手，四次关闭&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;答：&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;TCP三次握手过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步：client发送syn 到server 发起握手；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二步：server收到syn后回复syn+ack给client；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三步：client收到syn+ack后，回复server一个ack表示收到了server的syn+ack&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TCP四次关闭（挥手）：&lt;/p&gt;

&lt;p&gt;关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;第一步：主动方发送fin+ack到被动方发起请求关闭连接；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第二步：被动方收到后回复ack给主动方表示收到fin+ack；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第三步：被动方发送fin+ack到主动方表示同意关闭连接；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;第四步：主动方收到fin+ack后回复ack表示收到fin+ack；&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;丢包,粘包，&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;容量控制，拥塞控制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;子网划分&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IPV4和IPV6&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTPS和HTTP/2&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;数据库&#34;&gt;数据库&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;范式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据库事务和隔离级别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;为什么需要锁，锁定分类，锁粒度&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;乐观锁，悲观锁的概念及实现方式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分页如何实现（Oracle，MySql）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mysql引擎&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;MYSQL语句优化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从一张大表读取数据，如何解决性能问题&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内连接，左连接，右连接作用及区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Statement和PreparedStatement之间的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;索引以及索引的实现(B+树介绍、和B树、R树区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是数据库连接池&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;海量数据处理&#34;&gt;海量数据处理&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;海量日志数据，如何提取出某日访问淘宝次数最多的IP&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;上亿数据，统计其中出现次数最多的前N个数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;5亿个int，找出他们的中位数&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;两个文件，各存放50亿条URL，每个URL占64字节。内存限制是4G，找出两个文件中相同的URL&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;有40亿个不重复的unsigned int的整数，没排过序，现在给一个数，如何快速判断这个数是否在这40亿个数当中。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;提示：分治、Hash映射、堆排序、双层桶划分、Bloom filter、bitmap、数据库索引、mapreduce&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;java基础&#34;&gt;Java基础&lt;/h1&gt;

&lt;h2 id=&#34;封装-继承-多态&#34;&gt;封装、继承、多态&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java中实现多态的机制是什么，动态多态和静态多态的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口和抽象类的区别，如何选择&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java能不能多继承，可不可以多实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Static Nested Class 和 Inner Class的不同&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;重载和重写的区别。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;是否可以继承String类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;构造器是否可被override?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;public,protected,private的区别?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;集合相关&#34;&gt;集合相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;列举几个Java中Collection类库中的常用类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;List、Set、Map是否都继承自Collection接口？存储特点分别是什么？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ArrayList、LinkedList和Vector之间的区别与联系&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HashMap和Hashtable、TreeMap以及ConcurrentHashMap的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Collection 和 Collections的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;其他的集合类：treeset,linkedhashmap等。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;异常相关&#34;&gt;异常相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Error和Exception的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;异常的类型，什么是运行时异常&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;final、finally和finalize的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;try-catch-finally中，如果在catch中return了，finally中的代码还会执行么，原理是什么？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;列举3个以上的RuntimeException&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中的异常处理机制的简单原理和应用&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;其它&#34;&gt;其它&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;String和StringBuffer、StringBuilder的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;==和equals的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hashCode的作用，和equals方法的关系&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Input/OutputStream和Reader/Writer有什么区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何在字符流和字节流之间转换？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;switch可以使用那些数据类型&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java的四种引用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序列化与反序列化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;正则表达式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;int和Integer的区别，什么是自动装箱和自动拆箱&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;java高级&#34;&gt;Java高级&lt;/h1&gt;

&lt;h2 id=&#34;多线程&#34;&gt;多线程&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;进程和线程的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;并行和并发的区别和联系&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同步与异步&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;多线程的实现方式，有什么区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么叫守护线程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何停止一个线程？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是线程安全？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;synchronized 和 lock的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动一个线程是用run()还是start()?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;wait和sleep的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;notify和notifyAll的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程池的作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中线程池相关的类&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;jvm底层技术&#34;&gt;JVM底层技术&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;gc的概念，如果A和B对象循环引用，是否可以被GC？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jvm gc如何判断对象是否需要回收，有哪几种方式？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中能不能主动触发GC&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JVM的内存结构，堆和栈的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JVM堆的分代&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中的内存溢出是什么，和内存泄露有什么关系&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java的类加载机制，什么是双亲委派&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ClassLoader的类加载方式&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;io&#34;&gt;IO&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;NIO、AIO和BIO 之间的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;IO和NIO常用用法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;其它-1&#34;&gt;其它&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;hashcode 有哪些算法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;反射的基本概念，反射是否可以调用私有方法&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中范型的概念&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JVM启动参数，-Xms和 -Xmx&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;代理机制的实现&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String s = new String(&amp;ldquo;s&amp;rdquo;)，创建了几个对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;答：&lt;/em&gt; 如果常量池中已存在“s”，则直接引用，即只会创建一个对象；若常量池中不存在，则先创建后引用，也就是有两个。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;java-web&#34;&gt;Java Web&lt;/h1&gt;

&lt;h2 id=&#34;servlet&#34;&gt;Servlet&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;JSP和Servlet的区别，Servelt的概念。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Servlet的生命周期&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Servlet中的session工作原理 ，以及设置过期时间的方式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Servlet中，filter的应用场景有哪些？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;JSP的动态include和静态include&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;web.xml中常用配置及作用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Servlet的线程安全问题&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;mvc框架&#34;&gt;MVC框架&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;介绍几个常用的MVC框架&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是MVC&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Struts中请求的实现过程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spring mvc与Struts mvc的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Service嵌套事务处理，如何回滚&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struts2 中拦截器与过滤器的区别及执行顺序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;struts2拦截器的实现原理&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;http相关&#34;&gt;http相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;session和cookie的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP请求中session实现原理？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果客户端禁止Cookie能实现Session吗？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;http中 get和post区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;redirect与forward的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常见的web请求返回的状态码。404、302、301、500分别代表什么&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;ssh相关&#34;&gt;SSH相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Hibernate/Ibatis/MyBatis之间的区别&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是OR Mapping&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;hibernate的缓存机制、一级和二级缓存&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用Spring的好处是什么，Spring的核心理念&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是AOP和IOC，实现原理是什么&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;spring bean的初始化过程&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spring的事务管理 ，Spring bean注入的几种方式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;spring四种依赖注入方式&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;容器相关&#34;&gt;容器相关&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是web服务器、什么是应用服务器&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常用的web服务器有哪些？&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Tomcat和weblogic的区别&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;web安全&#34;&gt;web安全&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;什么是SQL注入 ，如何避免。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是XSS攻击，如何避免&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是CSRF攻击，如何避免&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;动态代理&#34;&gt;动态代理&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java的动态代理的概念&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java的动态代理的实现&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;编码问题&#34;&gt;编码问题&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;常用的字符编码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如何解决中文乱码问题&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;其它-2&#34;&gt;其它&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;XML的解析方式，以及优缺点。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;什么是ajax，Ajax如何解决跨域问题&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;设计模式&#34;&gt;设计模式&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;谈一下自己了解或者熟悉的设计模式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Singleton的几种实现方式，实现一个线程安全的单例。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;工厂模式和抽象工厂模式之间的区别&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;知识的综合能力&#34;&gt;知识的综合能力&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;请介绍一下一个http请求的全过程，描述的越全面越好&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;当你在浏览器地址栏输入www.taobao.com，敲下回车之后都发生了什么&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;工具使用&#34;&gt;工具使用&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;知道git/svn是干什么的吗？用过吗&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;知道maven/gradle是干什么的吗？用过吗&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;平常使用什么IDE，为什么&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;平常使用什么浏览器，为什么&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;平常开发机器是什么操作系统的&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;会在Linux上开发吗。Linux常用命令会吗&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;技术热情&#34;&gt;技术热情&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当前Java的最新版本&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java8的lambda表达式&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java8的stream API&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java9的模块化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java10的局部变量类型推断&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Spring Boot2.0&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;HTTP/2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;会翻墙么，知道翻墙的原理吗&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>技术文章索引</title>
      <link>https://boseman1024.github.io/2019/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Wed, 09 Jan 2019 19:42:33 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2019/%E6%8A%80%E6%9C%AF%E6%96%87%E7%AB%A0%E7%B4%A2%E5%BC%95/</guid>
      <description>

&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#java&#34;&gt;JAVA基础&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rpc&#34;&gt;RPC&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#TCP&#34;&gt;TCP/IP、HTTP&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-name-java-style-cursor-default-color-000-java基础-a&#34;&gt;&lt;a name=&#34;java&#34; style=&#34;cursor:default;color:#000;&#34;&gt;JAVA基础&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;amp;mid=2650121551&amp;amp;idx=1&amp;amp;sn=b14691e0daeca8d1283fc8a860732405&amp;amp;chksm=f36bb86ec41c3178bb5f17ae733ffa73a7249e39fcc473f63db928c909466397b352b493c0a3&amp;amp;scene=21#wechat_redirect&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;String有关的那点事儿&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/1150&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Java对象的序列化与反序列化&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-name-rpc-style-cursor-default-color-000-rpc-a&#34;&gt;&lt;a name=&#34;rpc&#34; style=&#34;cursor:default;color:#000;&#34;&gt;RPC&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/2accc2840a1b&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;什么是RPC&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.jianshu.com/p/5b90a4e70783&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;实现一个简单的RPC&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;a-name-tcp-style-cursor-default-color-000-tcp-ip-http-a&#34;&gt;&lt;a name=&#34;TCP&#34; style=&#34;cursor:default;color:#000;&#34;&gt;TCP/IP、HTTP&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://102.alibaba.com/detail?id=140&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;TCP 三次握手原理&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>IN 2019</title>
      <link>https://boseman1024.github.io/2019/in-2019/</link>
      <pubDate>Tue, 01 Jan 2019 10:42:33 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2019/in-2019/</guid>
      <description>

&lt;p&gt;&lt;center&gt;
&lt;h1&gt;SHUT UP!&lt;/h1&gt;
&lt;h2&gt;黙ってくれ！&lt;/h2&gt;
&lt;h3&gt;静かに。&lt;/h3&gt;
&lt;h4&gt;BE SILENT.&lt;/h4&gt;
&lt;h5&gt;2019&lt;/h5&gt;
&lt;/center&gt;&lt;/p&gt;

&lt;h1 id=&#34;六月&#34;&gt;六月&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;6月10日21点58分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记：&lt;/p&gt;

&lt;p&gt;《人生的智慧》——叔本华&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-建议和格言-我们对待自己的态度&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;「歌德的美妙诗句“我从不寄托希望在任何事情”其实就是说：只有当人挣脱了所有各种可能的期望，从而返回赤裸和冰冷的存在本身，人才能领会到精神上的安宁，而精神的安宁却是幸福的构成基础。」&lt;/p&gt;

&lt;p&gt;「所有局限和节制都有助于增进我们的幸福。我们的视线、活动和接触的范围圈子越狭窄，我们就越幸福；范围圈子越大，我们感受的焦虑或者担忧就越多。因为随着这一范围较大的扩大，我们的愿望、恐惧、担忧也就相应增加。」&lt;/p&gt;

&lt;p&gt;「所有局限制约——甚至精神方面的——都有助于增进我们的幸福。原因就在于意欲受到的刺激越少，我们的痛苦也就越少。」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6月5日22点01分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;记：&lt;/p&gt;

&lt;p&gt;《人生的智慧》——叔本华&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-人所展现的表象&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;「如果一个人是否具备价值只能取决于这个人在别人的眼中所呈现的样子，那这样的生存将是悲惨的。如果一个英雄或者天才所具有的价值真的只在于他所拥有的名声，亦即在于他人对他的首肯，那么，他的一生就确实够悲惨了。但真实的情形却恰恰不是这样。每个人都根据其自身本性而生存，因此，他首先是以自身的样子为自己而活。对于一个人来说，他的自身本性，不管其存在方式为何，才是重要的东西。如果这个人的自身本性欠缺价值，那他这个人也就欠缺价值。相比之下，他在别人头脑中的形象却是次要和枝节的东西，它受制于偶然，对他本人也只能施加间接的影响。」&lt;/p&gt;

&lt;p&gt;「到海外旅行的人只是变换了气候而已，他们并不曾改变思想意识。」&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-建议和格言-泛论&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;「“理性的人寻求的不是快乐，而只是没有痛苦。”这一句话所包含的真理在于：所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。
　　……
　　在这里我用一个日常司空见惯的事实对此真理加以解释。加入我们身体的整体健康并不会进入我们的意识，我们的注意力始终只集中在那疼痛的伤处。我们生活中的总体舒适感觉就会因这一小处伤痛而烟消云散。同样，尽管各样事情都按照我们的想法进行和发展，但只要有一件事情违反了我们的意愿——尽管这只是一件微不足道的事情——这一并不如意的事情就会进入我们的头脑；我们就会总是惦记着这一件事情，而不会想到其他更重要的、已经如我们所愿发生了的事情。在这两个例子里，我们的意欲都受到了伤害。在第一个例子，意欲客体化在人的机体里；在第二个例子，意欲则客体化在人的渴求、愿望当中。在上述两种情况，我们都可看到意欲的满足并不直接被我们感受得到，它顶多只以反省、回顾的方式进入我们的意识。但是，意欲受到的抵制却是肯定的，因此，这种状况会明确表示出来。每一快感的产生其实就是意欲所受到的抵制得到了消除，意欲获得了解放。所以，每一种快感都持续相当短暂的时间。」&lt;/p&gt;

&lt;p&gt;「我们对于幸福的过分期待毁坏了这世上的一切，毁坏的程度与我们做梦的程度相一致。谁要是摆脱了过分的期待，除了自己已经拥有的以外，不再奢望更多，那么，他就能够安然无恙地生活下去（《梅克通信录》）。」&lt;/p&gt;

&lt;h1 id=&#34;五月&#34;&gt;五月&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;5月19日13点33分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘✘✘✘，✘✘✘✘✘✘✘✘，✘✘✘✘✘。&lt;/p&gt;

&lt;h1 id=&#34;四月&#34;&gt;四月&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;4月21日21点03分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘。&lt;/p&gt;

&lt;h1 id=&#34;三月&#34;&gt;三月&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;3月26日22点07分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘，✘✘。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3月8日21点02分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘：✘✘✘、✘✘✘✘、✘✘✘✘、✘✘✘✘。&lt;/p&gt;

&lt;h1 id=&#34;二月&#34;&gt;二月&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;2月7日11点45分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘，✘✘，✘✘。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2月6日23点39分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘✘✘✘。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;《✘✘》✘✘✘✘✘；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;《✘✘✘✘✘》✘✘✘✘%✘✘。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;记：&lt;/p&gt;

&lt;p&gt;《作为意志和表象的世界》——叔本华&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-遵循充足理由原则的表象：经验与科学的对象&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;「当自己认知太阳和大地时，认知的并非太阳和大地本身，而是见到太阳的眼睛和触摸大地的手；他周围的世界只是表象，只是和意志有关的东西，和人类有关的东西。」&lt;/p&gt;

&lt;p&gt;「因此，在讨论充足理由原理的论文中，我也讨论过空间和时间的问题，我们感觉空间和时间是纯粹的，没有内容，是一种特殊而独立的观念。康德发现的这种直觉的种种普遍形式的性质，这种普遍形式离开经验而就其本身加以认识的性质，即这种普遍形式可以视为表现数学基础的那些法则的性质，当然非常重要。&lt;/p&gt;

&lt;p&gt;　　可是，空间和时间的另一种性质，也应该说明，把经验限制为因果法则和动机法则，并作为判断基本法则的充足理由原理，以一种完全特殊的形式出现。我曾经给这个特殊形式一个名称，即“存在者的基础”，就是时间方面来说，是时间片断的连续；就空间来说，是空间各部分的位置彼此限定。&lt;/p&gt;

&lt;p&gt;　　任何人只要从前面的引论了解到，在充足理由原则下，所有不同形式的内容完全相同，一定会相信认识这些形式中的最简单形式也相当重要，这就让他体验到自己内在的本性。这个原理的最简单形式就是时间。在时间中，只有后一刹那排除前一刹那时，每一刹那才是它的产生者，而它本身也会很快地又被另一刹那所消灭。&lt;/p&gt;

&lt;p&gt;　　过去和未来，像梦一样空幻，现在唯一不能分开的，是它们之间的短暂界限。在充足理由原理的所有其他形式中，我们会发现一些枯燥空洞的东西，也会了解，不但时间只有相对的存在，空间及时间的内容，所有从原因和动机产生的东西，也只有相对的存在，它们都只是通过另一个和本身相似的东西而存在。&lt;/p&gt;

&lt;p&gt;　　这个看法古来有之：当赫拉克里特叹息万物永远流转时，就是在表达这个看法；当柏拉图把客体对象贬为永远变动不居而非永远不变的恒定者时，他也在表达这个看法；当斯宾诺莎提出所谓唯一存在、永久实体的偶然性质的说法，还是在表达这个看法。&lt;/p&gt;

&lt;p&gt;　　康德把现象和物自体对立。古代印度哲人的只会告诉我们：“人类眼睛看到的是一个自己无法说存在还是不存在的世界，它是摩耶，是骗人的障幕；它像梦幻，像照在沙上的阳光，让远处的旅人以为是水，或把草绳误当作蛇。”但是，所有这些话的意义以及它们所表明的，只是我们刚才所说的服从充足理由原则的表象世界。」&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2月5日12点16分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘✘✘✘。&lt;/p&gt;

&lt;p&gt;✘✘✘✘。&lt;/p&gt;

&lt;p&gt;✘✘✘✘。&lt;/p&gt;

&lt;p&gt;✘✘：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;✘✘✘✘✘✘✘&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;✘✘✘✘✘✘&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;✘✘✘✘✘✘✘✘&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;✘✘✘&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;✘✘✘✘&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2月3日10点56分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘✘。&lt;/p&gt;

&lt;h1 id=&#34;一月&#34;&gt;一月&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1月10日23点38分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘✘✘✘。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1月4日12点23分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘✘✘✘，✘✘✘✘✘。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1月1日10点42分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;✘✘。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>计算机网络笔记</title>
      <link>https://boseman1024.github.io/2018/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 06 Dec 2018 13:46:33 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h1 id=&#34;概论&#34;&gt;概论&lt;/h1&gt;

&lt;h2 id=&#34;计算机网络的功能&#34;&gt;计算机网络的功能&lt;/h2&gt;

&lt;p&gt;实现网络中资源共享和数据交换。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;数据通信&lt;/code&gt;：数据通信是计算机网络最基本的功能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;资源共享&lt;/code&gt;：软、硬件资源共享、数据共享。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;实现分布式处理&lt;/code&gt;：
   均衡各计算机的负载 、充分利用网络资源 、并构成高性能的计算机体系。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;集中管理&lt;/code&gt;：通过MIS系统、OA等系统可以实现日常工作的集中管理，提高工作效率，增加经济效益。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;提高可靠性&lt;/code&gt;：重要的资源可以通过网络在多个地点互做备份，并使用用户可以通过几条路由来访问网内的资源，从而可以有效地避免单个部件、计算机等的故障影响用户的使用。&lt;/p&gt;

&lt;h2 id=&#34;计算机网络的组成&#34;&gt;计算机网络的组成&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;通信子网&lt;/code&gt;：传输介质（电缆、光纤、无线电波等）、通信设备（交换机等），承担全网的数据传输、转接、加工和变换等通信处理工作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;资源子网&lt;/code&gt;：硬件资源（主机、终端、I/O设备等）、软件资源、数据资源等，负责全网数据处理业务，向网络用户提供各种网络资源和网络服务。&lt;/p&gt;

&lt;h2 id=&#34;计算机网络的分类&#34;&gt;计算机网络的分类&lt;/h2&gt;

&lt;h3 id=&#34;按网络覆盖范围分类&#34;&gt;按网络覆盖范围分类&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;局域网（LAN）&lt;/code&gt;：通常是由地理范围在几公里以内的、采用单一或有限的传输介质、按照某种网络结构相互连接起来的计算机组成的网络。采用广播(broadcast)技术共享传输媒介传送。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：分布距离近（通常在1000-2000m范围内），传输速度高，连接费用低，数据传输可靠，延迟低，误码率低，易维护。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;广域网（WAN）&lt;/code&gt;：也称为远程网，它的联网设备分布范围很广，从数百公里至数千或数万公里不等。它所涉及的地理范围可以是市、地区、省、国家，乃至世界范围。广域网是通过卫星、微波、无线电、电话线、光纤等传输介质连接的国家网络和国际网络，它是全球计算机网络的主干网络。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：地理范围没有限制；传输介质复杂；由于长距离的传输，数据的传输速率较低，且容易出现错误，采用的技术比较复杂。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;城域网（MAN）&lt;/code&gt;：传送距离介于LAN和WAN之间(通常是一个城市）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：采用的传输介质相对复杂；数据传输速率次于局域网；数据传输距离相对局域网要长，信号容易受到干扰；组网比较复杂，成本较高。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;区域网（CAN）&lt;/code&gt;：介于LAN和MAN 之间的自治性网络，由某一实体（企业、高校、小区、研究院所、政府等）独立管理，若干相对独立的LAN组成，外连城域网或因特网。&lt;/p&gt;

&lt;h3 id=&#34;按网络通信方式分类&#34;&gt;按网络通信方式分类&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;点到点式网络&lt;/code&gt;：点到点传播指网络中每两台主机、两台节点交换机之间或主机与节点交换机之间都存在一条物理信道，即每条物理线路连接一对计算机。机器（包括主机和节点交换机）沿某信道发送的数据确定无疑地只有信道另一端的唯一一台机器收到。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;广播式网络&lt;/code&gt;：广播式网络中的广播是指网络中所有连网计算机都共享一个公共通信信道，当一台计算机利用共享通信信道发送报文分组时，所有其它计算机都会将会接收并处理这个分组。由于发送的分组中带有目的地址与源地址，网络中所有计算机接收到该分组的计算机将检查目的地址是否与本节点的地址相同。如果被接受报文分组的目的地址与本节点地址相同，则接受该分组，否则将收到的分组丢弃。&lt;/p&gt;

&lt;h3 id=&#34;按拓补结构分类&#34;&gt;按拓补结构分类&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;星型&lt;/code&gt;：均需通过中央节点。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;总线型&lt;/code&gt;：一次只允许传输一路信号。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;环型&lt;/code&gt;：成闭合环形发送数据。&lt;/p&gt;

&lt;h2 id=&#34;网络协议三要素&#34;&gt;网络协议三要素&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;语法&lt;/code&gt;：数据与控制信息的结构或格式 。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;语义&lt;/code&gt;：需要发出何种控制信息，完成何种动作以及做出何种响应。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;时序&lt;/code&gt;：事件实现顺序的详细说明。&lt;/p&gt;

&lt;h2 id=&#34;osi参考模型&#34;&gt;OSI参考模型&lt;/h2&gt;

&lt;p&gt;⑦&lt;strong&gt;应用层&lt;/strong&gt;——⑥&lt;strong&gt;表示层&lt;/strong&gt;——⑤&lt;strong&gt;会话层&lt;/strong&gt;——④&lt;strong&gt;传输层&lt;/strong&gt;——③&lt;strong&gt;网络层&lt;/strong&gt;——②&lt;strong&gt;数据链路层&lt;/strong&gt;——①&lt;strong&gt;物理层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;软件（⑦⑥⑤④）&lt;/code&gt;：由软件实现（面向通信用户），资源子网的任务。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;网络（③②①）&lt;/code&gt;：由硬件实现（完成传送服务），通信子网任务。&lt;/p&gt;

&lt;p&gt;同层对等实体间进行信息交换时必须遵守的规则称为&lt;strong&gt;协议&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;相邻层间进行信息交换时必须遵守的规则称为&lt;strong&gt;接口&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;下一层对上一层提供操作服务称为&lt;strong&gt;服务&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上一层对下一层通过称为&lt;strong&gt;调用&lt;/strong&gt;关系实现。&lt;/p&gt;

&lt;h2 id=&#34;tcp-ip的体系结构&#34;&gt;TCP/IP的体系结构&lt;/h2&gt;

&lt;p&gt;⑤&lt;strong&gt;应用层&lt;/strong&gt;——④&lt;strong&gt;传输层&lt;/strong&gt;——③&lt;strong&gt;网络层&lt;/strong&gt;——②&lt;strong&gt;数据链路层&lt;/strong&gt;——①&lt;strong&gt;物理层&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;数据传送顺序&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;主机1——&lt;/p&gt;

&lt;p&gt;⑤（应用进程数据加上应用层首部，成为应用层 PDU）&lt;/p&gt;

&lt;p&gt;④（应用层 PDU加上运输层首部，成为运输层报文）&lt;/p&gt;

&lt;p&gt;③（运输层报文加上网络层首部，成为IP数据报（或分组））&lt;/p&gt;

&lt;p&gt;②（IP数据报加上链路层首部和尾部，成为数据链路层帧）&lt;/p&gt;

&lt;p&gt;①（把比特流传送到物理媒体）&lt;/p&gt;

&lt;p&gt;—物理传输媒体—①②③④⑤——主机2&lt;/p&gt;

&lt;h2 id=&#34;题&#34;&gt;题&lt;/h2&gt;

&lt;p&gt;（×）如果一台计算机可以和其它地理位置的另一台计算机进行通信，那么这台计算机就是一个遵循OSI标准的开放系统。&lt;/p&gt;

&lt;p&gt;（×）ISO划分网络层次的基本原则是：不同的节点都有相同的层次；不同节点的相同层次可以有不同的功能。&lt;/p&gt;

&lt;p&gt;（√）协议是“水平的”，即协议是控制对等实体之间的通信的规则。&lt;/p&gt;

&lt;p&gt;（√）服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。&lt;/p&gt;

&lt;p&gt;（√）数据链路不等同于链路，它在链路上加了控制数据传输的规程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网卡&lt;/strong&gt;实现的主要功能是物理层与数据链路层的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;网络层的功能&lt;/strong&gt;：路由选择、流量控制、分组交换。&lt;/p&gt;

&lt;p&gt;在开放系统连接环境中，&lt;strong&gt;两个N层实体进行通信&lt;/strong&gt;，他们可能用到的服务是&lt;strong&gt;N-1层&lt;/strong&gt;提供的服务。&lt;/p&gt;

&lt;p&gt;对等实体在一次交互作用中传送的信息单位称为&lt;strong&gt;协议数据单元&lt;/strong&gt;，它包括&lt;strong&gt;控制信息和用户信息&lt;/strong&gt;两部分。&lt;/p&gt;

&lt;p&gt;网络协议是计算机网络和分布系统中相互通信的&lt;strong&gt;同等层实体&lt;/strong&gt;间交换信息时必须遵守的规则的集合。&lt;/p&gt;

&lt;p&gt;协议的关键成分中&lt;strong&gt;语法&lt;/strong&gt;是数据和控制信息的结构或格式；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语义&lt;/strong&gt;是用于协调和进行差错处理的控制信息；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;时序&lt;/strong&gt;是对事件实现顺序的详细说明。&lt;/p&gt;

&lt;p&gt;而网络体系结构则是&lt;strong&gt;网络各层、层中协议和层间接口的集合&lt;/strong&gt;。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;数据通信和物理层&#34;&gt;数据通信和物理层&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;物理层的主要任务&lt;/code&gt;：确定与传输媒体的接口的一些特性，即：
&lt;strong&gt;机械特性&lt;/strong&gt;、&lt;strong&gt;电气特性&lt;/strong&gt;、&lt;strong&gt;功能特性&lt;/strong&gt;、&lt;strong&gt;规程特性&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&#34;数据通信系统的模型&#34;&gt;数据通信系统的模型&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://jpjtrg.bn.files.1drv.com/y4mUYJxKCTijL06-OuCllUQoZqPviVjZYFyU6zU5Pze3DewVoSDyRZeZAzZgVIzQjkSqofnu-95Ipkz3ZOw2v_OLEXaoTyAOL4VTdQqC0s9vewv6zvOD7lp5MyWkMESXlLdb6Cs1ZO1aCcnKfpaLhijpQRPp2BFoj19rOBWIlml4ngS-KJSeMmFxDS2Ymisxo_m2ch_1WMR1Lau856nNWzO5A/data-communication-systems.png&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;模拟信号&lt;/code&gt;：信号电平是连续变化的；时间上连续，包含无穷多个值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;数字信号&lt;/code&gt;：用两种不同的电平去表示0、1比特序列的电压脉冲信号表示；时间上离散，仅包含有限数目的预定值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;信道&lt;/code&gt;：向某一个方向传输信息的媒体。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;模拟信道&lt;/code&gt;：用来传输连续的模拟信号(如正弦波信号)的信道。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;数字信道&lt;/code&gt;：用来传输离散的数字信号(如脉冲信号)的信道。&lt;/p&gt;

&lt;h2 id=&#34;数据通信系统的指标&#34;&gt;数据通信系统的指标&lt;/h2&gt;

&lt;p&gt;为了衡量数据传输的&lt;strong&gt;有效性&lt;/strong&gt;和&lt;strong&gt;可靠性&lt;/strong&gt;，数据通信系统的性能指标主要有以下几项 ：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;波特率：码元的传输速率。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;比特率：信息的传输速率。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;信道容量：信道能达到的最大传输能力。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;误码率：数据通信系统的传输可靠性的指标。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;码元&lt;/code&gt;：承载信息量的基本信号单位，一码元就是一个单位电脉冲。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;一码元所承载的信息量&lt;/code&gt;：一个码元（脉冲）可取&lt;strong&gt;M&lt;/strong&gt;个有效值时，则该码元能携带&lt;strong&gt;log₂M(bit)&lt;/strong&gt;二进制信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;波特率(RB)&lt;/code&gt;：又称为码元传输速率、码元速率或传码率。每秒传输信号码元的个数，单位为“波特”,常用符号“Baud”表示，简写为“B”。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;比特率(Rb)&lt;/code&gt;：又称数据传输速率。比特的传输速率，单位为比特/秒（bit/s）、位/秒，简记为b/s或bps；表示为&lt;strong&gt;实际的数据传输速率&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;信道容量&lt;/code&gt;：一个信道传输数据的能力,单位也用位/秒(bps)，表示&lt;strong&gt;信道的最大数据传输速率&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;数据速率 = 码元速率 * log₂Ｍ （M为一码元所承载的信息量）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题①&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;假设某信道的最大码元传输速率为2400baud，采用四电平的编码方式，该信道的最高数据传输速率是多少？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;数据速率 = 2400 * log₂4 = 4800 bps&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题②&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;设数据信号码元长度为833×10ˉ⁶秒，如采用16电平传输，试求数据传信速率和调制速率？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;调制速率 = 1 / (833 * 10ˉ⁶) = 1200B&lt;/p&gt;

&lt;p&gt;数据速率 = 1200 * log₂4 = 4800bps&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;信道带宽&lt;/code&gt;：网络信号可使用的最高频率与最低频率之差，或者说是“频带的宽度” ，单位是赫（Hz）。&lt;/p&gt;

&lt;p&gt;计算机网络中&lt;code&gt;带宽&lt;/code&gt;是数字信道所能传送的“&lt;strong&gt;最高数据率&lt;/strong&gt;”的同义语，单位是b/s (bit/s)。&lt;/p&gt;

&lt;p&gt;常用的带宽单位：&lt;/p&gt;

&lt;p&gt;千比每秒，即 kb/s （10³b/s）&lt;/p&gt;

&lt;p&gt;兆比每秒，即 Mb/s（10⁶b/s）&lt;/p&gt;

&lt;p&gt;吉比每秒，即 Gb/s（10⁹b/s）&lt;/p&gt;

&lt;p&gt;太比每秒，即 Tb/s（10¹²b/s）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;有600MB的数据，要甲地传送到乙地。设信息传送的速率是56Kb/s，则从甲到乙要多长时间？如果信息传送的速率是10Mb/s呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;1B=8bit&lt;/p&gt;

&lt;p&gt;600MB = 600 * 1024 * 1024 * 8 = 5033164800 bit&lt;/p&gt;

&lt;p&gt;① 600MB / (56 * 10³) ≈ 89878s&lt;/p&gt;

&lt;p&gt;② 600MB / (10 * 10⁶) ≈ 503s&lt;/p&gt;

&lt;p&gt;&lt;code&gt;时延&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;发送时延（传输时延 ）：发送数据时，数据块从结点进入到传输媒体所需要的时间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;信道带宽：数据在信道上的发送速率。常称为数据在信道上的传输速率。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;发送时延 = 数据块长度（比特）/ 信道带宽（比特/秒）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;传播时延：电磁波在信道中需要传播一定的距离而花费的时间。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;传播时延 = 信道长度（米）/ 信号在信道上的传播速率（米/秒）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;处理时延：交换结点为存储转发而进行一些必要的处理所花费的时间，处理时延的长短往往取决于网络中当时的通信量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;总时延 = 发送时延 + 传播时延 + 处理时延&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;收发两端之间的传输距离为1000km，信号在媒体上的传播速率为2×10⁸m/s。试计算以下两种情况的发送时延和传播时延：&lt;/p&gt;

&lt;p&gt;①数据长度为10⁷bit，数据发送速率为100kb/s。&lt;/p&gt;

&lt;p&gt;②数据长度为10³bit，数据发送速率为1Gb/s。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;传播时延 = 1000km / 2×10⁸m/s = 0.005s&lt;/p&gt;

&lt;p&gt;① 发送时延 = 10⁷ / (100 * 10³) = 100s&lt;/p&gt;

&lt;p&gt;② 发送时延 = 10³ / (1 * 10⁹) = 10ˉ⁶s&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;链路的时延带宽积：以比特为单位的链路长度。 表示发送端连续发送数据时，发送的第一个比特即将到达终点时，发送端就已经发送了“时延带宽积 ”个比特&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;时延带宽积 = 传播时延 * 带宽&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;假设信号在媒体上的传播速率为2.3×10⁸m/s。媒体长度l分别为：①10cm（网卡）②100m（局域网）③100km（城域网）④5000km（广域网），试计算当带宽为1Mb/s和10Gb/s时在以上媒体中正在传输的比特数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;传播时延 = ①4.35*10ˉ¹⁰ ②4.35*10ˉ⁷③4.35*10ˉ⁴④0.0217 s&lt;/p&gt;

&lt;p&gt;1Mb/s=10⁶b/s：&lt;/p&gt;

&lt;p&gt;①4.35*10ˉ¹⁰*10⁶=4.35*10ˉ⁴s&lt;/p&gt;

&lt;p&gt;②4.35*10ˉ⁷*10⁶=0.435s&lt;/p&gt;

&lt;p&gt;③4.35*10ˉ⁴*10⁶=4.35*10²s&lt;/p&gt;

&lt;p&gt;④0.0217*10⁶=2.17*10⁴s&lt;/p&gt;

&lt;p&gt;10Gb/s=10¹⁰b/s：&lt;/p&gt;

&lt;p&gt;①4.35*10ˉ¹⁰*10¹⁰=4.35&lt;/p&gt;

&lt;p&gt;②4.35*10ˉ⁷*10¹⁰=4.35*10³&lt;/p&gt;

&lt;p&gt;③4.35*10ˉ⁴*10¹⁰=4.35*10⁶s&lt;/p&gt;

&lt;p&gt;④0.0217*10¹⁰=2.17*10⁸s&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;利用率&lt;/code&gt;：有&lt;strong&gt;信道利用率&lt;/strong&gt;和&lt;strong&gt;网络利用率&lt;/strong&gt;两种。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;误码率&lt;/code&gt;：指二进制数据位传输时出错的概率，是衡量数据通信系统在正常工作情况下的传输可靠性的指标。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;误码率Pe  = 传错码元数(Ne) / 码元总数(N)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;一个二进制数字信号码元时间长度为0.1μs，在传输过程中平均2.5秒产生1个错码，求其平均误码率。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;1μs = 10ˉ⁶s&lt;/p&gt;

&lt;p&gt;2.5秒传输码元数 = 2.5 / 0.1 * 10ˉ⁶ = 2.5 * 10⁷&lt;/p&gt;

&lt;p&gt;平均误码率 = 1 / (2.5 * 10⁷ ) = 4×10ˉ⁸&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;奈氏(Nyquist)准则&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;理想低通信道的最高码元传输速率 = 2W Baud，W是理想低通信道的带宽，单位为赫(Hz)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每赫带宽的理想低通信道的最高码元传输速率是每秒2个码元。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;奈奎斯特公式&lt;/code&gt;：信道最大的数据传输速率( C )=2*W*log₂M(bps)，M表示一码元所承载的信息量。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;理想带通特性信道的最高码元传输速率 = W Baud，W是理想带通信道的带宽，单位为赫(Hz)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;每赫带宽的理想带通信道的最高码元传输速率是每秒1个码元。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;香农(Shannon)定理&lt;/code&gt;：信道的极限信息传输速率( C )=W*log₂(1+S/N) (b/s)，S为信道内所传信号的平均功率，N为信道内部的高斯噪声功率。&lt;/p&gt;

&lt;p&gt;由于实际使用的信道的信噪比都要足够大，故常表示成&lt;strong&gt;10×log₁₀(S/N)&lt;/strong&gt;，以&lt;strong&gt;分贝(dB)&lt;/strong&gt;为单位来计量，在使用时要特别注意。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题①&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;信噪比为30dB,带宽为3kHZ的信道的最大数据传输速率为？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;信噪比=30dB，且10×log₁₀(S/N)=30成立，可得S/N=1000。&lt;/p&gt;

&lt;p&gt;由香农定理可得 C=3000×log₂(1+1000)≈30kbps。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题②&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;某一待传输的图片约含2.25×10⁶个象元。为了很好的重现图片需要16个亮度电平。假若所有这些亮度电平等概率出现，试计算用3分钟传送一张图片时所需要的信道带宽（设信道中信噪功率比30dB）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;比特率R = (2.25*10⁶*log₂16) / (3*60) = 5×10⁴b/s&lt;/p&gt;

&lt;p&gt;信噪比=30dB，且10×log₁₀(S/N)=30成立，可得S/N=1000。&lt;/p&gt;

&lt;p&gt;由于最大比特率C&amp;gt;=R，即W*log₂(1+S/N)&amp;gt;=5×10⁴b/s，则W&amp;gt;=5×10³Hz。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题③&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在一个带宽为3kHz、没有噪声的信道，传输二进制信号时能够达到的极限数据传输率为（&lt;strong&gt;6Kbps&lt;/strong&gt;）。一个带宽为3kHz、信噪比为30dB的信道，能够达到的极限数据传输率为（&lt;strong&gt;30Kbps&lt;/strong&gt;）。上述结果表明，（&lt;strong&gt;条件不同，不能进行直接的比较&lt;/strong&gt;）。根据Nyquist定理，为了保证传输质量，达到3Kbps的数据传输率需要的带宽为（&lt;strong&gt;6kHz&lt;/strong&gt;）。在一个无限带宽的无噪声信道上，传输二进制信号，当信号的带宽为3kHz时，能达到的极限数据传输率为（&lt;strong&gt;6&lt;/strong&gt;）Kbps。&lt;/p&gt;

&lt;h2 id=&#34;数据通信方式&#34;&gt;数据通信方式&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;信息交互方式&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单工模式（单向通信）：信息只能朝着一个方向传递，信息传输方向不能改变。只需一条信道。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;半双工模式（双向交替通信）：数据信息可以双向传递，但不能同时进行。在此方式中信息流轮流使用发送和接收装置。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;全双工模式（双向同时通信）：能同时进行双向通信。需要两条不同方向的信道。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;各个二进制位是否同时传输&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并行传输：几位数据同时从一个设备发往另一设备，传输速度快。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;串行传输：数据一位位地按顺序传送，一次只能传送一位。实现容易，但传输速度慢。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;串行传输方式&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;同步传输：以固定的时钟节拍来连续串行发送数字信号，要求接收端按照发送端所发送码元的频率或起止时间来接收数据，使得收发双方在时序上保持一致。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;异步传输：以字符为单位进行同步的，以字符为传输单位，字符与字符（一个字符结束到下一个字符开始）之间的时间间隔是可变的，并不需要严格地限制它们的时间关系。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;题&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;异步传输中，假定停止位为2位，1位偶校验，数据位为8位，传输效率为多少？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;传输效率 = 8 / (1+1+2+8) = 66.6%&lt;/p&gt;

&lt;p&gt;&lt;code&gt;基带频带方式&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基带传输：在信道中直接传送基带信号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;频带传输：将基带信号调制成模拟信号，放到信道的通频带宽之内进行传输。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;基带信号&lt;/strong&gt;：指在通信电缆上原封不动的传输有计算机或终端产生的0或1数字脉冲信号。就是将数字信号 1 或 0 直接用两种不同的电压来表示，然后送到线路上去传输。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;宽带信号&lt;/strong&gt;：是将基带信号进行调制后形成的频分复用模拟信号。&lt;/p&gt;

&lt;h2 id=&#34;数据编码技术&#34;&gt;数据编码技术&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;数据编码方式&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;模拟数据编码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数字数据编码&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模拟数据和数字数据都可以用模拟信号或数字信号来表示，因而也可以用其中任意一种形式传输。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;数字信号编码技术&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;非归零码NRZ：用信号的幅值来表示二进制数据，负电平用于示一个二进制值，正电平用于表示另一个二进制值。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;曼彻斯特编码：每个比特间隔的中间位置处都存在一个跳变。这种中间处的跳变既含有时钟信息，也含有数据信息：从低到高的跳变代表1，从高到低的跳变代表0（注意有些系统也可能相反）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;差分曼彻斯特编码：比特间隔中间位置处的跳变仅含有时钟信息。在比特间隔开始处如果出现跳变表示0，如果没有跳变表示1。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;解码&lt;/strong&gt;：在解码过程，只要把前一位的后半位和本位的前半位进行“异或”即可判别出“0”或“1”的不同状态。两者相同，表示在码位之间无跳变发生，表示的是“1”；两者不同，表示在码位之间有跳变发生，表示的是“0”。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mB/nB编码：把m比特的二进制数据块（block）用n比特的二进制代码块来表示。2m个数据码是从2n个nB码选出来的。根据需要，一般要使“0”和“1”等概率、连续的“0”和“1”数目小。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于mB/nB码，编码开销增加了&lt;strong&gt;(n-m)/m%&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4B/5B编码&lt;/strong&gt;：把4比特的二进制数据块用5比特的二进制码代码块来表示，将欲发送的数据流每4比特作为一块，然后将每一块按4B/5B编码规则转换成相应的5B码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i5jtrg.bn.files.1drv.com/y4mcaDGHdiSqyFE-nbbAgrdh-UOp7dqyYpJrQjCncqp3CXIEn1GlUhDLWyo6GtXzU6RvQ5_g9hEjSwlI9Q3Pj7Zzw3Ig3X6ebuTCrTZwoI_6KMiFHnYF0hksDtPv-rguL275a_fQqBzQY_lia2ujcCsUZqkFX-804XYqmXqWmFxC0GqXFP6Dz2tgbpAFAgujwZA3Azcx5Nl-uzbKoozg9H_wQ/4B-5B.PNG&#34;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;多进制编码：数字数据编码中，通常利用码元的某些特征，如幅值、相位等来携带数字数据，这些特征可以有多种状态，称为码元状态数，每种状态可以表示一个数，编成多进制码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;调制器&lt;/code&gt;：把要发送的基带信号转换为频率范围在300-3400Hz之间的模拟信号（载波信号，载波通常是正弦波或余弦波），以便在电话用户线上传送。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;解调器&lt;/code&gt;：把电话用户线上传送来的模拟信号转换为数字信号。&lt;/p&gt;

&lt;p&gt;模拟信号是借助于载波实现的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;载波信号&lt;/strong&gt;：表示为余弦波形式 S(t)=Acos(2πft+θ)。&lt;/p&gt;

&lt;p&gt;频率、幅值和相位是余弦波形函数的三个重要特征，把一个数字数据调制成模拟信号，就是用一个数字数据控制周期信号的幅度、频率或相位。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;数字数据的模拟编码分类&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;幅移键控法(ASK)：又称幅度调制，用被传输的数字数据去调制载波信号的振幅。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若载波信号为Acos(2πft+θ)，则振幅调制信号可以表示为：&lt;/p&gt;

&lt;p&gt;数字数据为1：Acos(2πft+θ)&lt;/p&gt;

&lt;p&gt;数字数据为0：0&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：噪声通常只影响振幅，所以ASK是受噪声影响最大的调制技术。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;频移键控法(FSK)：又称频率调制，用被传输的数字数据去调制载波信号的频率。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若载波信号为Acos(2πft+θ)，则频率调制信号可以表示为：&lt;/p&gt;

&lt;p&gt;数字数据为1：Acos(2πf₁t+θ)&lt;/p&gt;

&lt;p&gt;数字数据为0：Acos(2πf₂t+θ)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：抗干扰性能优于ASK（噪声对其影响小）。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;相移键控法(PSK)：又称相位调制，用被传输的数字数据去调制载波信号的相位。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若载波信号为Acos(2πft+θ)，则相位调制信号可以表示为：&lt;/p&gt;

&lt;p&gt;数字数据为1：Acos(2πft+θ)&lt;/p&gt;

&lt;p&gt;数字数据为0：Acos(2πft+θ+π)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kpls0q.bn.files.1drv.com/y4mNcqZGwScQkCuaRQi1Z9ik36OSlxELiW6ukyIiBUtJbP_M0Gmq9M47_s5rPLti-xnV3efhkkoe4xjXaqNzit39UwK7du5yDt9OTpTLlVQV_TgkXPx8Wo_QIiPuCnt9sT80M01KhahnP1jvBOzsDJMY-jmhW-SIqRfW-O6HeMybHTuKikUoeP1jRHqAXTm2cxiwrrvqRep7CwB8ON1cJY64w/key.PNG&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;题&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;PCM是现代电话系统的核心。对于一个声音信道：带宽为4kHz，每秒采样多少次可完整地表示声音信号的特征？若量化级为128级，一条数字线路的数据传输速率为多少才能不失真地传输声音？若量化级为256级，数据传输速率又为多少？如果每个样本增加1位冗余，数据传输速率应达到多少？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;采样速率位8000样本/秒。&lt;/p&gt;

&lt;p&gt;声音分为128个量化级：&lt;/p&gt;

&lt;p&gt;每个量化级采用7位二进制编码表示，即2⁷=128，&lt;/p&gt;

&lt;p&gt;数据传输速率应达到7位*8000 =56kb/s。&lt;/p&gt;

&lt;p&gt;声音分为256个量化级：&lt;/p&gt;

&lt;p&gt;每个量化级采用8位二进制编码表示，即2⁸=256，&lt;/p&gt;

&lt;p&gt;数据传输速率应达到8位*8000 =64kb/s。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;传输层&#34;&gt;传输层&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;传输层功能&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;连接管理&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;流量控制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;差错检测&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对用户请求的响应&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建立无连接或面向连接的通信&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;端口&#34;&gt;端口&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;端口&lt;/code&gt;：让应用层的各种应用进程都能将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程，即用来标志应用层的进程。在通信时，只有找到了端口，才能最后找到我们所要找的目的进程。 其用一个 16 位二进制比特进行标识。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;端口分类&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;熟知端口：号码为0-1023的端口才能作为熟知端口。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&#34;https://jjjtrg.bn.files.1drv.com/y4mZOtK4hHHbiQ-rToxgqIiBl-7rRmt9Om3MzsTbd064gLeNTeaSXvjpJdSo08UDn-RwTkZLQTgJRWiY_kyxFcMb2NpMAhjgoM6qNjCcmBOdNChoAulCzrDTd5MqduoH4SF9S0R2TYq9mFJNw5s4HIy4TwaRZ9y7ad-zxMRTULJLrMS4ljJSMi4Hra8ykRtS7Or0sJ4ZIBCSLtLfybQWYb9IQ/port.PNG&#34;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;注册端口：操作系统将这些端口动态的分配给各个进程，同一进程两次分配有可能分配到不同的端口。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;传输层协议&#34;&gt;传输层协议&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;传输协议数据单元&lt;/code&gt;：两个对等传输实体在通信时传送的数据单位叫作传输协议数据单元TPDU。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;用户数据报协议UDP&lt;/code&gt;：无连接的传输服务，不需要先建立连接，对方的传输层在收到 UDP报文后，不需要给出任何确认。逻辑通信信道是一条不可靠信道。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协议数据单元&lt;/strong&gt;：UDP报文或用户数据报&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UDP是无连接的，即发送数据之前不需要建立连接，因而减少了开销和发送数据之前的时延。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UDP没有拥塞控制，也不保证可靠交付，因此主机不需要维持具有许多参数的、复杂的连接状态表。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络出现的拥塞不会使源主机的发送速率降低。这对传输实时数据是很重要的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UDP 支持一对一、一对多、多对一和多对多的交互通信。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UDP 的首部开销小，只有8个字节。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;UDP 是面向报文的。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;使用UDP协议的各种应用和应用层协议&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mzjtrg.bn.files.1drv.com/y4mXf4PyqNdMa6uTNP5rpPcOX63-ncjwOic2kMXCF4O2_dsJqHLYC6173OM9NGhGpP_gU9-zkZwmVsPOXn248sIVvA2RehfJi_t6ZDUGe0yKjyShrxPHCQJgtUxIT5OArDrQaY3Qc2_3sgfrDRxcvDDJ6obG6Zm_OF0l3XpHQ8aFDoOY8P9o81VBPTlw2wL4lb5TdcGpCP-tiC-c7q5tEhVgA/UDP-port.PNG&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;UDP首部格式&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://mpjtrg.bn.files.1drv.com/y4mkpO0v0YDgcEae5pbnOZIalxHIye82M-EJ0YO69cVaCK_kS78eaAWF49Rve3r1ENiOaZZ4-91L5tLnxJzus9Li13H1nOxgVndvku6Klrdq_89QDa13cJk2xaba7_rnQPxPy9BCv0uUiCnML4twZ657cmxE6J2vxq3JXQk_nP2C06laO-3Bjhx6sAZYPBPOhI15ecDT4qV9sN1pLPSYziFPg/UDP.PNG&#34;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;源端口：发送端的UDP端口，当不需要返回数据时，该字段为0。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;目的端口：接收端的UDP端口，必须使用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;长度：UDP数据报总长度，其最小值是8（仅有首部）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检验和：在计算检验和时，临时把“伪首部”和UDP用户数据报连接在一起。伪首部仅仅是为了计算检验和，不进行传输。该字段是可选的，如果该字段为“0”就表示不计算检验和。当应用程序对传输效率的重视程度高于可靠性时，就可以选择不进行检验。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;传输控制协议TCP&lt;/code&gt;：提供可靠的、面向连接的传输服务。逻辑通信信道是一条全双工可靠信道。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协议数据单元&lt;/strong&gt;：TCP报文段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;TCP是面向连接的传输层协议。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;由于TCP 连接只能有两个端点(endpoint)，因此TCP连接只能是点对点的（一对一）。TCP不能用于多播和广播。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;TCP提供全双工通信。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;面向字节流。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;TCP首部格式&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kzls0q.bn.files.1drv.com/y4mdakKV_zCzEXG5-fdTr1DG0KNGMgTYeT4MbUs1yKo-VbbCX0xUxWElHBa-RE9S9mMT9mN0rT1wJVp0LRODplTs2tXwa34IFqo78M0qXMNSl88syBjp4oibENHjKWztq7QSJ7B74lpu3Z1Q7Sl_T1OzkOIMAHrsp3Txv8ih_rdznqvDsIZCKxMVF7ADDbOXK5iL68ag9RgUdEdRryEJp8DOA/TCP.png&#34;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;源端口、目的端口：传输层与应用层的服务接口。传输层的复用和分用功能都要通过端口才能实现。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;序号：TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确认号：用于接收方对发送方发出的数据的累积确认，说明该序号之前的数据均已正确接收，也就是接收方希望接收的下一个报文段的第一个字节的序号。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;数据偏移：指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。“数据偏移”的单位是32位字（以4字节为计算单位）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;保留：保留为今后使用，但目前应置为0。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;紧急URG：当URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;确认ACK：只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效。TCP规定，在连接建立后所有传送的报文都必须把ACK置1。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;推送PSH：接收端TCP收到PSH=1的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;复位RST：当RST=1时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因）必须释放连接，然后再重新建立传输连接。RST置1还用来拒绝一个非法的报文或拒绝打开一个连接。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;同步SYN：同步SYN=1表示这是一个连接请求或连接接受报文。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;终止FIN：用来释放一个连接。FIN=1表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;窗口：用来让对方设置发送窗口的依据，单位为字节。从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。实际上反映了接收方目前可用的缓冲区的大小。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;检验和：检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。TCP的检验和是必须的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;紧急指针：指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。紧急指针仅在URG=1时才有效。即使窗口为0时也可发送紧急数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;填充：为了使整个首部长度是4字节的整数倍，填充字段为全0。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;TCP流量控制&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流量控制&lt;/strong&gt;：让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。定义了发送方在收到从接收方发来的确认之前可以发送的数据量。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;流量控制方式&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;缓存：发送进程和接收进程产生和消耗数据的速度并不一样，因此TCP需要缓存来存储数据。在每一个方向都有两个缓存，即发送缓存和接收缓存。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;滑动窗口：窗口大小的单位是字节。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>杂题</title>
      <link>https://boseman1024.github.io/2018/%E6%9D%82%E9%A2%98/</link>
      <pubDate>Wed, 07 Nov 2018 20:21:33 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E6%9D%82%E9%A2%98/</guid>
      <description>&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;题目：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1000 瓶无色无味的药水，其中有一瓶毒药，10只小白鼠拿过来做实验。喝了无毒的药水第二天没事儿，喝了有毒的药水后第二天会死亡。如何在一天之内(第二天)找出这瓶有毒的药水？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1000个瓶子可以用10位二进制数表示(0-1023)&lt;/p&gt;

&lt;p&gt;那么10个老鼠可以分别代表一个二进制位&lt;/p&gt;

&lt;p&gt;也就是说是为了找到这个10位二进制数每一位是0或者是1&lt;/p&gt;

&lt;p&gt;为了方便我还是假设有1024个瓶子吧&lt;/p&gt;

&lt;p&gt;老鼠1-10分别从低位到高位编码，那么：&lt;/p&gt;

&lt;p&gt;老鼠01：选择第1, 3, 5&amp;hellip;1023瓶共512瓶药混在一块，给它喝&lt;/p&gt;

&lt;p&gt;老鼠02：选择第1-2, 5-6, 9-10&amp;hellip;1021-1022瓶共512瓶药混在一块，给它喝&lt;/p&gt;

&lt;p&gt;老鼠03：选择第1-4, 9-12, 17-20&amp;hellip;1017-1020瓶共512瓶药混在一块，给它喝&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;老鼠10：选择第1-512瓶共512瓶药混在一块，给它喝&lt;/p&gt;

&lt;p&gt;这样第二天10个老鼠有些会死，有些不会死，死代表1，活代表0，这样把10个老鼠排在一块就能有一个二进制数，就是毒药的序号&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Top Interview Questions-Medium-①</title>
      <link>https://boseman1024.github.io/2018/top-interview-questions-medium-1/</link>
      <pubDate>Sat, 29 Sep 2018 22:59:34 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/top-interview-questions-medium-1/</guid>
      <description>

&lt;h1 id=&#34;design&#34;&gt;Design&lt;/h1&gt;

&lt;h2 id=&#34;insert-delete-getrandom-o-1&#34;&gt;Insert Delete GetRandom O(1)&lt;/h2&gt;

&lt;h2 id=&#34;设计数据结构实现时间复杂度为o-1-的插入-删除-获取随机数&#34;&gt;设计数据结构实现时间复杂度为O(1)的插入、删除、获取随机数&lt;/h2&gt;

&lt;p&gt;Design a data structure that supports all following operations in average O(1) time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;insert(val): Inserts an item val to the set if not already present.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;remove(val): Removes an item val from the set if present.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;// Init an empty set.&lt;/p&gt;

&lt;p&gt;RandomizedSet randomSet = new RandomizedSet();&lt;/p&gt;

&lt;p&gt;// Inserts 1 to the set. Returns true as 1 was inserted successfully.&lt;/p&gt;

&lt;p&gt;randomSet.insert(1);&lt;/p&gt;

&lt;p&gt;// Returns false as 2 does not exist in the set.&lt;/p&gt;

&lt;p&gt;randomSet.remove(2);&lt;/p&gt;

&lt;p&gt;// Inserts 2 to the set, returns true. Set now contains [1,2].&lt;/p&gt;

&lt;p&gt;randomSet.insert(2);&lt;/p&gt;

&lt;p&gt;// getRandom should return either 1 or 2 randomly.&lt;/p&gt;

&lt;p&gt;randomSet.getRandom();&lt;/p&gt;

&lt;p&gt;// Removes 1 from the set, returns true. Set now contains [2].&lt;/p&gt;

&lt;p&gt;randomSet.remove(1);&lt;/p&gt;

&lt;p&gt;// 2 was already in the set, so return false.&lt;/p&gt;

&lt;p&gt;randomSet.insert(2);&lt;/p&gt;

&lt;p&gt;// Since 2 is the only number in the set, getRandom always return 2.&lt;/p&gt;

&lt;p&gt;randomSet.getRandom();&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class RandomizedSet {
    Map&amp;lt;Integer,Integer&amp;gt; map; //存放元素及其在list中的下标
    List&amp;lt;Integer&amp;gt; list;//存放元素
    int size = 0;
    /** Initialize your data structure here. */
    public RandomizedSet() {
        map = new HashMap&amp;lt;&amp;gt;();
        list = new ArrayList&amp;lt;&amp;gt;();
    }
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        if(map.containsKey(val)){return false;}
        map.put(val,size);
        list.add(val);
        size++;
        return true;
    }
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        if(map.containsKey(val)){
            int last = list.get(size-1);
            list.set(map.get(val),last);//将数组尾元素赋值给val所在下标元素
            list.remove(size-1);//移除数组尾元素
            map.put(last,map.get(val));//数组尾元素重新定位为val所在下标
            map.remove(val);//移除val
            size--;
            return true;
        }
        return false;
    }
    /** Get a random element from the set. */
    public int getRandom() {
        return list.get(new Random().nextInt(size));
    }
}
/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;trees-and-graphs&#34;&gt;Trees and Graphs&lt;/h1&gt;

&lt;h2 id=&#34;binary-tree-zigzag-level-order-traversal&#34;&gt;Binary Tree Zigzag Level Order Traversal&lt;/h2&gt;

&lt;h2 id=&#34;之字形打印二叉树&#34;&gt;之字形打印二叉树&lt;/h2&gt;

&lt;p&gt;Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given binary tree &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;return its zigzag level order traversal as:
[[3],&lt;/p&gt;

&lt;p&gt;[20,9],&lt;/p&gt;

&lt;p&gt;[15,7]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-1&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        if(root==null){return list;}
        list.add(new ArrayList());
        //使用两个栈分别存放正序层和倒序层
        Stack&amp;lt;TreeNode&amp;gt; stack1 = new Stack&amp;lt;&amp;gt;();
        Stack&amp;lt;TreeNode&amp;gt; stack2 = new Stack&amp;lt;&amp;gt;();
        stack1.push(root);
        int level = 0;
        while(!stack1.empty()||!stack2.empty()){
            //根据层数从对应栈里出栈
            TreeNode node = level%2==0?stack1.pop():stack2.pop();
            list.get(level).add(node.val);
            if(level%2==0){
                if(node.left!=null){stack2.push(node.left);}
                if(node.right!=null){stack2.push(node.right);}
            }else{
                if(node.right!=null){stack1.push(node.right);}
                if(node.left!=null){stack1.push(node.left);}
            }
            //偶数层、倒序栈不为空且正序栈为空
            //奇数层、正序栈不为空且倒序栈为空
            //进入下一层
            if((level%2==0&amp;amp;&amp;amp;!stack2.empty()&amp;amp;&amp;amp;stack1.empty())||(level%2==1&amp;amp;&amp;amp;!stack1.empty()&amp;amp;&amp;amp;stack2.empty())){
                level++;
                list.add(new ArrayList());
            }
        }
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;construct-binary-tree-from-preorder-and-inorder-traversal&#34;&gt;Construct Binary Tree from Preorder and Inorder Traversal&lt;/h2&gt;

&lt;h2 id=&#34;根据先序-中序遍历生存二叉树&#34;&gt;根据先序、中序遍历生存二叉树&lt;/h2&gt;

&lt;p&gt;Given preorder and inorder traversal of a tree, construct the binary tree.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You may assume that duplicates do not exist in the tree.&lt;/p&gt;

&lt;p&gt;For example, given&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;preorder = [3,9,20,15,7]&lt;/p&gt;

&lt;p&gt;inorder = [9,3,15,20,7]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Return the following binary tree:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;　　　3&lt;/p&gt;

&lt;p&gt;　　9　20&lt;/p&gt;

&lt;p&gt;　　　15　7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-2&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    Map&amp;lt;Integer,Integer&amp;gt; inorderMap;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        inorderMap = new HashMap&amp;lt;&amp;gt;();
        for(int i=0;i&amp;lt;inorder.length;i++){
            inorderMap.put(inorder[i],i);
        }
        return build(preorder,0,preorder.length-1,inorder,0,inorder.length-1);
    }
    public TreeNode build(int[] preorder,int preStart,int preEnd,int[] inorder,int inStart,int inEnd){
        if(preStart&amp;gt;preEnd||inStart&amp;gt;inEnd){return null;}
        TreeNode node = new TreeNode(preorder[preStart]);
        int nodeIndex = inorderMap.get(node.val);
        /*找出该结点在中序中的位置nodeIndex
        *该节点在先序中的位置preStart
        *则先序中preStart至[preStart+nodeIndex-inStart]为该结点的左子树
        *即中序中inStart至[preStart+nodeIndex-inStart]为该结点的左子树
        *在中序中从nodeIndex开始不断收缩
        **/
        node.left = build(preorder,preStart+1,preStart+nodeIndex-inStart,inorder,inStart,nodeIndex-1);
        /*找出该结点在中序中的位置nodeIndex
        *该节点在先序中的位置preStart
        *则先序中[preStart+nodeIndex-inStart+1]开始至preEnd为该结点的右子树
        *即中序中nodeIndex+1至inEnd为该结点的右子树
        *在中序中从nodeIndex开始不断拓展
        **/
        node.right = build(preorder,preStart+nodeIndex-inStart+1,preEnd,inorder,nodeIndex+1,inEnd);
        return node;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;populating-next-right-pointers-in-each-node&#34;&gt;Populating Next Right Pointers in Each Node&lt;/h2&gt;

&lt;h2 id=&#34;将二叉树每层最右节点指向null&#34;&gt;将二叉树每层最右节点指向null&lt;/h2&gt;

&lt;p&gt;Given a binary tree&lt;/p&gt;

&lt;p&gt;Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to &lt;em&gt;NULL&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Initially, all next pointers are set to &lt;em&gt;NULL&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You may only use constant extra space.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Recursive approach is fine, implicit stack space does not count as extra space for this problem.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Given the following perfect binary tree,&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;　　1&lt;/p&gt;

&lt;p&gt;　2　　3&lt;/p&gt;

&lt;p&gt;4　5　6　7&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;After calling your function, the tree should look like:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;　　1 -&amp;gt; NULL&lt;/p&gt;

&lt;p&gt;　2　-&amp;gt;　3 -&amp;gt; NULL&lt;/p&gt;

&lt;p&gt;4 -&amp;gt; 5 -&amp;gt; 6 -&amp;gt; 7 -&amp;gt; NULL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-3&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    /**
    * 满二叉树深度为k的二叉树至多有2^k-1个结点。
    * 通过层序遍历，对遍历个数进行计数，达到最大结点个数则该结点指向null
    */
    public void connect(TreeLinkNode root) {
        if(root==null){return;}
        Queue&amp;lt;TreeLinkNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
        queue.offer(root);
        TreeLinkNode pre = root;
        int count =0;
        int level = 1;
        while(!queue.isEmpty()){
            TreeLinkNode node = queue.poll();
            count++;
            if(count==Math.pow(2,level-1)){
                pre.next = null;
                pre = node;
                level++;
            }else{
                pre.next = node;
                pre = pre.next;
            }
            if(node.left!=null){
                queue.offer(node.left);
            }
            if(node.right!=null){
                queue.offer(node.right);
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;number-of-islands&#34;&gt;Number of Islands&lt;/h2&gt;

&lt;h2 id=&#34;求出岛屿个数&#34;&gt;求出岛屿个数&lt;/h2&gt;

&lt;p&gt;Given a 2d grid map of *&amp;lsquo;1&amp;rsquo;*s (land) and &lt;em&gt;&amp;lsquo;0&amp;rsquo;s&lt;/em&gt; (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.&lt;/p&gt;

&lt;p&gt;无向图遍历，1为可移动区域&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input:&lt;/p&gt;

&lt;p&gt;11110&lt;/p&gt;

&lt;p&gt;11010&lt;/p&gt;

&lt;p&gt;11000&lt;/p&gt;

&lt;p&gt;00000&lt;/p&gt;

&lt;p&gt;Output: 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input:&lt;/p&gt;

&lt;p&gt;11000&lt;/p&gt;

&lt;p&gt;11000&lt;/p&gt;

&lt;p&gt;00100&lt;/p&gt;

&lt;p&gt;00011&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-4&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int numIslands(char[][] grid) {
        int rows = grid.length;
        if(rows==0){return 0;}
        int cols = grid[0].length;
        int count=0;
        for(int i=0;i&amp;lt;rows;i++){
            for(int j=0;j&amp;lt;cols;j++){
                if(grid[i][j]==&#39;1&#39;){
                    dfs(grid,i,j,rows,cols);
                    count++;
                }
            }
        }
        return count;
    }
    //深度搜索
    public void dfs(char[][] grid,int i,int j,int rows,int cols){
        if(i&amp;lt;0||j&amp;lt;0||i&amp;gt;=rows||j&amp;gt;=cols||grid[i][j]==&#39;0&#39;){return;}
        //剩下的grid[i][j]都为1
        //将已访问点设为0
        grid[i][j]=&#39;0&#39;;
        dfs(grid,i,j+1,rows,cols);
        dfs(grid,i,j-1,rows,cols);
        dfs(grid,i+1,j,rows,cols);
        dfs(grid,i-1,j,rows,cols);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;kth-smallest-element-in-a-bst&#34;&gt;Kth Smallest Element in a BST&lt;/h2&gt;

&lt;h2 id=&#34;找出第k小的数&#34;&gt;找出第K小的数&lt;/h2&gt;

&lt;p&gt;Given a binary search tree, write a function &lt;em&gt;kthSmallest&lt;/em&gt; to find the kth smallest element in it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You may assume k is always valid, 1 ≤ k ≤ BST&amp;rsquo;s total elements.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: root = [3,1,4,null,2], k = 1&lt;/p&gt;

&lt;p&gt;Output: 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: root = [5,3,6,2,4,null,null,1], k = 3&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-5&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //中序遍历找出第K小的数
    public int kthSmallest(TreeNode root, int k) {
        Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        stack.push(root);
        TreeNode node = root;
        while(node!=null||!stack.empty()){
            while(node!=null){
                stack.push(node);
                node = node.left;
            }
            if(!stack.empty()){
                node = stack.pop();
                k--;
                if(k==0){
                    return node.val;
                }
                node = node.right;
            }
        }
        return root.val;
        
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;binary-tree-inorder-traversal&#34;&gt;Binary Tree Inorder Traversal&lt;/h2&gt;

&lt;h2 id=&#34;二叉树非递归中序遍历&#34;&gt;二叉树非递归中序遍历&lt;/h2&gt;

&lt;p&gt;Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,null,2,3]&lt;/p&gt;

&lt;p&gt;Output: [1,3,2]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Follow up:&lt;/em&gt; Recursive solution is trivial, could you do it iteratively?&lt;/p&gt;

&lt;h3 id=&#34;解答-6&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        TreeNode node=root;
        while(node!=null||!stack.empty()){
            while(node!=null){
                stack.push(node);
                node = node.left;
            }
            if(!stack.empty()){
                node = stack.pop();
                list.add(node.val);
                node = node.right;
            }
        }
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;backtracking&#34;&gt;Backtracking&lt;/h1&gt;

&lt;h2 id=&#34;permutations&#34;&gt;Permutations&lt;/h2&gt;

&lt;h2 id=&#34;找出所有排序数列&#34;&gt;找出所有排序数列&lt;/h2&gt;

&lt;p&gt;Given a collection of distinct integers, return all possible permutations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,2,3]&lt;/p&gt;

&lt;p&gt;Output:[&lt;/p&gt;

&lt;p&gt;[1,2,3],&lt;/p&gt;

&lt;p&gt;[1,3,2],&lt;/p&gt;

&lt;p&gt;[2,1,3],&lt;/p&gt;

&lt;p&gt;[2,3,1],&lt;/p&gt;

&lt;p&gt;[3,1,2],&lt;/p&gt;

&lt;p&gt;[3,2,1]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-7&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; permute(int[] nums) {
        list = new ArrayList&amp;lt;&amp;gt;();
        permutation(nums,0);
        return list;
    }
    public void permutation(int[] nums,int begin){
        if(begin==nums.length){
            List&amp;lt;Integer&amp;gt; temp = new ArrayList&amp;lt;&amp;gt;();
            for(int i:nums){temp.add(i);}
            list.add(temp);
        }else{
            for(int i=begin;i&amp;lt;nums.length;i++){
                int temp = nums[i];
                nums[i] = nums[begin];
                nums[begin] = temp;
                permutation(nums,begin+1);
                temp = nums[i];
                nums[i] = nums[begin];
                nums[begin] = temp;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;word-search&#34;&gt;Word Search&lt;/h2&gt;

&lt;h2 id=&#34;矩阵中找单词&#34;&gt;矩阵中找单词&lt;/h2&gt;

&lt;p&gt;Given a 2D board and a word, find if the word exists in the grid.&lt;/p&gt;

&lt;p&gt;The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;board =[&lt;/p&gt;

&lt;p&gt;[&amp;lsquo;A&amp;rsquo;,&amp;lsquo;B&amp;rsquo;,&amp;lsquo;C&amp;rsquo;,&amp;lsquo;E&amp;rsquo;],&lt;/p&gt;

&lt;p&gt;[&amp;rsquo;S&amp;rsquo;,&amp;lsquo;F&amp;rsquo;,&amp;lsquo;C&amp;rsquo;,&amp;rsquo;S&amp;rsquo;],&lt;/p&gt;

&lt;p&gt;[&amp;lsquo;A&amp;rsquo;,&amp;rsquo;D&amp;rsquo;,&amp;lsquo;E&amp;rsquo;,&amp;lsquo;E&amp;rsquo;]]&lt;/p&gt;

&lt;p&gt;Given word = &amp;ldquo;ABCCED&amp;rdquo;, return true.&lt;/p&gt;

&lt;p&gt;Given word = &amp;ldquo;SEE&amp;rdquo;, return true.&lt;/p&gt;

&lt;p&gt;Given word = &amp;ldquo;ABCB&amp;rdquo;, return false.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-8&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //深度搜索
    public boolean exist(char[][] board, String word) {
        //word.charAt(i)耗时大于words[i]
        char[] words = word.toCharArray();
        for(int i=0;i&amp;lt;board.length;i++){
            for(int j=0;j&amp;lt;board[0].length;j++){
                if(DFS(board,i,j,words,0)){return true;}
            }
        }
        return false;
    }
    public boolean DFS(char[][] board,int y,int x,char[] words,int count){
        if(count==words.length){return true;}
        if(x&amp;lt;0||y&amp;lt;0||x&amp;gt;=board[0].length||y&amp;gt;=board.length){return false;}
        char c = board[y][x];
        if(c!=words[count]||c==&#39;0&#39;){return false;}
        //挖坑，标记已搜索坐标
        board[y][x]=&#39;0&#39;;
        boolean result = DFS(board,y+1,x,words,count+1)
        ||DFS(board,y-1,x,words,count+1)
        ||DFS(board,y,x+1,words,count+1)
        ||DFS(board,y,x-1,words,count+1);
        board[y][x]=c;
        return result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;sorting-and-searching&#34;&gt;Sorting and Searching&lt;/h1&gt;

&lt;h2 id=&#34;search-a-2d-matrix-ii&#34;&gt;Search a 2D Matrix II&lt;/h2&gt;

&lt;h2 id=&#34;矩阵中寻找一个数&#34;&gt;矩阵中寻找一个数&lt;/h2&gt;

&lt;p&gt;Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Integers in each row are sorted in ascending from left to right.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Integers in each column are sorted in ascending from top to bottom.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Consider the following matrix:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[[1,   4,  7, 11, 15],&lt;/p&gt;

&lt;p&gt;[2,   5,  8, 12, 19],&lt;/p&gt;

&lt;p&gt;[3,   6,  9, 16, 22],&lt;/p&gt;

&lt;p&gt;[10, 13, 14, 17, 24],&lt;/p&gt;

&lt;p&gt;[18, 21, 23, 26, 30]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Given target = 5, return true.&lt;/p&gt;

&lt;p&gt;Given target = 20, return false.&lt;/p&gt;

&lt;h3 id=&#34;解答-9&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //从矩阵下方开始，若大于目标则向上移动，若小于目标则向右移动，7ms。
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix==null||matrix.length==0||matrix[0].length==0){
            return false;
        }
        int y = matrix.length-1;
        int x = 0;
        while(y&amp;gt;=0 &amp;amp;&amp;amp; x&amp;lt;matrix[0].length){
            if(matrix[y][x] == target){return true;}
            else if(matrix[y][x] &amp;gt; target){y--;}
            else{x++;}
        }
        return false;
    }
    //对每行进行二分查找，16ms
    public boolean searchMatrix(int[][] matrix, int target) {
        for(int i=0;i&amp;lt;matrix.length;i++){
            int low = 0,high = matrix[0].length-1;
            while(low&amp;lt;=high){
                int mid = low+(high-low)/2;
                if(matrix[i][mid]&amp;gt;target){
                    high = mid-1;
                }else if(matrix[i][mid]&amp;lt;target){
                    low = mid+1;
                }else{
                    return true;
                }
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-first-and-last-position-of-element-in-sorted-array&#34;&gt;Find First and Last Position of Element in Sorted Array&lt;/h2&gt;

&lt;h2 id=&#34;二分查找范围&#34;&gt;二分查找范围&lt;/h2&gt;

&lt;p&gt;Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;If the target is not found in the array, return [-1, -1].&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [5,7,7,8,8,10], target = 8&lt;/p&gt;

&lt;p&gt;Output: [3,4]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [5,7,7,8,8,10], target = 6&lt;/p&gt;

&lt;p&gt;Output: [-1,-1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-10&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] array = new int[2];
        array[0] = findFirstIndex(nums,target);
        array[1] = findLastIndex(nums,target);
        return array;
    }
    public int findFirstIndex(int[] nums,int target){
        int low =0;
        int high = nums.length-1;
        while(low&amp;lt;=high){
            int mid = low+(high-low)/2;
            if(nums[mid]&amp;lt;target){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        return (low&amp;lt;nums.length)&amp;amp;&amp;amp;(nums[low]==target)?low:-1;
    }
    public int findLastIndex(int[] nums,int target){
        int low =0;
        int high = nums.length-1;
        while(low&amp;lt;=high){
            int mid = low+(high-low)/2;
            if(nums[mid]&amp;lt;=target){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        return (low-1&amp;gt;=0)&amp;amp;&amp;amp;(nums[low-1]==target)?low-1:-1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;find-peak-element&#34;&gt;Find Peak Element&lt;/h2&gt;

&lt;h2 id=&#34;找出一个大于前后的数&#34;&gt;找出一个大于前后的数&lt;/h2&gt;

&lt;p&gt;A peak element is an element that is greater than its neighbors.&lt;/p&gt;

&lt;p&gt;Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.&lt;/p&gt;

&lt;p&gt;The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.&lt;/p&gt;

&lt;p&gt;You may imagine that nums[-1] = nums[n] = -∞.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [1,2,3,1]&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;

&lt;p&gt;Explanation: 3 is a peak element and your function should return the index number 2.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [1,2,1,3,5,6,4]&lt;/p&gt;

&lt;p&gt;Output: 1 or 5&lt;/p&gt;

&lt;p&gt;Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-11&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //二分查找，时间O(logN)
    
    //时间O(N)
    public int findPeakElement(int[] nums) {
        if(nums.length==1){return 0;}
        //从nums[1]开始，与前一位比较，若小于前一位，则nums[i-1]为峰顶。
        //返回遇到的第一个顶峰。
        for(int i=1;i&amp;lt;nums.length;i++){
            if(nums[i]&amp;lt;nums[i-1]){return i-1;}
        }
        //最后只剩下数组最后一位数
        return nums.length-1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;kth-largest-element-in-an-array&#34;&gt;Kth Largest Element in an Array&lt;/h2&gt;

&lt;h2 id=&#34;找出数组中第k大的数&#34;&gt;找出数组中第k大的数&lt;/h2&gt;

&lt;p&gt;Find the *k*th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [3,2,1,5,6,4] and k = 2&lt;/p&gt;

&lt;p&gt;Output: 5&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [3,2,3,1,2,4,5,5,6] and k = 4&lt;/p&gt;

&lt;p&gt;Output: 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You may assume k is always valid, 1 ≤ k ≤ array&amp;rsquo;s length.&lt;/p&gt;

&lt;h3 id=&#34;解答-12&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length-k];
        //Quick Select is the fastest
        //快速选择
        
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;search-in-rotated-sorted-array&#34;&gt;Search in Rotated Sorted Array&lt;/h2&gt;

&lt;h2 id=&#34;找出一个数在旋转有序数组中的索引&#34;&gt;找出一个数在旋转有序数组中的索引&lt;/h2&gt;

&lt;p&gt;Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.&lt;/p&gt;

&lt;p&gt;(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).&lt;/p&gt;

&lt;p&gt;You are given a target value to search. If found in the array return its index, otherwise return -1.&lt;/p&gt;

&lt;p&gt;You may assume no duplicate exists in the array.&lt;/p&gt;

&lt;p&gt;Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [4,5,6,7,0,1,2], target = 0&lt;/p&gt;

&lt;p&gt;Output: 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [4,5,6,7,0,1,2], target = 3&lt;/p&gt;

&lt;p&gt;Output: -1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-13&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int search(int[] nums, int target) {
        //找出旋转轴，判断旋转轴与目标的大小，决定目标处于旋转轴哪个区间
        //二分查找
        if(nums.length==0){return -1;}
        int rotatedIndex = binarySearchRotatedIndex(nums);
        int index=-1;
        if(nums[0]&amp;lt;=target&amp;amp;&amp;amp;nums[rotatedIndex]&amp;gt;=target){
            index = binarySearch(0,rotatedIndex,nums,target);
        }else{
            index = binarySearch(rotatedIndex+1,nums.length-1,nums,target);
        }
        return index;
    }
    public int binarySearchRotatedIndex(int[] nums){
        int low = 0;
        int high = nums.length-1;
        while(low&amp;lt;=high){
            int mid = low+(high-low)/2;
            if(mid==nums.length-1){return mid;}
            if(nums[mid]&amp;gt;nums[mid+1]){
                return mid;
            }
            if(nums[mid]&amp;gt;=nums[low]){
                low = mid+1;
            }else{
                high = mid-1;
            }
        }
        return low;
    }
    public int binarySearch(int low,int high,int[] nums,int target){
        while(low&amp;lt;=high){
            int mid = low+(high-low)/2;
            if(nums[mid]&amp;gt;target){
                high = mid - 1;
            }else if(nums[mid]&amp;lt;target){
                low = mid + 1;
            }else{
                return mid;
            }
        }
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;top-k-frequent-elements&#34;&gt;Top K Frequent Elements&lt;/h2&gt;

&lt;h2 id=&#34;找出最频繁出现的k个数&#34;&gt;找出最频繁出现的K个数&lt;/h2&gt;

&lt;p&gt;Given a non-empty array of integers, return the k most frequent elements.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [1,1,1,2,2,3], k = 2&lt;/p&gt;

&lt;p&gt;Output: [1,2]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums = [1], k = 1&lt;/p&gt;

&lt;p&gt;Output: [1]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You may assume k is always valid, 1 ≤ k ≤ number of unique elements.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-14&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //24ms
    public List&amp;lt;Integer&amp;gt; topKFrequent(int[] nums, int k) {
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        //若nums长度等于k，直接返回
        if(nums.length==k){
            for(int i:nums){
                list.add(i);
            }
            return list;
        }
        Map&amp;lt;Integer,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        //修改TreeMap为降序，默认为升序
        Map&amp;lt;Integer,List&amp;lt;Integer&amp;gt;&amp;gt; mapTree = new TreeMap&amp;lt;&amp;gt;(new Comparator&amp;lt;Integer&amp;gt;() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2-o1;
            }
             
        });
        //将每个数及对应个数放入map中
        for(int i:nums){
            map.put(i,map.getOrDefault(i,0)+1);
        }
        //map键值对换，其值为mapTree的键，其键加入mapTree的值
        for(int i:map.keySet()){
            List&amp;lt;Integer&amp;gt; keyList=mapTree.containsKey(map.get(i)) ? mapTree.get(map.get(i)) : new ArrayList&amp;lt;&amp;gt;();
            keyList.add(i);
            mapTree.put(map.get(i),keyList);
        }
        //遍历mapTree的值，取k个数返回
        for(List&amp;lt;Integer&amp;gt; keyList:mapTree.values()){
            for(int i=0;i&amp;lt;keyList.size();i++){
                list.add(keyList.get(i));
                k--;
                if(k==0){return list;}
            }
        }
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;sort-colors&#34;&gt;Sort Colors&lt;/h2&gt;

&lt;h2 id=&#34;一次循环排序0-1-2&#34;&gt;一次循环排序0、1、2&lt;/h2&gt;

&lt;p&gt;Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.&lt;/p&gt;

&lt;p&gt;Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You are not suppose to use the library&amp;rsquo;s sort function for this problem.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [2,0,2,1,1,0]&lt;/p&gt;

&lt;p&gt;Output: [0,0,1,1,2,2]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Follow up:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A rather straight forward solution is a two-pass algorithm using counting sort.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;First, iterate the array counting number of 0&amp;rsquo;s, 1&amp;rsquo;s, and 2&amp;rsquo;s, then overwrite array with total number of 0&amp;rsquo;s, then 1&amp;rsquo;s and followed by 2&amp;rsquo;s.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Could you come up with a one-pass algorithm using only constant space?&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-15&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public void sortColors(int[] nums) {
        int low = 0;
        int high = nums.length-1;
        int i=0;
        while(i&amp;lt;=high){
            //nums[i]=0|1,i进位
            if(nums[i]==0){
                //若nums[low]=1,交换后nums[low]=0,nums[i]=1,之后则i进位跳过1，若有0再交换使0永远再1之前
                nums[i]=nums[low];
                nums[low]=0;
                low++;
            }else if(nums[i]==2){
                //nums[i]==2,i不进位
                nums[i]=nums[high];
                nums[high]=2;
                high--;
                i--;
            }
            i++;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;array-and-strings&#34;&gt;Array and Strings&lt;/h1&gt;

&lt;h2 id=&#34;longest-substring-without-repeating-characters&#34;&gt;Longest Substring Without Repeating Characters&lt;/h2&gt;

&lt;h2 id=&#34;最长且字母不重复的子串&#34;&gt;最长且字母不重复的子串&lt;/h2&gt;

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;abcabcbb&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;

&lt;p&gt;Explanation: The answer is &amp;ldquo;abc&amp;rdquo;, with the length of 3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;bbbbb&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 1&lt;/p&gt;

&lt;p&gt;Explanation: The answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;pwwkew&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;

&lt;p&gt;Explanation: The answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3. Note that the answer must be a substring, &amp;ldquo;pwke&amp;rdquo; is a subsequence and not a substring.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-16&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int lengthOfLongestSubstring(String s) {
        //初始化positions数组存放所有出现过字母的位置下标
        int[] positions = new int[127];
        Arrays.fill(positions,-1);
        char[] str = s.toCharArray();
        int longest = 0;
        int cur = 0;
        for(int i=0;i&amp;lt;str.length;i++){
            char c = str[i];
            int index = positions[c];
            if(index&amp;lt;0||(i-index)&amp;gt;cur){
                 cur++;
            }else{
                longest =  cur&amp;lt;longest?longest:cur;
                cur = i-index;
            }
            positions[c]=i;
        }
        longest =  cur&amp;lt;longest?longest:cur;
        return longest;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3sum&#34;&gt;3Sum&lt;/h2&gt;

&lt;h2 id=&#34;从数组中寻找三个和为0的数&#34;&gt;从数组中寻找三个和为0的数&lt;/h2&gt;

&lt;p&gt;Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.&lt;/p&gt;

&lt;p&gt;*Note:*The solution set must not contain duplicate triplets.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given array nums = [-1, 0, 1, 2, -1, -4],&lt;/p&gt;

&lt;p&gt;A solution set is:&lt;/p&gt;

&lt;p&gt;[[-1, 0, 1],[-1, -1, 2]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-17&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; threeSum(int[] nums) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        Arrays.sort(nums);
        //nums.length-2,一共求3个数
        for(int i=0;i&amp;lt;nums.length-2;i++){
            //若与前一个元素相同，则后移
            if(i==0||nums[i]!=nums[i-1]){
                int sum = 0-nums[i];
                int low = i+1;
                int high = nums.length-1;
                while(low&amp;lt;high){
                    if(nums[low]+nums[high]==sum){
                        list.add(Arrays.asList(nums[i],nums[low],nums[high]));
                        //去重，移动坐标
                        while(low&amp;lt;high&amp;amp;&amp;amp;nums[low]==nums[low+1]){low++;}
                        while(low&amp;lt;high&amp;amp;&amp;amp;nums[high]==nums[high-1]){high--;}
                        high--;
                        low++;
                    }else if(nums[low]+nums[high]&amp;gt;sum){
                        high--;
                    }else{
                        low++;
                    }
                }
            }
        }
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;set-matrix-zeroes&#34;&gt;Set Matrix Zeroes&lt;/h2&gt;

&lt;h2 id=&#34;将出现0的行列都赋值0&#34;&gt;将出现0的行列都赋值0&lt;/h2&gt;

&lt;p&gt;Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input:&lt;/p&gt;

&lt;p&gt;[[1,1,1],&lt;/p&gt;

&lt;p&gt;[1,0,1],&lt;/p&gt;

&lt;p&gt;[1,1,1]]&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;p&gt;[[1,0,1],&lt;/p&gt;

&lt;p&gt;[0,0,0],&lt;/p&gt;

&lt;p&gt;[1,0,1]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input:&lt;/p&gt;

&lt;p&gt;[[0,1,2,0],&lt;/p&gt;

&lt;p&gt;[3,4,5,2],&lt;/p&gt;

&lt;p&gt;[1,3,1,5]]&lt;/p&gt;

&lt;p&gt;Output:&lt;/p&gt;

&lt;p&gt;[[0,0,0,0],&lt;/p&gt;

&lt;p&gt;[0,4,5,0],&lt;/p&gt;

&lt;p&gt;[0,3,1,0]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Follow up:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A straight forward solution using O(mn) space is probably a bad idea.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A simple improvement uses O(m + n) space, but still not the best solution.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Could you devise a constant space solution?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-18&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public void setZeroes(int[][] matrix) {
        boolean[] rows = new boolean[matrix.length];
        boolean[] cols = new boolean[matrix[0].length];
        //找出所有为0的行、列
        for(int i=0;i&amp;lt;matrix.length;i++){
            for(int j=0;j&amp;lt;matrix[0].length;j++){
                if(matrix[i][j]==0){
                    rows[i] = true;
                    cols[j] = true;
                }
            }
        }
        //将所有标记行、列赋值0
        for(int i=0;i&amp;lt;matrix.length;i++){
            for(int j=0;j&amp;lt;matrix[0].length;j++){
                if(rows[i]||cols[j]){matrix[i][j]=0;}
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;increasing-triplet-subsequence&#34;&gt;Increasing Triplet Subsequence&lt;/h2&gt;

&lt;h2 id=&#34;是否存在i-j-k满足条件0-i-j-k-n-1且arr-i-arr-j-arr-k&#34;&gt;是否存在i、j、k满足条件0≤i&amp;lt;j&amp;lt;k≤n-1且arr[i]&amp;lt;arr[j]&amp;lt;arr[k]&lt;/h2&gt;

&lt;p&gt;Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.&lt;/p&gt;

&lt;p&gt;Formally the function should:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Return true if there exists i, j, k&lt;/p&gt;

&lt;p&gt;such that arr[i] &amp;lt; arr[j] &amp;lt; arr[k] given 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1 else return false.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Your algorithm should run in O(n) time complexity and O(1) space complexity.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,2,3,4,5]&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [5,4,3,2,1]&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-19&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean increasingTriplet(int[] nums) {
        /* 适用于多个下标，不只ijk三个下标
        if(nums.length&amp;lt;3){return false;}
        int[] ijk = new int[3];
        Arrays.fill(ijk,Integer.MAX_VALUE);
        for(int num:nums){
            for(int j=0;j&amp;lt;3;j++){
                //比较k时，num已大于ij
                if(j==2){return true;}
                if(num&amp;lt;=ijk[j]){
                    ijk[j]=num;
                    break;
                }
            }
        }
        return false;
        */
        int i = Integer.MAX_VALUE,j = Integer.MAX_VALUE;
        for(int num:nums){
            if(num&amp;lt;=i){
                i=num;
            }else if(num&amp;lt;=j){
                j=num;
            }else{
                return true;
            }
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;group-anagrams&#34;&gt;Group Anagrams&lt;/h2&gt;

&lt;h2 id=&#34;按条件-单词长度一致且出现字母相同-分组&#34;&gt;按条件 单词长度一致且出现字母相同 分组&lt;/h2&gt;

&lt;p&gt;Given an array of strings, group anagrams together.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [&amp;ldquo;eat&amp;rdquo;, &amp;ldquo;tea&amp;rdquo;, &amp;ldquo;tan&amp;rdquo;, &amp;ldquo;ate&amp;rdquo;, &amp;ldquo;nat&amp;rdquo;, &amp;ldquo;bat&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;Output:[[&amp;ldquo;ate&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;tea&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;nat&amp;rdquo;,&amp;ldquo;tan&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;bat&amp;rdquo;]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;All inputs will be in lowercase.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The order of your output does not matter.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-20&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //16ms，key为字母排序后的字符串，检验map中是否存在key
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) {
        if(strs==null || strs.length==0) return null;
        HashMap&amp;lt;String,List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for(String s : strs){
            char[] key=s.toCharArray();
            Arrays.sort(key);
            String st=String.valueOf(key);
            if(!map.containsKey(st)) map.put(st,new ArrayList());
            map.get(st).add(s);
        }
        return new ArrayList(map.values());        
    }
    //775 ms，每个字符串排序字母后比较每个List&amp;lt;String&amp;gt;的排序字母后的字符串
    public List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; groupAnagrams(String[] strs) {
        List&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; group = new ArrayList&amp;lt;&amp;gt;();
            for(String s:strs){
                char[] temp = s.toCharArray();
                Arrays.sort(temp);
                String sortS = String.valueOf(temp);
                boolean have = false;
                for(List&amp;lt;String&amp;gt; list:group){
                    if(s.length()!=list.get(0).length()){continue;}
                    char[] chs = list.get(0).toCharArray();
                    Arrays.sort(chs);
                    String sortChs = String.valueOf(chs);
                    if(sortChs.equals(sortS)) {
                        have = true;
                        list.add(s);
                        break;
                    }
                }
                if(!have) {
                    List&amp;lt;String&amp;gt; newList = new ArrayList&amp;lt;&amp;gt;();
                    newList.add(s);
                    group.add(newList);
                }
          }
        return group;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;linked-list&#34;&gt;Linked List&lt;/h1&gt;

&lt;h2 id=&#34;intersection-of-two-linked-lists&#34;&gt;Intersection of Two Linked Lists&lt;/h2&gt;

&lt;h2 id=&#34;找出两个链表最早的交集元素&#34;&gt;找出两个链表最早的交集元素&lt;/h2&gt;

&lt;p&gt;Write a program to find the node at which the intersection of two singly linked lists begins.&lt;/p&gt;

&lt;p&gt;For example, the following two linked lists:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A:&amp;nbsp;a1 → a2&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;↘&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;c1 → c2 → c3&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;↗&lt;/p&gt;

&lt;p&gt;B:&amp;nbsp;b1 → b2 → b3&lt;/p&gt;

&lt;p&gt;begin to intersect at node c1.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Notes:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;If the two linked lists have no intersection at all, return null.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The linked lists must retain their original structure after the function returns.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;You may assume there are no cycles anywhere in the entire linked structure.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Your code should preferably run in O(n) time and use only O(1) memory.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-21&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    //双指针法
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {

    }
    //利用哈希表，时间复杂度O(lengthA+lengthB)
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA == null || headB == null){return null;}
        Set&amp;lt;ListNode&amp;gt; set = new HashSet&amp;lt;&amp;gt;(); 
        while(headA!=null){
            set.add(headA);
            headA=headA.next;
        }
        while(headB!=null){
            if(set.contains(headB)){return headB;}
            headB=headB.next;
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;odd-even-linked-list&#34;&gt;Odd Even Linked List&lt;/h2&gt;

&lt;h2 id=&#34;偶数下标链表-奇数下表列表&#34;&gt;偶数下标链表+奇数下表列表&lt;/h2&gt;

&lt;p&gt;Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.&lt;/p&gt;

&lt;p&gt;You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/p&gt;

&lt;p&gt;Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 2-&amp;gt;1-&amp;gt;3-&amp;gt;5-&amp;gt;6-&amp;gt;4-&amp;gt;7-&amp;gt;NULL&lt;/p&gt;

&lt;p&gt;Output: 2-&amp;gt;3-&amp;gt;6-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;4-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-22&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head!=null){
            ListNode odd=head,even=head.next,evenHead=even;
            while(even!=null&amp;amp;&amp;amp;even.next!=null){
                odd.next = odd.next.next; 
                even.next = even.next.next; 
                odd = odd.next;
                even = even.next;
            }
            odd.next = evenHead; 
        }
        return head;
    }
    public ListNode oddEvenList(ListNode head) {
        if(head==null||head.next==null||head.next.next==null){return head;}
        ListNode odd = new ListNode(head.val);
        ListNode startOdd = odd;
        ListNode even = new ListNode(head.val);
        ListNode startEven = even;
        int count=1;
        while(head!=null){
            if(count%2==1){
                odd.next = new ListNode(head.val);
                odd = odd.next;
            }else{
                even.next = new ListNode(head.val);
                even = even.next;
            }
            head=head.next;
            count++;
        }
        odd.next = startEven.next;
        return startOdd.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;add-two-numbers&#34;&gt;Add Two Numbers&lt;/h2&gt;

&lt;h2 id=&#34;两个链表倒序输出所得数之和-按倒序构造新的链表&#34;&gt;两个链表倒序输出所得数之和 按倒序构造新的链表&lt;/h2&gt;

&lt;p&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;/p&gt;

&lt;p&gt;Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;p&gt;Explanation: 342 + 465 = 807.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-23&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode node = new ListNode(0);
        ListNode pre = node;
        int sum = 0;
        //l1=[6 7],l2=[6 7]
        while(l1!=null||l2!=null){
            if(l1!=null){
                sum+=l1.val;
                l1=l1.next;
            }
            if(l2!=null){
                sum+=l2.val;
                l2=l2.next;
            }
            /**
             *sum=12/pre.next=2
             *sum=1
             *sum=15/pre.next=5
             *sum=1
             */
            pre.next = new ListNode(sum%10);
            pre = pre.next;
            sum/=10;
        }
        //pre.next=sum=1
        if(sum==1){pre.next=new ListNode(1);}
        return node.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;math&#34;&gt;Math&lt;/h1&gt;

&lt;h2 id=&#34;sqrt-x&#34;&gt;Sqrt(x)&lt;/h2&gt;

&lt;h2 id=&#34;实现平方根&#34;&gt;实现平方根&lt;/h2&gt;

&lt;p&gt;Implement int sqrt(int x).&lt;/p&gt;

&lt;p&gt;Compute and return the square root of x, where x is guaranteed to be a non-negative integer.&lt;/p&gt;

&lt;p&gt;Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 4&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 8&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;

&lt;p&gt;Explanation: The square root of 8 is 2.82842&amp;hellip;, and since the decimal part is truncated, 2 is returned.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-24&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int mySqrt(int x) {
        //二分查找
        if(x&amp;lt;1){return 0;}
        int low = 1;
        int high = x;
        while(low&amp;lt;=high){
            int mid = low+(high-low)/2;
            if(x/mid==mid){return mid;}
            if(x/mid&amp;gt;mid){low = mid+1;}
            if(x/mid&amp;lt;mid){high = mid-1;}
        }
        return high;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pow-x-n&#34;&gt;Pow(x, n)&lt;/h2&gt;

&lt;h2 id=&#34;实现一个数的次方运算&#34;&gt;实现一个数的次方运算&lt;/h2&gt;

&lt;p&gt;Implement pow(x, n), which calculates x raised to the power n (x^n).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 2.00000, 10&lt;/p&gt;

&lt;p&gt;Output: 1024.00000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 2.10000, 3&lt;/p&gt;

&lt;p&gt;Output: 9.26100&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 2.00000, -2&lt;/p&gt;

&lt;p&gt;Output: 0.25000&lt;/p&gt;

&lt;p&gt;Explanation: 2-2 = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;22&lt;/sub&gt; = &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; = 0.25&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-100.0 &amp;lt; x &amp;lt; 100.0&lt;/li&gt;
&lt;li&gt;n is a 32-bit signed integer, within the range [−231, 231 − 1]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-25&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
    *实质为斐波那契数列
    *x^n=
    *   [x^(n/2)]*[x^(n/2)]; n为偶数
    *   {x[(n-1)/2]}*{x[(n-1)/2]}*x; n为奇数
    */
    public double myPow(double x,int n) {
        if(n==0){return 1;}
        if(n&amp;lt;0){
            x = 1/x;
            n = -n;
        }
        return fastPow(x, n);
    }
    
    public double fastPow(double x,int n){
        if(n==0){return 1;}
        double half = fastPow(x,n/2);
        if(n%2==0){
            return half*half;
        }else{
            return half*half*x;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;excel-sheet-column-number&#34;&gt;Excel Sheet Column Number&lt;/h2&gt;

&lt;h2 id=&#34;英文字母计数-26进制&#34;&gt;英文字母计数（26进制）&lt;/h2&gt;

&lt;p&gt;Given a column title as appear in an Excel sheet, return its corresponding column number.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;A -&amp;gt; 1&lt;/p&gt;

&lt;p&gt;B -&amp;gt; 2&lt;/p&gt;

&lt;p&gt;C -&amp;gt; 3&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Z -&amp;gt; 26&lt;/p&gt;

&lt;p&gt;AA -&amp;gt; 27&lt;/p&gt;

&lt;p&gt;AB -&amp;gt; 28&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;A&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;AB&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 28&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;ZY&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 701&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-26&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //&amp;quot;AAA&amp;quot;=703
    public int titleToNumber(String s) {
        char[] str = s.toCharArray();
        int sum = 0;
        for(int i=0;i&amp;lt;str.length;i++){
            //处于第几位=Math.pow(26,str.length-i-1)
            //当前数=str[i]-&#39;A&#39;+1
            sum += (int)Math.pow(26,str.length-i-1)*(str[i]-&#39;A&#39;+1);
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;factorial-trailing-zeroes&#34;&gt;Factorial Trailing Zeroes&lt;/h2&gt;

&lt;h2 id=&#34;找出一个数末尾有几个0&#34;&gt;找出一个数末尾有几个0&lt;/h2&gt;

&lt;p&gt;Given an integer n, return the number of trailing zeroes in n!.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 3&lt;/p&gt;

&lt;p&gt;Output: 0&lt;/p&gt;

&lt;p&gt;Explanation: 3! = 6, no trailing zero.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 5&lt;/p&gt;

&lt;p&gt;Output: 1&lt;/p&gt;

&lt;p&gt;Explanation: 5! = 120, one trailing zero.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Your solution should be in logarithmic time complexity.&lt;/p&gt;

&lt;h3 id=&#34;解答-27&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /**
    * 1*2*3*…*n=1*2*3*(2*2)*5*(2*3)*(2*2*2)*(3*3)*(2*5)*…
    * 只有2*5所得结果尾部为0
    * 2的个数比5多
    * 可得0的个数 = n由多少个5的乘积组成
    */
    public int trailingZeroes(int n) {
        if(n==0){return 0;}
        return n/5+trailingZeroes(n/5);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;happy-number&#34;&gt;Happy Number&lt;/h2&gt;

&lt;h2 id=&#34;求一个数所有数位的平方和-直至和为0&#34;&gt;求一个数所有数位的平方和，直至和为0&lt;/h2&gt;

&lt;p&gt;Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 19&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;

&lt;p&gt;Explanation:&lt;/p&gt;

&lt;p&gt;1^2 + 9^2 = 82&lt;/p&gt;

&lt;p&gt;8^2 + 2^2 = 68&lt;/p&gt;

&lt;p&gt;6^2 + 8^2 = 100&lt;/p&gt;

&lt;p&gt;1^2 + 0^2 + 0^2 = 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-28&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean isHappy(int n) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        while(n!=1){
            String s = String.valueOf(n);
            list.add(s);
            char[] chs = s.toCharArray();
            n=0;
            for(char c:chs){n+=Math.pow(Integer.parseInt(c+&amp;quot;&amp;quot;),2);}
            //若list中存在该数，则将陷入循环
            if(list.contains(String.valueOf(n))){return false;}
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;other&#34;&gt;Other&lt;/h1&gt;

&lt;h2 id=&#34;majority-element&#34;&gt;Majority Element&lt;/h2&gt;

&lt;h2 id=&#34;找出现次数最多的元素&#34;&gt;找出现次数最多的元素&lt;/h2&gt;

&lt;p&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;

&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [3,2,3]&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [2,2,1,1,1,2,2]&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-29&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //The majority element is the element that appears more than ⌊ n/2 ⌋ times.
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length / 2];
    }
    //3ms
    //原理：如果majority元素存在（majority元素个数大于n/2,个数超过数组长度一半），那么无论它的各个元素位置是如何分布的，其count经过抵消和增加后，最后一定是大于等于1的。 如果不能保证majority存在，需要检验。 复杂度：O(N)
    public int majorityElement(int[] nums) {
        int majority = nums[0];
        int count = 0;
        for(int i=0;i&amp;lt;nums.length;i++){
            if(count==0){
                count++;
                majority = nums[i];
            }else if(majority==nums[i]){
                count++;
            }else{
                count--;
            }
        }
        return majority;
    }
    //先排序后找出现次数最多的数，6ms
    public int majorityElement(int[] nums) {
        if(nums.length&amp;lt;=2){return nums[0];}
        Arrays.sort(nums);
        int max = 1;
        int record = 1;
        int majority = nums[0];
        for(int i=0;i&amp;lt;nums.length-1;i++){
            if(nums[i]==nums[i+1]){
                record++;
            }else{
                record = 1;
            }
            if(max&amp;lt;record){
                    max = record;
                    majority = nums[i];
            }
        }
        return majority;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Top Interview Questions-Easy-①</title>
      <link>https://boseman1024.github.io/2018/top-interview-questions-easy-1/</link>
      <pubDate>Fri, 28 Sep 2018 21:47:14 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/top-interview-questions-easy-1/</guid>
      <description>

&lt;h1 id=&#34;design&#34;&gt;Design&lt;/h1&gt;

&lt;h2 id=&#34;shuffle-an-array&#34;&gt;Shuffle an Array&lt;/h2&gt;

&lt;h2 id=&#34;打乱数组&#34;&gt;打乱数组&lt;/h2&gt;

&lt;p&gt;Shuffle a set of numbers without duplicates.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;// Init an array with set 1, 2, and 3.&lt;/p&gt;

&lt;p&gt;int[] nums = {1,2,3};&lt;/p&gt;

&lt;p&gt;Solution solution = new Solution(nums);&lt;/p&gt;

&lt;p&gt;// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.&lt;/p&gt;

&lt;p&gt;solution.shuffle();&lt;/p&gt;

&lt;p&gt;// Resets the array back to its original configuration [1,2,3].&lt;/p&gt;

&lt;p&gt;solution.reset();&lt;/p&gt;

&lt;p&gt;// Returns the random shuffling of array [1,2,3].&lt;/p&gt;

&lt;p&gt;solution.shuffle();&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    int nums[];
    public Solution(int[] nums) {
        this.nums = nums;
    }
    /** Resets the array to its original configuration and return it. */
    public int[] reset() {
        return nums;
    }
    /** Returns a random shuffling of the array. */
    public int[] shuffle() {
        int arr[] = new int[nums.length];
        for(int i=0;i&amp;lt;nums.length;i++){
            int rand = (int)(Math.random()*(i+1));
            arr[i] = arr[rand];
            arr[rand] = nums[i];
        }
        return arr;
    }
}
/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(nums);
 * int[] param_1 = obj.reset();
 * int[] param_2 = obj.shuffle();
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;min-stack&#34;&gt;Min Stack&lt;/h2&gt;

&lt;h2 id=&#34;栈取最小值&#34;&gt;栈取最小值&lt;/h2&gt;

&lt;p&gt;Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;push(x) &amp;ndash; Push element x onto stack.&lt;/li&gt;
&lt;li&gt;pop() &amp;ndash; Removes the element on top of the stack.&lt;/li&gt;
&lt;li&gt;top() &amp;ndash; Get the top element.&lt;/li&gt;
&lt;li&gt;getMin() &amp;ndash; Retrieve the minimum element in the stack.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;MinStack minStack = new MinStack();&lt;/p&gt;

&lt;p&gt;minStack.push(-2);&lt;/p&gt;

&lt;p&gt;minStack.push(0);&lt;/p&gt;

&lt;p&gt;minStack.push(-3);&lt;/p&gt;

&lt;p&gt;minStack.getMin();   &amp;ndash;&amp;gt; Returns -3.&lt;/p&gt;

&lt;p&gt;minStack.pop();&lt;/p&gt;

&lt;p&gt;minStack.top();      &amp;ndash;&amp;gt; Returns 0.&lt;/p&gt;

&lt;p&gt;minStack.getMin();   &amp;ndash;&amp;gt; Returns -2.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-1&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MinStack {
    //71 ms
    //使用两个Stack，保持stack、minStack数量一致
    //minStack仅存放当前最小值
    Stack&amp;lt;Integer&amp;gt; stack;
    Stack&amp;lt;Integer&amp;gt; minStack;
    public MinStack() {
        stack = new Stack&amp;lt;&amp;gt;();
        minStack = new Stack&amp;lt;&amp;gt;();
    }
    public void push(int x) {
        if(minStack.empty()||x&amp;lt;minStack.peek()){
            minStack.push(x);
        }else{
            minStack.push(minStack.peek());
        }
        stack.push(x);
    }
    public void pop() {
        stack.pop();
        minStack.pop();
    }
    public int top() {return stack.peek();}
    public int getMin() {return minStack.peek();}
}
//使用List，700ms+
class MinStack {
    List&amp;lt;Integer&amp;gt; stack;
    public MinStack() {stack = new ArrayList();}
    public void push(int x) {stack.add(x);}
    public void pop() {stack.remove(stack.size()-1);}
    public int top() {return stack.get(stack.size()-1);}
    public int getMin() {
        int min=stack.get(0);
        for(int i=0;i&amp;lt;stack.size();i++) {
            if(min&amp;gt;stack.get(i)) {
                min = stack.get(i);
            }
        }
        return min;
    }
}
/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;linked-list&#34;&gt;Linked List&lt;/h1&gt;

&lt;h2 id=&#34;reverse-linked-list&#34;&gt;Reverse Linked List&lt;/h2&gt;

&lt;h2 id=&#34;反转链表&#34;&gt;反转链表&lt;/h2&gt;

&lt;p&gt;Reverse a singly linked list.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/p&gt;

&lt;p&gt;Output: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-2&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null){return null;}
        ListNode pre = new ListNode(head.val);
        pre.next = null;
        ListNode next = pre;
        while(head.next!=null){
            head = head.next;
            next = new ListNode(head.val);
            next.next = pre;
            pre = next;
        }
        return next;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;linked-list-cycle&#34;&gt;Linked List Cycle&lt;/h2&gt;

&lt;h2 id=&#34;检验链表是否有环&#34;&gt;检验链表是否有环&lt;/h2&gt;

&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;

&lt;h3 id=&#34;解答-3&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        while(head!=null&amp;amp;&amp;amp;head.next!=null){
            if(head.next==head){return true;}
            ListNode pre = head;
            head = head.next;
            pre.next = pre;
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;palindrome-linked-list&#34;&gt;Palindrome Linked List&lt;/h2&gt;

&lt;h2 id=&#34;检验链表是否回文&#34;&gt;检验链表是否回文&lt;/h2&gt;

&lt;p&gt;Given a singly linked list, determine if it is a palindrome.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-4&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }*/
class Solution {
    //使用StringBuilder，700ms+
    public boolean isPalindrome(ListNode head) {
        StringBuilder sb = new StringBuilder();
        StringBuilder bs = new StringBuilder();
        while(head!=null){
            sb.append(head.val);
            bs.insert(0,head.val);
            head = head.next;
        }
        return sb.toString().equals(bs.toString());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;merge-two-sorted-lists&#34;&gt;Merge Two Sorted Lists&lt;/h2&gt;

&lt;h2 id=&#34;合并链表&#34;&gt;合并链表&lt;/h2&gt;

&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/p&gt;

&lt;p&gt;Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-5&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode newList = new ListNode(0);
        ListNode head = newList;
        while(l1!=null&amp;amp;&amp;amp;l2!=null){
            if(l1.val&amp;gt;l2.val){
                newList.next = l2;
                l2 = l2.next;
            }else{
                newList.next = l1;
                l1 = l1.next;
            }
            newList = newList.next;
        }
        if (l1 == null) {
            newList.next = l2;
        }else{
            newList.next = l1;
        }
        return head.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;delete-node-in-a-linked-list&#34;&gt;Delete Node in a Linked List&lt;/h2&gt;

&lt;h2 id=&#34;从链表中删除元素&#34;&gt;从链表中删除元素&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: head = [4,5,1,9], node = 5&lt;/p&gt;

&lt;p&gt;Output: [4,1,9]&lt;/p&gt;

&lt;p&gt;Explanation: You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: head = [4,5,1,9], node = 1&lt;/p&gt;

&lt;p&gt;Output: [4,5,9]&lt;/p&gt;

&lt;p&gt;Explanation: You are given the third node with value 1, the linked list should become 4 -&amp;gt; 5 -&amp;gt; 9 after calling your function.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-6&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remove-nth-node-from-end-of-list&#34;&gt;Remove Nth Node From End of List&lt;/h2&gt;

&lt;h2 id=&#34;删除链表中倒数第n个元素&#34;&gt;删除链表中倒数第N个元素&lt;/h2&gt;

&lt;p&gt;Given a linked list, remove the n-th node from the end of list and return its head.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.&lt;/p&gt;

&lt;p&gt;After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-7&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }  
 */
class Solution {
    //11ms
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode indexNode = head;
        int sum=0;
        while(indexNode!=null){
            indexNode = indexNode.next;
            sum++;
        }
        ListNode newNode = new ListNode(0);
        newNode.next = head;
        indexNode = newNode;
        for(int i=0;i&amp;lt;(sum-n);i++){
            indexNode = indexNode.next;
        }
        indexNode.next = indexNode.next.next;
        return newNode.next;
    }
    //递归计数，18 ms
    int Num;
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head==null){
            Num = n;
            return null;
        }
        head.next = removeNthFromEnd(head.next,n);
        Num--;
        return Num==0?head.next:head;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;sorting-and-searching&#34;&gt;Sorting and Searching&lt;/h1&gt;

&lt;h2 id=&#34;first-bad-version&#34;&gt;First Bad Version&lt;/h2&gt;

&lt;h2 id=&#34;第一个坏版本&#34;&gt;第一个坏版本&lt;/h2&gt;

&lt;p&gt;You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.&lt;/p&gt;

&lt;p&gt;Suppose you have n versions [1, 2, &amp;hellip;, n] and you want to find out the first bad one, which causes all the following ones to be bad.&lt;/p&gt;

&lt;p&gt;You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given n = 5, and version = 4 is the first bad version.&lt;/p&gt;

&lt;p&gt;call isBadVersion(3) -&amp;gt; false&lt;/p&gt;

&lt;p&gt;call isBadVersion(5) -&amp;gt; true&lt;/p&gt;

&lt;p&gt;call isBadVersion(4) -&amp;gt; true&lt;/p&gt;

&lt;p&gt;Then 4 is the first bad version.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-8&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        //二分查找
        int low = 1;
        int high = n-1;
        while(low&amp;lt;=high){
            //(low+high)/2求中间位置容易溢出
            int mid = low+(high-low)/2;
            if(isBadVersion(mid)){
                high = mid-1;
            }else{
                low = mid+1;
            }
        }
        return low;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;merge-sorted-array&#34;&gt;Merge Sorted Array&lt;/h2&gt;

&lt;h2 id=&#34;合并排序数组&#34;&gt;合并排序数组&lt;/h2&gt;

&lt;p&gt;Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The number of elements initialized in nums1 and nums2 are m and n respectively.&lt;/li&gt;
&lt;li&gt;You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input:&lt;/p&gt;

&lt;p&gt;nums1 = [1,2,3,0,0,0], m = 3&lt;/p&gt;

&lt;p&gt;nums2 = [2,5,6],       n = 3&lt;/p&gt;

&lt;p&gt;Output: [1,2,2,3,5,6]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-9&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void merge(int[] nums1, int m, int[] nums2, int n) {
    //①
    int i = m-1;
    int j = n-1;
    int k = m+n-1;
    while(i&amp;gt;=0 &amp;amp;&amp;amp; j&amp;gt;=0){
        if(nums1[i] &amp;gt; nums2[j]){
            nums1[k--] = nums1[i--];
        }else{
            nums1[k--] = nums2[j--];
        }
    }
    while(j&amp;gt;=0){
        nums1[k--] = nums2[j--];
    }
    //②
    for(int i=nums1.length-1;i&amp;gt;=0;i--) {
        if(n==0) {
            break;
        }
        if(m&amp;gt;0&amp;amp;&amp;amp;nums1[m-1]&amp;gt;=nums2[n-1]) {
            nums1[i] = nums1[m-1];
            m--;
        }else {
            nums1[i] = nums2[n-1];
            n--;
        }
    }    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;array&#34;&gt;Array&lt;/h1&gt;

&lt;h2 id=&#34;rotate-image&#34;&gt;Rotate Image&lt;/h2&gt;

&lt;h2 id=&#34;矩阵旋转&#34;&gt;矩阵旋转&lt;/h2&gt;

&lt;p&gt;You are given an n x n 2D matrix representing an image.&lt;/p&gt;

&lt;p&gt;Rotate the image by 90 degrees (clockwise).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given input matrix =&lt;/p&gt;

&lt;p&gt;[[1,2,3],&lt;/p&gt;

&lt;p&gt;[4,5,6],&lt;/p&gt;

&lt;p&gt;[7,8,9]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;rotate the input matrix in-place such that it becomes:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[[7,4,1],&lt;/p&gt;

&lt;p&gt;[8,5,2],&lt;/p&gt;

&lt;p&gt;[9,6,3]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given input matrix =&lt;/p&gt;

&lt;p&gt;[[ 5, 1, 9,11],&lt;/p&gt;

&lt;p&gt;[ 2, 4, 8,10],&lt;/p&gt;

&lt;p&gt;[13, 3, 6, 7],&lt;/p&gt;

&lt;p&gt;[15,14,12,16]],&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;rotate the input matrix in-place such that it becomes:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[[15,13, 2, 5],
[14, 3, 4, 1],
[12, 6, 8, 9],
[16, 7,10,11]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-10&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] rotate = new int[n][n];
        int index = n-1;
        for(int i=0;i&amp;lt;n;i++) {
            //rotate从右到左每一排存放matrix从上到下每一层
            for(int j=0;j&amp;lt;n;j++) {rotate[j][index] = matrix[i][j];}
            index--;
        }
        for(int i=0;i&amp;lt;n;i++){
            for(int j=0;j&amp;lt;n;j++){matrix[i][j] = rotate[i][j];}
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;best-time-to-buy-and-sell-stock-ii&#34;&gt;Best Time to Buy and Sell Stock II&lt;/h2&gt;

&lt;h2 id=&#34;买卖股票的最佳时间&#34;&gt;买卖股票的最佳时间&lt;/h2&gt;

&lt;p&gt;Say you have an array for which the i^th element is the price of a given stock on day i.&lt;/p&gt;

&lt;p&gt;Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [7,1,5,3,6,4]&lt;/p&gt;

&lt;p&gt;Output: 7&lt;/p&gt;

&lt;p&gt;Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.&lt;/p&gt;

&lt;p&gt;Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,2,3,4,5]&lt;/p&gt;

&lt;p&gt;Output: 4&lt;/p&gt;

&lt;p&gt;Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.&lt;/p&gt;

&lt;p&gt;Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [7,6,4,3,1]&lt;/p&gt;

&lt;p&gt;Output: 0&lt;/p&gt;

&lt;p&gt;Explanation: In this case, no transaction is done, i.e. max profit = 0.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-11&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length==0){return 0;}
        int max = 0;
        int pre = prices[0];
        for(int i =1;i&amp;lt;prices.length;i++){
            //遇到高价就出售
            if(prices[i]&amp;gt;pre){max += prices[i] - pre;}
            pre = prices[i];   
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;valid-sudoku&#34;&gt;Valid Sudoku&lt;/h2&gt;

&lt;h2 id=&#34;验证数独是否成立&#34;&gt;验证数独是否成立&lt;/h2&gt;

&lt;p&gt;Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Each row must contain the digits 1-9 without repetition.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each column must contain the digits 1-9 without repetition.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Sudoku board could be partially filled, where empty cells are filled with the character &amp;lsquo;.&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input:&lt;/p&gt;

&lt;p&gt;[[&amp;ldquo;5&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;3&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;4&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;7&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;5&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;9&amp;rdquo;]]&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input:&lt;/p&gt;

&lt;p&gt;[[&amp;ldquo;8&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;3&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;4&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;7&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;6&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;4&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;9&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;5&amp;rdquo;],&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;.&amp;rdquo;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;9&amp;rdquo;]]&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;

&lt;p&gt;Explanation: Same as Example 1, except with the 5 in the top left corner being&lt;/p&gt;

&lt;p&gt;modified to 8. Since there are two 8&amp;rsquo;s in the top left 3x3 sub-box, it is invalid.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A Sudoku board (partially filled) could be valid but is not necessarily solvable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Only the filled cells need to be validated according to the mentioned rules.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The given board contain only digits 1-9 and the character &amp;lsquo;.&amp;rsquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The given board size is always 9x9.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-12&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean isValidSudoku(char[][] board) {
        Set&amp;lt;Character&amp;gt; hset = new HashSet&amp;lt;&amp;gt;();
        Set&amp;lt;Character&amp;gt; vset = new HashSet&amp;lt;&amp;gt;();
        Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for(int i=0;i&amp;lt;9;i++) {
            for(int j=0;j&amp;lt;9;j++) {
                if(board[i][j]!=&#39;.&#39;&amp;amp;&amp;amp;!hset.add(board[i][j])) {return false;}
                if(board[j][i]!=&#39;.&#39;&amp;amp;&amp;amp;!vset.add(board[j][i])) {  return false;}
                if(i%3==0&amp;amp;&amp;amp;j%3==0) {
                    for(int x=i;x&amp;lt;i+3;x++) {
                        for(int y=j;y&amp;lt;j+3;y++) {
                            if(board[x][y]!=&#39;.&#39;&amp;amp;&amp;amp;!set.add(board[x][y])) {return false;}
                        }
                    }
                    set.clear();
                }
            }
            hset.clear();
            vset.clear();
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;intersection-of-two-arrays-ii&#34;&gt;Intersection of Two Arrays II&lt;/h2&gt;

&lt;h2 id=&#34;数组求交集&#34;&gt;数组求交集&lt;/h2&gt;

&lt;p&gt;Given two arrays, write a function to compute their intersection.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums1 = [1,2,2,1], nums2 = [2,2]&lt;/p&gt;

&lt;p&gt;Output: [2,2]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]&lt;/p&gt;

&lt;p&gt;Output: [4,9]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Each element in the result should appear as many times as it shows in both arrays.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The result can be in any order.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-13&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //2ms
    public int[] intersect(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int i=0,j=0,index=0;
        while(i&amp;lt;nums1.length&amp;amp;&amp;amp;j&amp;lt;nums2.length) {
            if(nums1[i]==nums2[j]) {
                nums1[index++]=nums1[i];
                i++;
                j++;
            }else if(nums1[i]&amp;lt;nums2[j]) {i++;
            }else {j++;}
        }
        return Arrays.copyOf(nums1, index);
    }
    //9ms
    public int[] intersect(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        if(nums1.length&amp;gt;nums2.length) {
            int[] temp = nums1;
            nums1 = nums2;
            nums2 = temp;
        }
        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        int index = 0;
        for(int i=0;i&amp;lt;nums1.length;i++) {
            for(int j=index;j&amp;lt;nums2.length;j++) {
                if(nums1[i]==nums2[j]) {
                    list.add(nums1[i]);
                    index = ++j;
                    break;
                }
            }
        }
        int length = list.size();
        int[] result = new int[length];
        for(int i:list) {result[--length] = i;}
        return result;   
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;two-sum&#34;&gt;Two Sum&lt;/h2&gt;

&lt;h2 id=&#34;数组中两个数之和等于目标数&#34;&gt;数组中两个数之和等于目标数&lt;/h2&gt;

&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;/p&gt;

&lt;p&gt;You may assume that each input would have exactly one solution, and you may not use the same element twice.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given nums = [2, 7, 11, 15], target = 9,&lt;/p&gt;

&lt;p&gt;Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-14&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int[] twoSum(int[] nums, int target) {
        int remain;
        for(int i=0;i&amp;lt;nums.length;i++) {
            remain = target-nums[i];
            for(int j=i+1;j&amp;lt;nums.length;j++) {
                if(remain==nums[j]) {
                    return new int[]{i,j};
                }
            }
        }
        return null;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;plus-one&#34;&gt;Plus One&lt;/h2&gt;

&lt;h2 id=&#34;数组每个元素所得数加一&#34;&gt;数组每个元素所得数加一&lt;/h2&gt;

&lt;p&gt;Given a non-empty array of digits representing a non-negative integer, plus one to the integer.&lt;/p&gt;

&lt;p&gt;The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.&lt;/p&gt;

&lt;p&gt;You may assume the integer does not contain any leading zero, except the number 0 itself.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,2,3]&lt;/p&gt;

&lt;p&gt;Output: [1,2,4]&lt;/p&gt;

&lt;p&gt;Explanation: The array represents the integer 123.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [4,3,2,1]&lt;/p&gt;

&lt;p&gt;Output: [4,3,2,2]&lt;/p&gt;

&lt;p&gt;Explanation: The array represents the integer 4321.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-15&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int[] plusOne(int[] digits) {
    for(int i=digits.length-1;i&amp;gt;=0;i--) {
        if(digits[i]==9) {
            digits[i]=0;    
        }else {
            digits[i] += 1;
            return digits;
        }
    }
    int nums[] = new int[digits.length+1];
    nums[0] = 1;
    return nums;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;contains-duplicate&#34;&gt;Contains Duplicate&lt;/h2&gt;

&lt;h2 id=&#34;数组中是否有重复数&#34;&gt;数组中是否有重复数&lt;/h2&gt;

&lt;p&gt;Given an array of integers, find if the array contains any duplicates.&lt;/p&gt;

&lt;p&gt;Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,2,3,1]&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,2,3,4]&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,1,1,3,3,4,3,2,4,2]
Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-16&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//排序后前后比对，重复则返回true。
public boolean containsDuplicate(int[] nums) {
    Arrays.sort(nums);
    for(int i=0;i&amp;lt;nums.length-1;i++) {
        if(nums[i]==nums[i+1]) {
            return true;
        }
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;move-zeroes&#34;&gt;Move Zeroes&lt;/h2&gt;

&lt;h2 id=&#34;将所有0后移&#34;&gt;将所有0后移&lt;/h2&gt;

&lt;p&gt;Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [0,1,0,3,12]&lt;/p&gt;

&lt;p&gt;Output: [1,3,12,0,0]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You must do this in-place without making a copy of the array.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Minimize the total number of operations.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-17&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //74ms
    public void moveZeroes(int[] nums) {
        int n=0;
        for(int i =nums.length-1;i&amp;gt;=0;i--){
            if(nums[i]==0){
                for(int j=i;j&amp;lt;nums.length-1;j++){
                    nums[j] = nums[j+1];
                }
                n++;
            }
        }
        for(int i=0;i&amp;lt;n;i++){nums[nums.length-1-i] = 0;}
        for(int i=0;i&amp;lt;nums.length;i++){System.out.println(nums[i]);}
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;single-number&#34;&gt;Single Number&lt;/h2&gt;

&lt;h2 id=&#34;找出只出现一次的数&#34;&gt;找出只出现一次的数&lt;/h2&gt;

&lt;p&gt;Given a non-empty array of integers, every element appears twice except for one. Find that single one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [2,2,1]&lt;/p&gt;

&lt;p&gt;Output: 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [4,1,2,1,2]&lt;/p&gt;

&lt;p&gt;Output: 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-18&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public int singleNumber(int[] nums) {
    List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
    for(int i=0;i&amp;lt;nums.length;i++){
        if(list.contains(nums[i])){
            list.remove(Integer.valueOf(nums[i]));
        }else{
            list.add(nums[i]);
        }
    }
    return list.get(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;rotate-array&#34;&gt;Rotate Array&lt;/h2&gt;

&lt;h2 id=&#34;按k位旋转数组&#34;&gt;按k位旋转数组&lt;/h2&gt;

&lt;p&gt;Given an array, rotate the array to the right by k steps, where k is non-negative.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [1,2,3,4,5,6,7] and k = 3&lt;/p&gt;

&lt;p&gt;Output: [5,6,7,1,2,3,4]&lt;/p&gt;

&lt;p&gt;Explanation:&lt;/p&gt;

&lt;p&gt;rotate 1 steps to the right: [7,1,2,3,4,5,6]&lt;/p&gt;

&lt;p&gt;rotate 2 steps to the right: [6,7,1,2,3,4,5]&lt;/p&gt;

&lt;p&gt;rotate 3 steps to the right: [5,6,7,1,2,3,4]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [-1,-100,3,99] and k = 2&lt;/p&gt;

&lt;p&gt;Output: [3,99,-1,-100]&lt;/p&gt;

&lt;p&gt;Explanation:&lt;/p&gt;

&lt;p&gt;rotate 1 steps to the right: [99,-1,-100,3]&lt;/p&gt;

&lt;p&gt;rotate 2 steps to the right: [3,99,-1,-100]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Could you do it in-place with O(1) extra space?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;解答-19&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RotateArray {
    public void rotate(int[] nums, int k) {
        /***
         *数组右移k轮
         * Time Limit Exceeded
         */
        int temp;
        for(int i=0;i&amp;lt;k;i++){
            temp = nums[nums.length-1];
            for(int j=nums.length-2;j&amp;gt;=0;j--){
                nums[j+1] = nums[j];
            }
            nums[0] = temp;
        }

        /***
         * 三次倒置数组元素
         * 倒置整个数组-倒置前（右移位数）个元素-倒置后（剩下）个元素
         * 例（右移3位）
         * 原：[1,2,3,4,5,6,7]
         * 1：[7,6,5,4,3,2,1]
         * 2：[5,6,7,4,3,2,1]
         * 3：[5,6,7,1,2,3,4]
         */
        int temp;
        int length = nums.length;
        for(int i = 0;i&amp;lt;length/2;i++){
            temp = nums[i];
            nums[i] = nums[length-1-i];
            nums[length-1-i] = temp;
        }
        while(k&amp;gt;nums.length){
            k -=nums.length;
        }
        for(int i = 0;i&amp;lt;k/2;i++){
            temp = nums[i];
            nums[i] = nums[k-1-i];
            nums[k-1-i] = temp;
        }
        for(int i = k,times=0;times&amp;lt;(length-k)/2;i++,times++){
            temp = nums[i];
            nums[i] = nums[length-1-times];
            nums[length-1-times] = temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;remove-duplicates-from-sorted-array&#34;&gt;Remove Duplicates from Sorted Array&lt;/h2&gt;

&lt;h2 id=&#34;删除排序数组中重复数字-每个重复数字只保留一个&#34;&gt;删除排序数组中重复数字，每个重复数字只保留一个&lt;/h2&gt;

&lt;p&gt;Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given nums = [1,1,2],&lt;/p&gt;

&lt;p&gt;Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what you leave beyond the returned length.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given nums = [0,0,1,1,1,2,2,3,3,4],&lt;/p&gt;

&lt;p&gt;Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t matter what values are set beyond the returned length.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Clarification:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Confused why the returned value is an integer but your answer is an array?&lt;/p&gt;

&lt;p&gt;Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.&lt;/p&gt;

&lt;p&gt;Internally you can think of this:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);&lt;/p&gt;

&lt;p&gt;// any modification to nums in your function would be known by the caller.&lt;/p&gt;

&lt;p&gt;// using the length returned by your function, it prints the first len elements.&lt;/p&gt;

&lt;p&gt;for (int i = 0; i &amp;lt; len; i++) {
    print(nums[i]);
}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-20&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RemoveDuplicatesFromSortedArray {
    public int removeDuplicates(int[] nums) {
        if(nums.length==0){return 0;}
        int length = 0;
        for(int i =1;i&amp;lt;nums.length;i++){
            if(nums[i]!=nums[length]){
                nums[length+1]=nums[i];
                length++;
            }
        }
        return length+1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Top Interview Questions-Easy-②</title>
      <link>https://boseman1024.github.io/2018/top-interview-questions-easy-2/</link>
      <pubDate>Thu, 27 Sep 2018 15:08:22 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/top-interview-questions-easy-2/</guid>
      <description>

&lt;h1 id=&#34;dynamic-programming&#34;&gt;Dynamic Programming&lt;/h1&gt;

&lt;h2 id=&#34;climbing-stairs&#34;&gt;Climbing Stairs&lt;/h2&gt;

&lt;h2 id=&#34;爬楼梯-实质为斐波那契数列&#34;&gt;爬楼梯，实质为斐波那契数列&lt;/h2&gt;

&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;

&lt;p&gt;Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Given n will be a positive integer.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 2&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;

&lt;p&gt;Explanation: There are two ways to climb to the top.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;1 step + 1 step&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2 steps&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 3&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;

&lt;p&gt;Explanation: There are three ways to climb to the top.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;1 step + 1 step + 1 step&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;1 step + 2 steps&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;2 steps + 1 step&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    /*斐波那契数列：
    * f(0)=1
    * f(1)=2
    * f(n)=f(n-1)+f(n-2)  n&amp;gt;1
    *
    * 若一次可爬1、2、…、n级台阶，则爬上一个n级台阶一共有f(n)=2^(n-1)种跳法
    */
    public int climbStairs(int n) {
        if(n&amp;lt;=1){return n;}
        int one = 1;
        int two = 2;
        int ways  = 2;
        for(int i=2;i&amp;lt;n;i++){
            ways = one+two;
            one = two;
            two = ways;
        }
        return ways;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maximum-subarray&#34;&gt;Maximum Subarray&lt;/h2&gt;

&lt;h2 id=&#34;数组中连续数的最大和&#34;&gt;数组中连续数的最大和&lt;/h2&gt;

&lt;p&gt;Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [-2,1,-3,4,-1,2,1,-5,4],&lt;/p&gt;

&lt;p&gt;Output: 6&lt;/p&gt;

&lt;p&gt;Explanation: [4,-1,2,1] has the largest sum = 6.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-1&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length&amp;lt;1||nums==null) {return 0;}
        int sum = nums[0];
        int temp = 0;
        for(int i:nums){
            temp+=i;
            sum = Math.max(sum,temp);
            temp = temp&amp;lt;0?0:temp;
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;best-time-to-buy-and-sell-stock&#34;&gt;Best Time to Buy and Sell Stock&lt;/h2&gt;

&lt;h2 id=&#34;买卖股票的最佳时间&#34;&gt;买卖股票的最佳时间&lt;/h2&gt;

&lt;p&gt;Say you have an array for which the ith element is the price of a given stock on day i.&lt;/p&gt;

&lt;p&gt;If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.&lt;/p&gt;

&lt;p&gt;Note that you cannot sell a stock before you buy one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [7,1,5,3,6,4]&lt;/p&gt;

&lt;p&gt;Output: 5&lt;/p&gt;

&lt;p&gt;Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.&lt;/p&gt;

&lt;p&gt;Not 7-1 = 6, as selling price needs to be larger than buying price.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [7,6,4,3,1]&lt;/p&gt;

&lt;p&gt;Output: 0&lt;/p&gt;

&lt;p&gt;Explanation: In this case, no transaction is done, i.e. max profit = 0.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-2&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //2ms
    public int maxProfit(int[] prices) {
        int max = 0;
        int minPrice = Integer.MAX_VALUE;
        for(int i:prices){
            minPrice = Math.min(i,minPrice);
            max = Math.max(max,i-minPrice);
        }
        return max;
    }
    //400ms+
    public int maxProfit(int[] prices) {
        int max = 0;
        for(int i=0;i&amp;lt;prices.length;i++){
            for(int j=i+1;j&amp;lt;prices.length;j++){
                if(prices[i]&amp;lt;prices[j]){
                    max = Math.max(max,prices[j]-prices[i]);
                }
            }
        }
        return max;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;others&#34;&gt;Others&lt;/h1&gt;

&lt;h2 id=&#34;valid-parentheses&#34;&gt;Valid Parentheses&lt;/h2&gt;

&lt;h2 id=&#34;检验优先级&#34;&gt;检验优先级&lt;/h2&gt;

&lt;p&gt;Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.&lt;/p&gt;

&lt;p&gt;An input string is valid if:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Open brackets must be closed by the same type of brackets.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Open brackets must be closed in the correct order.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note that an empty string is also considered valid.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;()&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;()[]{}&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;(]&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 4:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;([)]&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 5:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;{[]}&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-3&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean isValid(String s) {
        char[] chs =  s.toCharArray();
        //使用堆栈，栈中仅存&#39;)、}、]&#39;,出栈时核验是否匹配
        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for (char c : s.toCharArray()) {
            if (c == &#39;(&#39;) {stack.push(&#39;)&#39;);
            } else if (c ==&#39;{&#39;) {stack.push(&#39;}&#39;);
            } else if (c ==&#39;[&#39;) {stack.push(&#39;]&#39;);
            } else if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }
        return stack.isEmpty();
        //使用Deque双向队列
        Deque&amp;lt;Character&amp;gt; box = new ArrayDeque&amp;lt;&amp;gt;();
        Map&amp;lt;Character,Character&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;)&#39;,&#39;(&#39;);
        map.put(&#39;}&#39;,&#39;{&#39;);
        map.put(&#39;]&#39;,&#39;[&#39;);
        for(char c:chs) {
            if(c==&#39;(&#39;||c==&#39;{&#39;||c==&#39;[&#39;) {
                box.addFirst(c);
            }else {
                char first = box.size()&amp;gt;0?box.peekFirst():&#39; &#39;;
                if(first==&#39;]&#39;||first==&#39;}&#39;||first==&#39;)&#39;) {
                    return false;
                }else if(first==map.get(c)) {
                    box.removeFirst();
                }else {
                    box.addLast(c);
                }
            }
        }
        return box.size()==0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;pascal-s-triangle&#34;&gt;Pascal&amp;rsquo;s Triangle&lt;/h2&gt;

&lt;h2 id=&#34;杨辉三角形-帕斯卡三角形&#34;&gt;杨辉三角形、帕斯卡三角形&lt;/h2&gt;

&lt;p&gt;Given a non-negative integer numRows, generate the first numRows of Pascal&amp;rsquo;s triangle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif&#34;&gt;&lt;/p&gt;

&lt;p&gt;In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 5&lt;/p&gt;

&lt;p&gt;Output:[&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;[1],&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[1,1],&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[1,2,1],&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[1,3,3,1],&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[1,4,6,4,1]]&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-4&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; generate(int numRows) {
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; all = new ArrayList&amp;lt;&amp;gt;();
        if(numRows&amp;lt;=0){return all;}
        all.add(new ArrayList&amp;lt;&amp;gt;());
        all.get(0).add(1);
        if(numRows==1){return all;}
        all.add(new ArrayList&amp;lt;&amp;gt;());
        all.get(1).add(1);
        all.get(1).add(1);
        if(numRows==2){return all;}
        for(int i=3;i&amp;lt;=numRows;i++){
            all.add(new ArrayList&amp;lt;&amp;gt;());
            List&amp;lt;Integer&amp;gt; now = all.get(i-1);
            now.add(1);
            List&amp;lt;Integer&amp;gt; pre = all.get(i-2);
            for(int j=1;j&amp;lt;i-1;j++){
                now.add(pre.get(j-1)+pre.get(j));
            }
            now.add(1);
        }
        return all;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hamming-distance&#34;&gt;Hamming Distance&lt;/h2&gt;

&lt;h2 id=&#34;汉明距离&#34;&gt;汉明距离&lt;/h2&gt;

&lt;p&gt;The Hamming distance between two integers is the number of positions at which the corresponding bits are different.&lt;/p&gt;

&lt;p&gt;Given two integers x and y, calculate the Hamming distance.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; 0 ≤ x, y &amp;lt; 2^31.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: x = 1, y = 4&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;

&lt;p&gt;Explanation:&lt;/p&gt;

&lt;p&gt;1   (0 0 0 1)&lt;/p&gt;

&lt;p&gt;4   (0 1 0 0)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;↑   ↑&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The above arrows point to positions where the corresponding bits are different.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-5&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int hammingDistance(int x, int y) {
        //得到x,y的异或值
        int val = x^y;
        //计算1的个数，方法同Number of 1 Bits
        return Integer.bitCount(val);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;number-of-1-bits&#34;&gt;Number of 1 Bits&lt;/h2&gt;

&lt;h2 id=&#34;二进制数中1的个数&#34;&gt;二进制数中1的个数&lt;/h2&gt;

&lt;p&gt;Write a function that takes an unsigned integer and returns the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 11&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;

&lt;p&gt;Explanation: Integer 11 has binary representation 00000000000000000000000000001011&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 128
Output: 1
Explanation: Integer 128 has binary representation 00000000000000000000000010000000&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-6&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    public int hammingWeight(int n) {
        /**与运算
        *1：0000 0001
        *2：0000 0010
        *3：0000 0011
        *4：0000 0100
        *5：0000 0101
        *6：0000 0110
        *7：0000 0111
        *8：0000 1000
        *9：0000 1001
        *10：0000 1010
        *11：0000 1011
        *------------
        *0000 1010  = 10 = 11&amp;amp;10
        *0000 1000  =  8 = 10&amp;amp;9
        *0000 0000  =  0 = 8&amp;amp;7
        */ 
        int sum = 0;
        while(n!=0){
            sum++;
            n&amp;amp;=n-1;
        }
        return sum;
        //java API，返回1的个数
        return Integer.bitCount(n);
        // 转换为String判断每一位是否为1
        if (n==0) {return 0;}
        char[] chs = Integer.toBinaryString(n).toCharArray();
        int count = 0;
        for (int i=0; i &amp;lt; chs.length; i++) {
            if (chs[i]==&#39;1&#39;){count++;}
        }
        return count;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;missing-number&#34;&gt;Missing Number&lt;/h2&gt;

&lt;p&gt;Given an array containing n distinct numbers taken from 0, 1, 2, &amp;hellip;, n, find the one that is missing from the array.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [3,0,1]&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [9,6,4,2,3,5,7,0,1]&lt;/p&gt;

&lt;p&gt;Output: 8&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-7&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //0+1+2+……+n = n*(n+1)/2
    public int missingNumber(int[] nums) {
        int sum = nums.length*(nums.length+1)/2;
        for(int i=0;i&amp;lt;nums.length;i++){sum-=nums[i];}
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reverse-bits&#34;&gt;Reverse Bits&lt;/h2&gt;

&lt;h2 id=&#34;反转二进制&#34;&gt;反转二进制&lt;/h2&gt;

&lt;p&gt;Reverse bits of a given 32 bits unsigned integer.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 43261596&lt;/p&gt;

&lt;p&gt;Output: 964176192&lt;/p&gt;

&lt;p&gt;Explanation:&lt;/p&gt;

&lt;p&gt;43261596 represented in binary as 00000010100101000001111010011100,&lt;/p&gt;

&lt;p&gt;return 964176192 represented in binary as 00111001011110000010100101000000.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-8&#34;&gt;解答&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Solution {
    //位运算？不会
    // you need treat n as an unsigned value
    //转换为二进制字符串，不足位数前补0，反转字符串
    public int reverseBits(int n) {
        String s = Integer.toBinaryString(n);
        int length = s.length();
        for(int i=0;i&amp;lt;(32-length);i++) {s=&#39;0&#39;+s;}
        String sb = new StringBuilder(s).reverse().toString();
        return (int)Long.parseLong(sb,2);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;tree&#34;&gt;Tree&lt;/h1&gt;

&lt;h2 id=&#34;symmetric-tree&#34;&gt;Symmetric Tree&lt;/h2&gt;

&lt;h2 id=&#34;镜像二叉树树&#34;&gt;镜像二叉树树&lt;/h2&gt;

&lt;p&gt;Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).&lt;/p&gt;

&lt;p&gt;For example, this binary tree &lt;code&gt;[1,2,2,3,4,4,3]&lt;/code&gt; is symmetric&lt;/p&gt;

&lt;p&gt;But the following &lt;code&gt;[1,2,2,null,3,null,3]&lt;/code&gt; is not&lt;/p&gt;

&lt;h3 id=&#34;解答-9&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //8ms
    public boolean isSymmetric(TreeNode root) {
        return isSymmetric(root,root);
    }
    public boolean isSymmetric(TreeNode left,TreeNode right){
        if(left==null&amp;amp;&amp;amp;right==null){return true;}
        if(left==null||right==null){return false;}
        if(left.val!=right.val){return false;}
        return isSymmetric(left.left,right.right)&amp;amp;&amp;amp;isSymmetric(left.right,right.left);
    }
    //-----------------------------------------------
    //先将二叉树化为按层划分的集合，再做镜像校验
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; all;
    public boolean isSymmetric(TreeNode root) {
        if(root==null){return true;}
        all = new ArrayList&amp;lt;&amp;gt;();
        get(root,0);
        //检验镜像
        for(List&amp;lt;Integer&amp;gt; list:all){
            int i=0;
            while(list.size()&amp;gt;1&amp;amp;&amp;amp;i&amp;lt;list.size()/2){
                if(list.get(i)!=list.get(list.size()-1-i)){
                    return false;
                }
                i++;
            }
        }
        return true;
    }
    //同Binary Tree Level Order Traversal，但node为空则向集合添加null
    public void get(TreeNode node,int depth){
        if(all.size()&amp;lt;=depth){all.add(new ArrayList&amp;lt;&amp;gt;());}
        if(node==null){all.get(depth).add(null);return;
        }else{all.get(depth).add(node.val);}        
        depth++;
        get(node.left,depth);
        get(node.right,depth);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;binary-tree-level-order-traversal&#34;&gt;Binary Tree Level Order Traversal&lt;/h2&gt;

&lt;h2 id=&#34;二叉树分层遍历&#34;&gt;二叉树分层遍历&lt;/h2&gt;

&lt;p&gt;Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).&lt;/p&gt;

&lt;p&gt;For example:
Given binary tree &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;return its level order traversal as:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;[[3],&lt;/p&gt;

&lt;p&gt;[9,20],&lt;/p&gt;

&lt;p&gt;[15,7]]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-10&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; all;
    public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) {
        all = new ArrayList&amp;lt;&amp;gt;();
        if(root==null){return all;}
        get(root,0);
        return all;
    }
    public void get(TreeNode node,int depth){
        if(node==null){return;}
        //深度depth的all不存在，则向all内添加List
        if(all.size()&amp;lt;=depth){all.add(new ArrayList&amp;lt;&amp;gt;());}
        all.get(depth).add(node.val);
        depth++;
        get(node.left,depth);
        get(node.right,depth);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;convert-sorted-array-to-binary-search-tree&#34;&gt;Convert Sorted Array to Binary Search Tree&lt;/h2&gt;

&lt;h2 id=&#34;将排序后的数组构成二叉搜索树&#34;&gt;将排序后的数组构成二叉搜索树&lt;/h2&gt;

&lt;p&gt;Given an array where elements are sorted in ascending order, convert it to a height balanced BST.&lt;/p&gt;

&lt;p&gt;For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given the sorted array: [-10,-3,0,5,9],&lt;/p&gt;

&lt;p&gt;One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST&lt;/p&gt;

&lt;p&gt;[0,-10,5,null,-3,null,9]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-11&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return toBST(nums,0,nums.length-1);
    }
    public TreeNode toBST(int[] nums,int low,int high){
        if(low&amp;gt;high){return null;}
        int mid = low+(high-low)/2;
        TreeNode node = new TreeNode(nums[mid]);
        node.left = toBST(nums,low,mid-1);
        node.right = toBST(nums,mid+1,high);
        return node;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;validate-binary-search-tree&#34;&gt;Validate Binary Search Tree&lt;/h2&gt;

&lt;h2 id=&#34;检验是否为二叉搜索树&#34;&gt;检验是否为二叉搜索树&lt;/h2&gt;

&lt;p&gt;Given a binary tree, determine if it is a valid binary search tree (BST).&lt;/p&gt;

&lt;p&gt;Assume a BST is defined as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Both the left and right subtrees must also be binary search trees.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [2,1,3]&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [5,1,4,null,null,3,6]&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;

&lt;p&gt;Explanation: The input is: [5,1,4,null,null,3,6]. The root node&amp;rsquo;s value is 5 but its right child&amp;rsquo;s value is 4.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-12&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //0ms
    public boolean isValidBST(TreeNode root) {
        return helper(root, null, null);
    }
    public boolean helper(TreeNode node,Integer upper,Integer lower) {
        if(node == null){return true;}
        if(upper != null &amp;amp;&amp;amp; node.val &amp;gt;= upper){return false;}
        if(lower != null &amp;amp;&amp;amp; node.val &amp;lt;= lower){return false;}
        return helper(node.left,node.val,lower) &amp;amp;&amp;amp; helper(node.right, upper,node.val);
    } 
    //使用堆栈，6ms
    Stack&amp;lt;Integer&amp;gt; stack;
    public boolean isValidBST(TreeNode root) {
        if(root==null){return true;}
        stack = new Stack&amp;lt;&amp;gt;();
        get(root);
        while(!stack.isEmpty()){
            int pop = stack.pop();
            if(!stack.isEmpty()&amp;amp;&amp;amp;pop&amp;lt;=stack.peek()){return false;}
        }
        return true;
    }
    public void get(TreeNode node){
        if(node!=null){
            get(node.left);
            stack.add(node.val);
            get(node.right);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;maximum-depth-of-binary-tree&#34;&gt;Maximum Depth of Binary Tree&lt;/h2&gt;

&lt;h2 id=&#34;二叉树的最大深度&#34;&gt;二叉树的最大深度&lt;/h2&gt;

&lt;p&gt;Given a binary tree, find its maximum depth.&lt;/p&gt;

&lt;p&gt;The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; A leaf is a node with no children.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Given binary tree [3,9,20,null,null,15,7],&lt;/p&gt;

&lt;p&gt;return its depth = 3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-13&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null){return 0;}
        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;math&#34;&gt;Math&lt;/h1&gt;

&lt;h2 id=&#34;roman-to-integer&#34;&gt;Roman to Integer&lt;/h2&gt;

&lt;h2 id=&#34;罗马数字转换&#34;&gt;罗马数字转换&lt;/h2&gt;

&lt;p&gt;Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.&lt;/p&gt;

&lt;p&gt;I=1,V=5,X=10,L=50,C=100,D=500,M=1000&lt;/p&gt;

&lt;p&gt;For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.&lt;/p&gt;

&lt;p&gt;Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;I can be placed before V (5) and X (10) to make 4 and 9.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;X can be placed before L (50) and C (100) to make 40 and 90.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;C can be placed before D (500) and M (1000) to make 400 and 900.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;III&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;IV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;IX&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 9&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 4:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;LVIII&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 58&lt;/p&gt;

&lt;p&gt;Explanation: L = 50, V= 5, III = 3.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 5:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;MCMXCIV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 1994&lt;/p&gt;

&lt;p&gt;Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-14&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int romanToInt(String s) {
        Map&amp;lt;Character,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&#39;I&#39;,1);
        map.put(&#39;V&#39;,5);
        map.put(&#39;X&#39;,10);
        map.put(&#39;L&#39;,50);
        map.put(&#39;C&#39;,100);
        map.put(&#39;D&#39;,500);
        map.put(&#39;M&#39;,1000);
        int sum =0;
        int pre = 0;
        char[] chs = s.toCharArray();
        for(char c:chs){
            int num = map.get(c);
            if(num&amp;gt;pre){sum = sum-2*pre+num;
            //num-pre再减去前一轮加上的pre = num-2*pre
            }else{sum+=num;}
            pre = num;
        }
        return sum;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;fizz-buzz&#34;&gt;Fizz Buzz&lt;/h2&gt;

&lt;h2 id=&#34;fizz-替代3的倍数-buzz-替代5的倍数&#34;&gt;“Fizz”替代3的倍数，“Buzz”替代5的倍数&lt;/h2&gt;

&lt;p&gt;Write a program that outputs the string representation of numbers from 1 to n.&lt;/p&gt;

&lt;p&gt;But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;n = 15,&lt;/p&gt;

&lt;p&gt;Return:&lt;/p&gt;

&lt;p&gt;[&amp;ldquo;1&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;Fizz&amp;rdquo;,&amp;ldquo;4&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Buzz&amp;rdquo;,&amp;ldquo;Fizz&amp;rdquo;,&amp;ldquo;7&amp;rdquo;,&amp;ldquo;8&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Fizz&amp;rdquo;,&amp;ldquo;Buzz&amp;rdquo;,&amp;ldquo;11&amp;rdquo;,&amp;ldquo;Fizz&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&amp;ldquo;13&amp;rdquo;,&amp;ldquo;14&amp;rdquo;,&amp;ldquo;FizzBuzz&amp;rdquo;]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-15&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public List&amp;lt;String&amp;gt; fizzBuzz(int n) {
        List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        for(int i=1;i&amp;lt;=n;i++){
            boolean isThree = i%3==0;
            boolean isFive = i%5==0
            if(isThree&amp;amp;&amp;amp;isFive){list.add(&amp;quot;FizzBuzz&amp;quot;);
            }else if(isThree){list.add(&amp;quot;Fizz&amp;quot;);
            }else if(isFive){list.add(&amp;quot;Buzz&amp;quot;);
            }else{list.add(String.valueOf(i));
            }
        }
        return list;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;count-primes&#34;&gt;Count Primes&lt;/h2&gt;

&lt;h2 id=&#34;质数的个数&#34;&gt;质数的个数&lt;/h2&gt;

&lt;p&gt;Count the number of prime numbers &lt;em&gt;less than&lt;/em&gt; a non-negative number, n.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 10&lt;/p&gt;

&lt;p&gt;Output: 4&lt;/p&gt;

&lt;p&gt;Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-16&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //筛法求素数：若已知一个数为素数，则该数的倍数均非素数。
    //21ms，筛法求素数
    public int countPrimes(int n) {
        boolean[] isPrime = new boolean[n];
        int count = 0;
        for(int i=2;i&amp;lt;n;i++){
            if(isPrime[i]==false){
                count++;
                for(int j=2;j*i&amp;lt;n;j++){isPrime[j*i]=true;}
            }
        }
        return count;
    }
    //120ms，筛法求素数
    public int countPrimes(int n) {
        if(n==0||n==1){return 0;}
        int[] num = new int[n];
        int[] result = new int[n];
        int count = 0;
        for(int i=2;i&amp;lt;n;i++){
            //是素数，存入result
            if(num[i]==0){result[count++]=i;}
            //将所求素数的倍数设为1，均非素数
            for(int j=2*i;j&amp;lt;n;j+=i){num[j]=1;}
        }
        return count;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;power-of-three&#34;&gt;Power of Three&lt;/h2&gt;

&lt;h2 id=&#34;是否为3的多次方数&#34;&gt;是否为3的多次方数&lt;/h2&gt;

&lt;p&gt;Given an integer, write a function to determine if it is a power of three.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 27&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 0&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 9&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 4:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: 45&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-17&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public boolean isPowerOfThree(int n) {
        while(n&amp;gt;0){
            if(n==1){return true;
            }else if(n%3==0){n /=3;
            }else{return false;}
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;string&#34;&gt;String&lt;/h1&gt;

&lt;h2 id=&#34;string-to-integer-atoi&#34;&gt;String to Integer (atoi)&lt;/h2&gt;

&lt;h2 id=&#34;字符串转整型数&#34;&gt;字符串转整型数&lt;/h2&gt;

&lt;p&gt;Implement atoi which converts a string to an integer.&lt;/p&gt;

&lt;p&gt;The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;

&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;

&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;

&lt;p&gt;If no valid conversion could be performed, a zero value is returned.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Only the space character &amp;lsquo; &amp;rsquo; is considered as whitespace character.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;42&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 42&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;   -42&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: -42&lt;/p&gt;

&lt;p&gt;Explanation: The first non-whitespace character is &amp;lsquo;-&amp;rsquo;, which is the minus sign.&lt;/p&gt;

&lt;p&gt;Then take as many numerical digits as possible, which gets 42.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 3:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;4193 with words&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 4193&lt;/p&gt;

&lt;p&gt;Explanation: Conversion stops at digit &amp;lsquo;3&amp;rsquo; as the next character is not a numerical digit.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 4:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;words and 987&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 0&lt;/p&gt;

&lt;p&gt;Explanation: The first non-whitespace character is &amp;lsquo;w&amp;rsquo;, which is not a numerical&lt;/p&gt;

&lt;p&gt;digit or a +/- sign. Therefore no valid conversion could be performed.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 5:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: &amp;ldquo;-91283472332&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: -2147483648&lt;/p&gt;

&lt;p&gt;Explanation: The number &amp;ldquo;-91283472332&amp;rdquo; is out of the range of a 32-bit signed integer.&lt;/p&gt;

&lt;p&gt;Thefore INT_MIN (−231) is returned.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-18&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int myAtoi(String str) {
        if(str.trim().length()&amp;lt;1||str==null){return 0;}
        str = str.trim();
        char c = str.charAt(0);
        boolean flag = false;
        if(c==&#39;-&#39;) {
            flag = true;
            str = str.substring(1,str.length());
        }else if(c==&#39;+&#39;){str = str.substring(1,str.length());
        }else if(c&amp;lt;&#39;0&#39;||c&amp;gt;&#39;9&#39;){return 0;}
        //&amp;quot;-+2&amp;quot;
        if(str.length()&amp;lt;1||str.charAt(0)&amp;lt;&#39;0&#39;||str.charAt(0)&amp;gt;&#39;9&#39;){return 0;}
        //&amp;quot; 0000000123&amp;quot;
        boolean isZero = true;
        int zeroNum = 0;
        for(int i=0;i&amp;lt;str.length();i++) {
            char num = str.charAt(i);
            if(isZero&amp;amp;&amp;amp;num==&#39;0&#39;) {zeroNum++;
            }else {isZero = false;}
            if(num&amp;lt;&#39;0&#39;||num&amp;gt;&#39;9&#39;){
                str = str.substring(0,i);
                break;
            }
        }
        str = str.substring(zeroNum, str.length());
        //&amp;quot;000000000&amp;quot;
        if(str.length()&amp;lt;1) {return 0;}
        //&amp;quot;200000000000000000000&amp;quot;，防止溢出
        String MAX = String.valueOf(Integer.MAX_VALUE);
        String MIN = String.valueOf(Integer.MIN_VALUE);
        if(!flag&amp;amp;&amp;amp;str.length()&amp;gt;MAX.length()) {return Integer.MAX_VALUE;
        }else if(flag&amp;amp;&amp;amp;str.length()&amp;gt;MIN.length()-1){return Integer.MIN_VALUE;
        }
        long result = flag?-1*Long.parseLong(str):Long.parseLong(str);
        result = result&amp;gt;Integer.MAX_VALUE?Integer.MAX_VALUE:result;
        result = result&amp;lt;Integer.MIN_VALUE?Integer.MIN_VALUE:result;
        return (int)result;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;longest-common-prefix&#34;&gt;Longest Common Prefix&lt;/h2&gt;

&lt;h2 id=&#34;求最长共同的前缀&#34;&gt;求最长共同的前缀&lt;/h2&gt;

&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;

&lt;p&gt;If there is no common prefix, return an empty string &amp;ldquo;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [&amp;ldquo;flower&amp;rdquo;,&amp;ldquo;flow&amp;rdquo;,&amp;ldquo;flight&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;Output: &amp;ldquo;fl&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: [&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;racecar&amp;rdquo;,&amp;ldquo;car&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;Output: &amp;ldquo;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Explanation: There is no common prefix among the input strings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Note:*All given inputs are in lowercase letters a-z.&lt;/p&gt;

&lt;h3 id=&#34;解答-19&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //排序后比较头尾
    public String longestCommonPrefix(String[] strs) {
        if(strs.length==0||strs==null){return &amp;quot;&amp;quot;;}
        Arrays.sort(strs);
        String pre = &amp;quot;&amp;quot;;
        for(int i=0;i&amp;lt;strs[0].length();i++){
            if(strs[0].charAt(i)==strs[strs.length-1].charAt(i)){
                pre += strs[0].charAt(i);
            }else{return pre;}
        }
        return pre;
    }
    //不断截取长度-1的字符串，直至符合
    public String longestCommonPrefix(String[] strs) {
        if(strs.length==0||strs==null){return &amp;quot;&amp;quot;;}
        String pre=strs[0];
        for(int i =0;i&amp;lt;strs.length;i++){
            while(strs[i].indexOf(pre)!=0){
                pre = pre.substring(0,pre.length()-1);
            }
        }
        return pre;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implement-strstr&#34;&gt;Implement strStr()&lt;/h2&gt;

&lt;h2 id=&#34;若字符串needle是haystack的子串-求其在haystack的索引&#34;&gt;若字符串needle是haystack的子串，求其在haystack的索引&lt;/h2&gt;

&lt;p&gt;Implement strStr().&lt;/p&gt;

&lt;p&gt;Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: 2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: -1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-20&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //java API
    public int strStr(String haystack, String needle) {
        return haystack.indexOf(needle);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;valid-anagram&#34;&gt;Valid Anagram&lt;/h2&gt;

&lt;h2 id=&#34;检验s-t是否由颠倒字母顺序而构成&#34;&gt;检验s、t是否由颠倒字母顺序而构成&lt;/h2&gt;

&lt;p&gt;Given two strings s and t , write a function to determine if t is an anagram of s.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Example 1:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: s = &amp;ldquo;anagram&amp;rdquo;, t = &amp;ldquo;nagaram&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Example 2:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Input: s = &amp;ldquo;rat&amp;rdquo;, t = &amp;ldquo;car&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Output: false&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;*Note:*You may assume the string contains only lowercase alphabets.&lt;/p&gt;

&lt;h3 id=&#34;解答-21&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    //存入字母表，判断字母表个数，1ms
    public boolean isAnagram(String s, String t) {
        if(s.length()!=t.length()){return false;}
        int[] charMap = new int[26];
        char[] sc = s.toCharArray();
        char[] tc  = t.toCharArray();
        for(char csc:sc){charMap[csc-&#39;a&#39;]++;}
        for(char ctc:tc){charMap[ctc-&#39;a&#39;]--;}
        for(int i:charMap){
            if(i!=0){return false;}
        }
        return true;
    }
    //转数组并排序比较是否匹配
    public boolean isAnagram(String s, String t) {
        if(s.length()!=t.length()){return false;}
        char[] sc = s.toCharArray();
        char[] tc  = t.toCharArray();
        Arrays.sort(sc);
        Arrays.sort(tc);
        return Arrays.equals(sc,tc);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;first-unique-character-in-a-string&#34;&gt;First Unique Character in a String&lt;/h2&gt;

&lt;h2 id=&#34;找出字符串中仅出现1次的字母&#34;&gt;找出字符串中仅出现1次的字母&lt;/h2&gt;

&lt;p&gt;Given a string, find the first non-repeating character in it and return it&amp;rsquo;s index. If it doesn&amp;rsquo;t exist, return -1.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; You may assume the string contain only lowercase letters.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Examples:&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;s = &amp;ldquo;leetcode&amp;rdquo;&lt;/p&gt;

&lt;p&gt;return 0.&lt;/p&gt;

&lt;p&gt;s = &amp;ldquo;loveleetcode&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;return 2.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;解答-22&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int firstUniqChar(String s) {
        for(int i=0;i&amp;lt;s.length();i++) {
            if(s.indexOf(s.charAt(i))==s.lastIndexOf(s.charAt(i))) {
                return i;
            }
        }
        return -1;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;valid-palindrome&#34;&gt;Valid Palindrome&lt;/h2&gt;

&lt;h2 id=&#34;回文&#34;&gt;回文&lt;/h2&gt;

&lt;h3 id=&#34;解答-23&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public boolean isPalindrome(String s) {
    char[] str = s.toLowerCase().toCharArray();
    int i=0;
    int j=str.length-1;
    while(i&amp;lt;j) {
        while(i&amp;lt;str.length&amp;amp;&amp;amp;!isChar(str[i])) {
            i++;
        }
        while(j&amp;gt;=0&amp;amp;&amp;amp;!isChar(str[j])) {
            j--;
        }
        if(i&amp;lt;j&amp;amp;&amp;amp;str[i]!=str[j]) {
            return false;
        }
        i++;
        j--;
    }
    return true;
}
public boolean isChar(char c) {
    return (&#39;a&#39;&amp;lt;=c&amp;amp;&amp;amp;c&amp;lt;=&#39;z&#39;)||(&#39;A&#39;&amp;lt;=c&amp;amp;&amp;amp;c&amp;lt;=&#39;Z&#39;)||(c&amp;gt;=&#39;0&#39;&amp;amp;&amp;amp;c&amp;lt;=&#39;9&#39;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reverse-integer&#34;&gt;Reverse Integer&lt;/h2&gt;

&lt;h2 id=&#34;反转整型&#34;&gt;反转整型&lt;/h2&gt;

&lt;p&gt;Given a 32-bit signed integer, reverse digits of an integer.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt;
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;

&lt;h3 id=&#34;解答-24&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Solution {
    public int reverse(int x) {
        //数值
        if(x&amp;gt;Integer.MAX_VALUE||x&amp;lt;Integer.MIN_VALUE){
            return 0;
        }
        long num = 0;
        while(x!=0) {
            num*=10;
            num += x%10;
            x /= 10;
        }
        if(num&amp;lt;=Integer.MAX_VALUE&amp;amp;&amp;amp;num&amp;gt;=Integer.MIN_VALUE){
            return (int)num;
        }
        return 0;
        //转换字符串
        boolean flag = false;
        long num = x;
        if(num&amp;lt;0) {
            num *=-1;
            flag = true;
        }
        String str = new StringBuffer(String.valueOf(num)).reverse().toString();
        num = Long.parseLong(str);
        if(num&amp;gt;Integer.MAX_VALUE ||num&amp;lt;Integer.MIN_VALUE ){
            return 0;
        }else if(flag) {
            num*=-1;
        }
        return (int)num;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;reverse-string&#34;&gt;Reverse String&lt;/h2&gt;

&lt;h2 id=&#34;反转字符串&#34;&gt;反转字符串&lt;/h2&gt;

&lt;h3 id=&#34;解答-25&#34;&gt;解答：&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public String reverseString(String s) {
    return new StringBuffer(s).reverse().toString();
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>排序算法整理</title>
      <link>https://boseman1024.github.io/2018/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</link>
      <pubDate>Thu, 14 Jun 2018 13:56:22 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</guid>
      <description>

&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void Bubble(int num[]) {
    for(int i=0;i&amp;lt;num.length-1;i++) {
        for(int j=0;j&amp;lt;num.length-i-1;j++) {
            if(num[j]&amp;gt;num[j+1]) {
                int temp = num[j+1];
                num[j+1] = num[j];
                num[j] = temp;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void Selection(int num[]) {
    for(int i=0;i&amp;lt;num.length;i++) {
        //最小元素的下标
        int min = i;
        //找出最小元素
        for(int j=i;j&amp;lt;num.length;j++) {
            if(num[j]&amp;lt;num[min]) {
                min = j;
            }
        }
        //交换元素
        int temp = num[i];
        num[i] = num[min];
        num[min] = temp;
    }
    show(num);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;插入排序&#34;&gt;插入排序&lt;/h2&gt;

&lt;h3 id=&#34;直接插入排序&#34;&gt;直接插入排序&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void StraightInsert(int num[]) {
    for(int i=1;i&amp;lt;num.length;i++) {
        int temp = num[i];
        int j=i;
        while(j&amp;gt;0&amp;amp;&amp;amp;temp&amp;lt;num[j-1]) {
            num[j] = num[j-1];
            j--;
        }
        num[j]=temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;二分插入排序&#34;&gt;二分插入排序&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void DichotomyInsert(int num[]) {
    for(int i=1;i&amp;lt;num.length;i++) {
        int low = 0;
        int high = i-1;
        int temp = num[i];
        while(low&amp;lt;=high) {
            int mid = low+(high-low)/2; //取中间点
            if(temp&amp;gt;num[mid]) {
                low = mid+1; //插入点在右半区间
            }else {
                high = mid-1; //插入点在左半区间
            }
        }
        //插入点在low，low到i为止的所有元素向右移动一位
        for(int j=i-1;j&amp;gt;=low;j--) {
            num[j+1] = num[j];
        }
        //插入low位置
        num[low] = temp;
    }
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>JAVA虚拟机笔记</title>
      <link>https://boseman1024.github.io/2018/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Jun 2018 20:40:26 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</guid>
      <description>

&lt;h1 id=&#34;java内存区域&#34;&gt;JAVA内存区域&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://kaftjq.bn.files.1drv.com/y4mS6vvsA9ypbLWdrf592ni-F5HWviDc0m_3jez5dmgtqnLFzrA2I-5gYaXq5DO7cpt4kJV6QM6o5ayel6jDpoAZBDJb3iO7-hWXAcw2TMQvphu-vsexMHGtm8BOQNEenhstL8BSOqeh194hxKAIv2-MkcoAOSnDhiGzLnjuJ2pk5wTouPKOq7G4G5Qbwxi6AKLdHGMmvq2O9vR991cmC3URw/RuntimeDataArea.jpg&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;程序计数器&#34;&gt;程序计数器&lt;/h2&gt;

&lt;p&gt;*程序计数器（Program Counter Register）*是当前线程所执行的字节码的行号指示器，通过计数器的值选取下一条需要执行的字节码指令（java方法）。 &lt;em&gt;可参考《计算机系统组成》&lt;/em&gt;
每个线程都需要一个独立的程序计数器，各线程间计数器互不影响，独立储存，称之为“&lt;code&gt;线程私有&lt;/code&gt;”的内存。&lt;/p&gt;

&lt;h2 id=&#34;java虚拟机栈&#34;&gt;JAVA虚拟机栈&lt;/h2&gt;

&lt;p&gt;*JAVA虚拟机栈（Java Virtual Machine Stacks）*描述的是JAVA方法执行的内存模型：每个方法执行的同时会创建一个&lt;code&gt;栈帧&lt;/code&gt;，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程。
同时其也是&lt;code&gt;线程私有&lt;/code&gt;，生命周期与线程相同。
其中&lt;code&gt;局部变量表&lt;/code&gt;，存放了编译器可知的各种&lt;code&gt;基本数据&lt;/code&gt;类型（boolean、byte、char、short、int、float、long、double）、&lt;code&gt;对象引用&lt;/code&gt;类型（reference类型，可能是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和&lt;code&gt;returnAddress&lt;/code&gt;类型（指向一条字节码指令的地址）。其中64位长度的long和double类型数据占用2个局部变量空间（slot），其余只占用1个。
局部变量表&lt;code&gt;所需的内存空间&lt;/code&gt;在编译期间完成分配，当进入一个方法时，需要在帧中分配多大的局部变量空间时完全确定的，在方法执行期间不会改变局部变量表大小。&lt;/p&gt;

&lt;h2 id=&#34;本地方法栈&#34;&gt;本地方法栈&lt;/h2&gt;

&lt;p&gt;*本地方法栈（Native Method Stack）*于虚拟机栈相似，但其为虚拟机使用到的Native方法服务。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java虚拟机栈合二为一。&lt;/p&gt;

&lt;h2 id=&#34;java堆&#34;&gt;JAVA堆&lt;/h2&gt;

&lt;p&gt;*JAVA堆（JAVA Heap）*被所有线程共享的一块内存区域，在虚拟机启动时创建，被用于存放对象实例，是垃圾收集器管理的主要区域。&lt;/p&gt;

&lt;h2 id=&#34;方法区&#34;&gt;方法区&lt;/h2&gt;

&lt;p&gt;*方法区（Method Area）*与Java堆一样，是各个线程共享的内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。被称为&lt;code&gt;永久代&lt;/code&gt;，垃圾回收行为在该区域是相对较少出现的。
*运行常量池（Runtime Constant Pool）*是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用。&lt;/p&gt;

&lt;h2 id=&#34;直接内存&#34;&gt;直接内存&lt;/h2&gt;

&lt;p&gt;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是JAVA虚拟机规范中定义的内存区域。但这部分也被频繁使用，也可能导致OutOfMemoryError异常出现。直接内存的分配不受JAVA堆大小的限制，但是还是会受到本机总内存大小以及处理器寻址空间的限制。&lt;/p&gt;

&lt;h2 id=&#34;对象的访问定位&#34;&gt;对象的访问定位&lt;/h2&gt;

&lt;h3 id=&#34;使用句柄&#34;&gt;使用句柄&lt;/h3&gt;

&lt;p&gt;JAVA堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息。
优点：稳定，对象被移动只会改变句柄中实例数据指针，而reference本身不需要修改。
&lt;img src=&#34;https://jwftjq.bn.files.1drv.com/y4m1Tt8l7LeH5vWIEdq9c9zdVLyXr97wgn_YmcfDDpNdsaMBPbQYNOPUHedGOlXS7eakVI0oOoSZB08TeRrB4AShVp4Cjku2__xXuUErtgTONnVAkoLvlKzLnXvWWvy17OtXmMy8kmOzJmFAKtbbhANvZDqePqLNx8WZaz3D3XmCfP_N9xfROXXJf4gBf7diI7aKzV0_LS4H0F_bR41vHwmUg/bing.jpg&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;直接指针&#34;&gt;直接指针&lt;/h3&gt;

&lt;p&gt;reference中存储的直接就是对象地址。
优点：速度更快，节省一次指针定位的时间开销。
&lt;img src=&#34;https://jgftjq.bn.files.1drv.com/y4mssPKlB9jDykLBWj5lx5qcSxOgCJSru_-T0QsY7K4fAl8ndPpxgMriCJbz0h7FLNcoKWMVXtfRP0tBeI4dbcylX2w907qFY9B0F3fkxIHbAJ15X2Q4vigtsrK9CmKqCZY7faysTIzcl59klwSsH_qRMjLnWhfETvGJx4GJ_cNIVehrSrTpnY2qQG3ECW9FVtX0SIXyrA8edX5LCz5KSWhpg/direct.jpg&#34;&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;垃圾收集器与内存分配策略&#34;&gt;垃圾收集器与内存分配策略&lt;/h1&gt;

&lt;h2 id=&#34;引用计数算法&#34;&gt;引用计数算法&lt;/h2&gt;

&lt;p&gt;判断对象是否存活的算法：
给对象添加一个引用计数器，每当有一个地方引用它，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就不可能再被使用。&lt;/p&gt;

&lt;p&gt;但JAVA虚拟机中并未采用该算法来管理内存。
例：对象&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;都有字段&lt;code&gt;instance&lt;/code&gt;，赋值令&lt;code&gt;A.instance=B&lt;/code&gt;及&lt;code&gt;B.instance=A&lt;/code&gt;，除此之外两个对象无任何引用，实际上两个对象已经不可能再被访问，但因为互相引用着对方，导致引用计数都不为0，引用计数算法无法通知GC收集器回收。但执行&lt;code&gt;System.gc()&lt;/code&gt;时，A、B将被正常回收，说明虚拟机并未采用引用计数算法。&lt;/p&gt;

&lt;h2 id=&#34;可达性分析算法&#34;&gt;可达性分析算法&lt;/h2&gt;

&lt;p&gt;通过&lt;code&gt;GC Roots&lt;/code&gt;对象作为起始点，向下搜索节点，搜索走过的路径称为&lt;code&gt;引用链&lt;/code&gt;，当一个对象到&lt;code&gt;GC Roots&lt;/code&gt;没有任何引用链项链时，证明此对象不可用。
如下图，obj5、obj6、obj7虽然互相关联，但到&lt;code&gt;GC Roots&lt;/code&gt;不可达，所以将被判定为可回收对象。
&lt;img src=&#34;https://kqftjq.bn.files.1drv.com/y4mEPZS2f6F0u6RwfW_Q8InHU8TZmxpOmVZPp8r9FT4kDWqlIZooNqKkMfnpaRbbVRskS3wKsXiLdRcwr_7DTzovRXrmA2LdgwZCQzGbhvM09_kpIoHj9PusWU3sDFQW_Zh8gogoZw666MjOr_e6rba3mMgip051IGPaCpMTTNbgXZEjVMcs6ldl-Z5VTri89PouQ7-9PDy6I4nNILal9zcPg/reachability.jpg&#34;&gt;
JAVA中可作为&lt;code&gt;GC Roots&lt;/code&gt;的对象包括以下几种：
* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中Native方法引用的对象&lt;/p&gt;

&lt;h2 id=&#34;引用强度&#34;&gt;引用强度&lt;/h2&gt;

&lt;h3 id=&#34;强引用&#34;&gt;强引用&lt;/h3&gt;

&lt;p&gt;类似“Object obj = new Object()”这类的引用，只要强引用在，垃圾收集器永远不会回收掉被引用的对象。&lt;/p&gt;

&lt;h3 id=&#34;软引用&#34;&gt;软引用&lt;/h3&gt;

&lt;p&gt;有用但并非必需的对象。系统将要发生内存溢出异常之前，这些对象将被列入回收范围进行第二次回收。如果这次回收没有足够内存，才会抛出内存溢出异常。提供&lt;code&gt;SoftReference&lt;/code&gt;类实现软引用。&lt;/p&gt;

&lt;h3 id=&#34;弱引用&#34;&gt;弱引用&lt;/h3&gt;

&lt;p&gt;非必需对象，强度比软引用更弱一些，弱引用关联的对象只能够生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否够用，都会回收掉只被弱引用关联的对象。提供&lt;code&gt;WeakReference&lt;/code&gt;类实现弱引用。&lt;/p&gt;

&lt;h3 id=&#34;虚引用&#34;&gt;虚引用&lt;/h3&gt;

&lt;p&gt;也称幽灵引用、幻影引用，是最弱的引用关系。对象是否虚引用不对其生成时间有影响，也无法通过虚引用取得对象实例。唯一目的是对象被收集器回收时受到一个系统通知。提供&lt;code&gt;PhantomReference&lt;/code&gt;类实现虚引用。&lt;/p&gt;

&lt;h2 id=&#34;死亡与否&#34;&gt;死亡与否&lt;/h2&gt;

&lt;p&gt;一个对象死亡要经历两次标记过程，如果一个对象没有与&lt;code&gt;GC Roots&lt;/code&gt;相连接的引用链，那它将被第一次标记，并且筛选此对象有无必要执行&lt;code&gt;finalize()&lt;/code&gt;方法。若该对象在&lt;code&gt;finalize()&lt;/code&gt;方法中与任何引用链上的对象建立关联，则移出回收集合，否则将被回收。
任何一个对象的&lt;code&gt;finalize()&lt;/code&gt;方法只会被系统调用一次，第一次时被救回，下次回收将不再执行，回收自救将失败。
在JAVA中并不推荐使用&lt;code&gt;finalize()&lt;/code&gt;方法。&lt;/p&gt;

&lt;h2 id=&#34;垃圾收集算法&#34;&gt;垃圾收集算法&lt;/h2&gt;

&lt;h3 id=&#34;标记-清除算法&#34;&gt;标记-清除算法&lt;/h3&gt;

&lt;p&gt;标记出所有需要回收的对象，标记完成后统一回收所有被标记对象。
缺点：
* 效率问题，标记、清除两个过程效率不高
* 空间问题，标记、清除后将会产生大量不连续的内存碎片&lt;/p&gt;

&lt;h3 id=&#34;复制算法&#34;&gt;复制算法&lt;/h3&gt;

&lt;p&gt;将内存划分为等大容量的两块，每次只使用其中一块。当一块内存用完了，将存活对象复制到另一块内存上，再将已被使用过的内存空间一次清理掉，每次都对整个半区进行内存回收。实现简单，运行高效，但代价过高，将只使用内存的一半。&lt;/p&gt;

&lt;h3 id=&#34;标记-整理算法&#34;&gt;标记-整理算法&lt;/h3&gt;

&lt;p&gt;标记出所有需要回收的对象，将所有存活的对象往一端移动，然后直接清除端边界外的内存。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;类加载&#34;&gt;类加载&lt;/h1&gt;

&lt;h2 id=&#34;生命周期&#34;&gt;生命周期&lt;/h2&gt;

&lt;p&gt;类被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期包括：
&lt;code&gt;加载&lt;/code&gt;-&amp;gt;&lt;code&gt;验证&lt;/code&gt;-&amp;gt;&lt;code&gt;准备&lt;/code&gt;-&amp;gt;&lt;code&gt;解析&lt;/code&gt;-&amp;gt;&lt;code&gt;初始化&lt;/code&gt;-&amp;gt;&lt;code&gt;使用&lt;/code&gt;-&amp;gt;&lt;code&gt;卸载&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;触发类初始化的五种情况&#34;&gt;触发类初始化的五种情况&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;主动引用&lt;/code&gt;：
1. 遇到&lt;code&gt;new&lt;/code&gt;、&lt;code&gt;getstatic&lt;/code&gt;、&lt;code&gt;putstatic&lt;/code&gt;或&lt;code&gt;invokestatic&lt;/code&gt;这4条字节码指令时，如果类没有初始化，则需要先触发其初始化。
场景：
 使用&lt;code&gt;new&lt;/code&gt;关键字实例化对象；
 读取或设置一个类的静态变量（被&lt;code&gt;final&lt;/code&gt;修饰、已在编译期把结果放入常量池的静态变量除外）；
 调用一个类的静态方法。
2. 使用&lt;code&gt;java.lang.reflect&lt;/code&gt;包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，其父类还未初始化，则先触发其父类初始化。（但一个接口初始化的时候，并不要求父类接口全部完成初始化，只有在真正使用到父接口的时候才会初始化，如引用接口中定义的常量的时候）
4. 当虚拟机启动时，用户需要指定一个要执行的类（包含&lt;code&gt;main()&lt;/code&gt;方法的那个类），虚拟机会先初始化这个主类。
5. 当使用&lt;code&gt;JDK1.7&lt;/code&gt;的动态语言支持时，如果一个&lt;code&gt;java.lang.invoke.MethodHandle&lt;/code&gt;实例最后解析的结果&lt;code&gt;REF_getStatic&lt;/code&gt;、&lt;code&gt;REF_putStatic&lt;/code&gt;、&lt;code&gt;REF_invokeStatic&lt;/code&gt;的方法句柄，并且这个方法的句柄所对应的类还未初始化过，则需要先触发其初始化。&lt;/p&gt;

&lt;p&gt;初次之外引用类的方式都不会触发初始化，称为&lt;code&gt;被动引用&lt;/code&gt;。
例1：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class SuperClass{
    static{
        System.out.println(&amp;quot;init SuperClass&amp;quot;);
    }
    public static int value = 123;
}
public class SubClass extends SuperClass{
    static{
        System.out.println(&amp;quot;init SubClass&amp;quot;);
    }
}

System.out.println(SubClass.value);
//结果：
//init SuperClass
//对于静态变量，只有直接定义这个字段的类才会被初始化
//因此通过其子类引用父类中定义的静态变量，只会触发父类的初始化而不会触发子类的初始化。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例2：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ConstClass{
    static{
        System.out.println(&amp;quot;init ConstClass&amp;quot;);
    }
    public static final String HELLOWORLD = &amp;quot;hello world&amp;quot;;
}
public class NotInitialization{
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
//结果：
//hello world
//ConstClass并未被初始化
//在编译阶段HELLOWORLD的值被存储到NotInitialization类的常量池中，
//以后NotInitialization对常量ConstClass.HELLOWORLD的引用实际都转化为NotInitialization类对自身常量池的引用。
//实际上，NotInitialization的class文件并没有ConstClass类的符号引入入口，
//在编译成class后两个类不存在任何联系。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;分派&#34;&gt;分派&lt;/h1&gt;

&lt;h2 id=&#34;静态分派&#34;&gt;静态分派&lt;/h2&gt;

&lt;p&gt;编译器在编译程序时并不知道一个对象的实际类型，在重载时是通过参数的静态类型而不是实际类型作为判断依据的。
实际类型的变化在运行期才能确定，而静态类型是编译期可知的。
&lt;code&gt;Human man = new Man();&lt;/code&gt;其中&lt;code&gt;Human&lt;/code&gt;为静态类型或外观类型，而&lt;code&gt;Man&lt;/code&gt;为实际类型。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class StaticDispatch{

    static abstract class Human{}

    static class Man extends Human{}
    static class Woman extends Human{}

    public void sayHello(Human guy){
        System.out.println(&amp;quot;hello,guy!&amp;quot;);
    }
    public void sayHello(Man guy){
        System.out.println(&amp;quot;hello,man!&amp;quot;);
    }
    public void sayHello(Woman guy){
        System.out.println(&amp;quot;hello,woman!&amp;quot;);
    }
    public static void main(String args[]){
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sd = new StaticDispatch();
        sd.sayHello(man);
        sd.sayHello(woman);
    }
    //结果：
    //hello,guy!
    //hello,guy!
    //
    //注释public void sayHello(Human guy)后，eclipse报错：
    //The method sayHello(StaticDispatch.Man) in the type StaticDispatch is not applicable for the arguments (StaticDispatch.Human)
    //找不到匹配参数的方法。
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;重载方法匹配优先级&#34;&gt;重载方法匹配优先级&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Overload{
    public static void sayHello(Object arg){
        System.out.println(&amp;quot;hello Object&amp;quot;);
    }
    public static void sayHello(int arg){
        System.out.println(&amp;quot;hello int&amp;quot;);
    }
    public static void sayHello(long arg){
        System.out.println(&amp;quot;hello long&amp;quot;);
    }
    public static void sayHello(char arg){
        System.out.println(&amp;quot;hello char&amp;quot;);
    }
    public static void sayHello(char... arg){
        System.out.println(&amp;quot;hello char...&amp;quot;);
    }
    public static void sayHello(Character arg){
        System.out.println(&amp;quot;hello Character&amp;quot;);
    }
    public static void sayHello(Serializable arg){
        System.out.println(&amp;quot;hello Serializable&amp;quot;);
    }
    public static void main(String args[]){
        sysHello(&#39;a&#39;);
    }
    //结果：
    //hello char
    //注释sayHello(char arg)，char将按照char-&amp;gt;int-&amp;gt;long-&amp;gt;float-&amp;gt;double顺序转型，但不会匹配到byte和short的重载，因为char到byte或short转型并不安全：
    //hello int
    //注释sayHello(int arg)
    //hello long
    //注释sayHello(long arg)，发生自动装箱：
    //hello Character
    //注释sayHello(Character arg)，java.lang.Serializable是java.lang.Character类实现的一个接口，自动装箱后找不到装箱类，但找到了装箱类实现的接口类型，再一次自动转型：
    //hello Serializable
    //注释sayHello(Serializable arg)，char装箱后转型为父类了，多个父类则从继承关系从下往上搜索，越接近上层优先级越低：
    //hello Object
    //注释sayHello(Object arg)，可变长参数的优先级别是最低的：
    //hello char...
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;动态分派&#34;&gt;动态分派&lt;/h2&gt;

&lt;p&gt;运行期根据实际类型确定方法执行版本的分派过程称之为&lt;code&gt;动态分派&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class DynamicDispatch{
    static abstract class Human{
        protected abstract void sayHello();
    }
    static class Man extends Human{
        @Override
        protected void sayHello(){
            System.out.println(&amp;quot;man say hello&amp;quot;);
        }
    }
    static class Woman extends Human{
        @Override
        protected void sayHello(){
            System.out.println(&amp;quot;woman say hello&amp;quot;);
        }
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        woman.sayHello();
    }
    //结果：
    //man say hello
    //woman say hello
    //woman say hello
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>图总结及代码实现</title>
      <link>https://boseman1024.github.io/2018/%E5%9B%BE%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 07 Jun 2018 11:31:26 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E5%9B%BE%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid>
      <description>

&lt;h1 id=&#34;图&#34;&gt;图&lt;/h1&gt;

&lt;h2 id=&#34;数组表示法&#34;&gt;数组表示法&lt;/h2&gt;

&lt;h3 id=&#34;无向图&#34;&gt;无向图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://kziiuw.bn.files.1drv.com/y4m2IUbPTi0WnWXtECNGRHz4MuWlq5pBUsSiFq9tVOzQgBJV4m0FjI3KKjGlGsBGDYiykRy5q8q6wn1gnqO5rkKcPq0wkyW4J-RRvoFJ4IqbITdICYRPZtpwgXPJL9UNpaE5HXpnJf9kFnk8ZbBDnlbD15sPxH7usDK8Hn0M2Alg5MaSe0FxCbT7oo2dwG7MF4tKnl_VcyW9LX5vGkwvHO-VA/wuxiang.jpg&#34;&gt;&lt;/p&gt;

&lt;p&gt;数组矩阵表示如下：
&lt;table border=&#34;1&#34; style=&#34;width:100%;text-align:center;margin: 0;padding: 0&#34;&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;有向图&#34;&gt;有向图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://nqftjq.bn.files.1drv.com/y4mFSMrs-TX1vnTJPsZiGJPR43BPUVl1ejkW3sxyvtG4DH00x4RwCvZ2SjOO8faQfdRfakm5sDcKKBFt02MEjp_bn4bnsFvVrUWpSgQPD_IrykT4DTfWh8_nIBYgQOGzPx1Zgijx5WOFHn4IG--ZzAjD0l9ECDiZXmj2tL5sPW4kKrFnLafDABDk5aXCEfndwZvgqJTf8TCyrobC6UC_ycx3Q/youxiang.jpg&#34;&gt;&lt;/p&gt;

&lt;p&gt;数组矩阵表示如下：
&lt;table border=&#34;1&#34; style=&#34;width:100%;text-align:center;margin: 0;padding: 0&#34;&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;9&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;图的遍历&#34;&gt;图的遍历&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://i5iiuw.bn.files.1drv.com/y4mqiNfh_Kms7FbOONXFdjYC0gQVkfuloNCjB_DOyJExl2e1AkHnaUN8lJN5MhFS57JvjMxq-U1xsKR5hmnSFLU4GvkRiX0kDk5Js7MwS_FGISPoB8vcHa9-1a9do30XEUyiajTmk8AScPEEPSMrs1YxctMGjGn77jPf_40ft6vj31bhlthm7ZTh3z2sMzsiSQAmeeJZeGPRlgZnObnGCKoNQ/bianli.jpg&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;深度优先搜索&#34;&gt;深度优先搜索&lt;/h2&gt;

&lt;p&gt;其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。
深度优先搜索的遍历访问顺序并不唯一。&lt;/p&gt;

&lt;p&gt;假设以&lt;code&gt;V1&lt;/code&gt;为起点，
&lt;code&gt;V1&lt;/code&gt;有两个邻接点&lt;code&gt;V2&lt;/code&gt;与&lt;code&gt;V3&lt;/code&gt;且都未被访问，则访问&lt;code&gt;V2&lt;/code&gt;（或访问&lt;code&gt;v3&lt;/code&gt;开始皆可，以下皆如此）；
&lt;code&gt;V2&lt;/code&gt;有三个邻接点&lt;code&gt;V1&lt;/code&gt;、&lt;code&gt;V4&lt;/code&gt;、&lt;code&gt;V5&lt;/code&gt;，&lt;code&gt;V1&lt;/code&gt;已被访问，&lt;code&gt;V4&lt;/code&gt;与&lt;code&gt;V5&lt;/code&gt;都未被访问，则访问&lt;code&gt;V4&lt;/code&gt;；
&lt;code&gt;V4&lt;/code&gt;有两个邻接点&lt;code&gt;V2&lt;/code&gt;与&lt;code&gt;V8&lt;/code&gt;，只有&lt;code&gt;V8&lt;/code&gt;未被访问，则访问&lt;code&gt;V8&lt;/code&gt;；
&lt;code&gt;V8&lt;/code&gt;有两个邻接点&lt;code&gt;V4&lt;/code&gt;与&lt;code&gt;V5&lt;/code&gt;，&lt;code&gt;V4&lt;/code&gt;已被访问，则访问&lt;code&gt;V5&lt;/code&gt;；
&lt;code&gt;V5&lt;/code&gt;有两个邻接点&lt;code&gt;V2&lt;/code&gt;与&lt;code&gt;V8&lt;/code&gt;，且&lt;code&gt;V2&lt;/code&gt;、&lt;code&gt;V8&lt;/code&gt;都已被访问，则从头搜索&lt;code&gt;V1&lt;/code&gt;的邻接点&lt;code&gt;V2&lt;/code&gt;、&lt;code&gt;V3&lt;/code&gt;，&lt;code&gt;V2&lt;/code&gt;已被访问，则访问&lt;code&gt;V3&lt;/code&gt;；
&lt;code&gt;V3&lt;/code&gt;有三个邻接点&lt;code&gt;V1&lt;/code&gt;、&lt;code&gt;V6&lt;/code&gt;、&lt;code&gt;V7&lt;/code&gt;且未被访问，则访问&lt;code&gt;V6&lt;/code&gt;；
&lt;code&gt;V6&lt;/code&gt;有两个邻接点&lt;code&gt;V3&lt;/code&gt;与&lt;code&gt;V7&lt;/code&gt;，&lt;code&gt;V3&lt;/code&gt;已被访问，则访问&lt;code&gt;V7&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;则以&lt;code&gt;V1&lt;/code&gt;为起点的深度优先搜索访问顺序为：
&lt;code&gt;V1-&amp;gt;V2-&amp;gt;V4-&amp;gt;V8-&amp;gt;V5-&amp;gt;V3-&amp;gt;V6-&amp;gt;V7&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void dfs(int[][] grid,int i,int j,int rows,int cols){
    if(i&amp;lt;0||j&amp;lt;0||i&amp;gt;=rows||j&amp;gt;=cols||grid[i][j]==-1){return;}
    System.out.println(grid[i][j]);
    //标记已访问点
    grid[i][j]=-1;
    dfs(grid,i,j+1,rows,cols);
    dfs(grid,i,j-1,rows,cols);
    dfs(grid,i+1,j,rows,cols);
    dfs(grid,i-1,j,rows,cols);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;广度优先搜索&#34;&gt;广度优先搜索&lt;/h2&gt;

&lt;p&gt;类似于树的按层次遍历的过程，可先将图按层划分。
广度优先搜索的遍历访问顺序并不唯一。&lt;/p&gt;

&lt;p&gt;假设以&lt;code&gt;V1&lt;/code&gt;为起点，则可划分为下图：
&lt;img src=&#34;https://jziiuw.bn.files.1drv.com/y4mTokhO7WiYqo2IvZseXV5EHASpsTO-aRZvnw7X25uHngheqwi971jMOBIkf1yeER8QJerf-2RKZcOTnXfuZ1yFkgmqEhuL0TZbJTYi_PbiA8qC6RATb2fnAmj6feMDTeyG4kj6m22KSE0m0El8lToGUPupd1qq60wnekTHs8sPXtBnvjDwR-3TXBlt2u80Tj69kIM7cV_pT_cIVAtEmG24g/fenceng.jpg&#34;&gt;&lt;/p&gt;

&lt;p&gt;第一层（V1）：
&lt;code&gt;V1&lt;/code&gt;有两个邻接点&lt;code&gt;V2&lt;/code&gt;、&lt;code&gt;V3&lt;/code&gt;，则先访问&lt;code&gt;V2&lt;/code&gt;，再访问&lt;code&gt;V3&lt;/code&gt;（或先访问&lt;code&gt;V3&lt;/code&gt;，再访问&lt;code&gt;V2&lt;/code&gt;皆可，以下皆如此）；
第二层(V2、V3)：
&lt;code&gt;V2&lt;/code&gt;有三个邻接点&lt;code&gt;V1&lt;/code&gt;、&lt;code&gt;V4&lt;/code&gt;、&lt;code&gt;V5&lt;/code&gt;，&lt;code&gt;V1&lt;/code&gt;已被访问，则访问&lt;code&gt;V4&lt;/code&gt;、&lt;code&gt;V5&lt;/code&gt;；
&lt;code&gt;V3&lt;/code&gt;有两个邻接点&lt;code&gt;V6&lt;/code&gt;、&lt;code&gt;V7&lt;/code&gt;且都未被访问，则访问&lt;code&gt;V6&lt;/code&gt;、&lt;code&gt;V7&lt;/code&gt;；
第三层（V4、V5、V6、V7）：
&lt;code&gt;V4&lt;/code&gt;有两个邻接点&lt;code&gt;V2&lt;/code&gt;与&lt;code&gt;V8&lt;/code&gt;，&lt;code&gt;V2&lt;/code&gt;已被访问，则访问&lt;code&gt;V8&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;则以&lt;code&gt;V1&lt;/code&gt;为起点的广度优先搜索访问顺序为：
&lt;code&gt;V1-&amp;gt;V2-&amp;gt;V3-&amp;gt;V4-&amp;gt;V5-&amp;gt;V6-&amp;gt;V7-&amp;gt;V8&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;最小生成树&#34;&gt;最小生成树&lt;/h1&gt;

&lt;p&gt;在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。
最小生成树中不存在回路。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://j5iiuw.bn.files.1drv.com/y4mlTpiFkVd9CxeKKmK2sFkAloYrcXLdQ5R3GkwZgzgfPtIgjqK0pmlLRjjmHF5XwgYLdPCTEYBEywm1PlwFQUQNgK9U6C37Coh4zPX6HV_CVi_UXcFR9yxuEJVfgu-qe1ce5zCzu-9M6F21Z7YqxOULCVuf2HDZRtu64Kft5vNjz7fIKUo3O_DMzDjwynKNdtMndd3dWDeQxeykB-JZVhbiA/mini.jpg&#34;&gt;&lt;/p&gt;

&lt;p&gt;可得数组矩阵：
&lt;table border=&#34;1&#34; style=&#34;width:100%;text-align:center;margin: 0;padding: 0&#34;&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;∞&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;

&lt;h2 id=&#34;普里姆-prim-算法&#34;&gt;普里姆（Prim）算法&lt;/h2&gt;

&lt;p&gt;此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kpiiuw.bn.files.1drv.com/y4mja8RDcpPdxAbesqpRa5bEQ45M4qCsiOldNGo6t_HiYftqnhssC9dMdLQiSXzwDjsGUNK88_0M-pSLL6DFEXzHVWM-kuoYoXD8UTOqK4YPVAiir1nAfu_v1p36kPC5suMarx6LFaxHwTLofjicFlCx0RKt9NGtc0fuxbzLjO8msOZMO34xqOuS-PbKIUQGvFyjP7iHacnAz0DZnKNFhYb_Q/prim.jpg&#34;&gt;&lt;/p&gt;

&lt;p&gt;设：
* 所有结点V={V1,V2,V3,V4,V5,V6}
* 已选结点U={}
* 剩余结点V-U
* 代价最小的边MIN&lt;/p&gt;

&lt;table border=&#34;1&#34; style=&#34;width:100%;text-align:center;margin: 0;padding: 0&#34;&gt;
&lt;thead&gt;&lt;tr&gt;&lt;th&gt;index&lt;/th&gt;&lt;th&gt;V-U&lt;/th&gt;&lt;th&gt;U&lt;/th&gt;&lt;th&gt;MIN(边)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;{V1,V2,V3,V4,V5,V6}&lt;/td&gt;&lt;td&gt;{}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;{V2,V3,V4,V5,V6}&lt;/td&gt;&lt;td&gt;{V1}&lt;/td&gt;&lt;td&gt;1(V1-V3)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;{V2,V4,V5,V6}&lt;/td&gt;&lt;td&gt;{V1,V3}&lt;/td&gt;&lt;td&gt;4(V3-V6)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;{V2,V4,V5}&lt;/td&gt;&lt;td&gt;{V1,V3,V6}&lt;/td&gt;&lt;td&gt;2(V6-V4)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;{V2,V5}&lt;/td&gt;&lt;td&gt;{V1,V3,V6,V4}&lt;/td&gt;&lt;td&gt;5(V3-V2)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;{V5}&lt;/td&gt;&lt;td&gt;{V1,V3,V6,V4,V2}&lt;/td&gt;&lt;td&gt;3(V2-V5)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;{}&lt;/td&gt;&lt;td&gt;{V1,V3,V6,V4,V2,V5}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;或设：
* 所有结点V={V1,V2,V3,V4,V5,V6}
* 已选结点U={}
* 剩余结点V-U
* 序列i（1,2,3,…,V的个数），每个序列下为每个结点的最小代价边。
* 选择序列k，被选择序列设为0&lt;/p&gt;

&lt;p&gt;每个结点的多条代价边中选最小代价边。
如：
2-1中，V2距离V-U存在6（V2-V1），5（V2-V3）两条边，则选择6（V2-V1）。&lt;/p&gt;

&lt;table border=&#34;1&#34; style=&#34;width:100%;text-align:center;margin: 0;padding: 0&#34;&gt;
&lt;thead&gt;&lt;tr&gt;&lt;th&gt;index\i&lt;/th&gt;&lt;th&gt;1&lt;/th&gt;&lt;th&gt;2&lt;/th&gt;&lt;th&gt;3&lt;/th&gt;&lt;th&gt;4&lt;/th&gt;&lt;th&gt;5&lt;/th&gt;&lt;th&gt;U&lt;/th&gt;&lt;th&gt;V-U&lt;/th&gt;&lt;th&gt;k(选择序列)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;V1-6&lt;/td&gt;&lt;td&gt;V1-1&lt;/td&gt;&lt;td&gt;V1-5&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;{V1}&lt;/td&gt;&lt;td&gt;{V2,V3,V4,V5,V6}&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;V3-5&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;V1-5&lt;/td&gt;&lt;td&gt;V3-6&lt;/td&gt;&lt;td&gt;V3-4&lt;/td&gt;&lt;td&gt;{V1,V3}&lt;/td&gt;&lt;td&gt;{V2,V4,V5,V6}&lt;/td&gt;&lt;td&gt;5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;V3-5&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;V6-2&lt;/td&gt;&lt;td&gt;V3-6&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;{V1,V3,V6}&lt;/td&gt;&lt;td&gt;{V2,V3,V4,V5}&lt;/td&gt;&lt;td&gt;3&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;V3-5&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;V3-6&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;{V1,V3,V6,V4}&lt;/td&gt;&lt;td&gt;{V2,V5}&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;V2-3&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;{V1,V3,V6,V4,V2}&lt;/td&gt;&lt;td&gt;{V5}&lt;/td&gt;&lt;td&gt;4&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;{V1,V3,V6,V4,V2,V5}&lt;/td&gt;&lt;td&gt;{}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;克鲁斯卡尔-kruskal-算法&#34;&gt;克鲁斯卡尔（Kruskal）算法&lt;/h2&gt;

&lt;p&gt;每次在剩下的所有未选取的边中，找最小边，如果和已选取的边构成回路，则放弃，选取次小边。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kjiiuw.bn.files.1drv.com/y4m5Pe_CTVaOvlExT9TkkcaSW_jqcUtgsqSEmjwSmeku-ZNsuEQRujcfJF7_xJJ-FoQCFztoCyz4nCnMcMyZMaxex72wMoycSwGG5KlOluK0yhG5fyk0Sdt1bZobL_jfgY0t51UdJCT35JpyLLWkZdVqZyuLfH0WVdc74-VZBuoO2WaDd83u32FR_8XXFR-qaxa27hPMaH3tnV3ri2H0_GFbQ/kruskal.jpg&#34;&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;最短路径&#34;&gt;最短路径&lt;/h1&gt;

&lt;h2 id=&#34;有向带权图&#34;&gt;有向带权图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://jpiiuw.bn.files.1drv.com/y4mTGASFsvVJ2BiRIKmLiFCAkFmC8iOV4KR4I-BR_yv7JRPkXX3GNwXea05EUNqaZhbR5toBr20EmsQN4XUSsCUgOoJs9R0Qfmr2IyvqE-auyRgiM2NOapt4awLS5QqngSxa3mnugaxhECSa2TWj-V6BcHm6FD-QjaViSjnczCzf-GHkUtNRs1kRis4HlW1d7yVA86kVaWZKo8GyPGc1_Z3vg/directGraph.jpg&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;迪杰斯特拉-dijkstra-算法&#34;&gt;迪杰斯特拉（Dijkstra）算法&lt;/h2&gt;

&lt;p&gt;设：
* 已选顶点元素集合&lt;code&gt;S&lt;/code&gt;
* 起点&lt;code&gt;V&lt;/code&gt;到其余顶点i的带权长度(Distance)&lt;code&gt;D[]&lt;/code&gt;，&lt;code&gt;D[V]&lt;/code&gt;初始化为&lt;code&gt;0&lt;/code&gt;，其他元素初始化为&lt;code&gt;∞&lt;/code&gt;
* &lt;code&gt;S&lt;/code&gt;到其余顶点&lt;code&gt;i&lt;/code&gt;的最短序列上顶点i的前一个顶点(Pre)&lt;code&gt;P[]&lt;/code&gt;，所有元素初始化为起点&lt;code&gt;V&lt;/code&gt;
* &lt;code&gt;S&lt;/code&gt;中的中间点&lt;code&gt;v&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;若存在&lt;code&gt;D[v]+weight(v,i)&amp;lt;D[i]&lt;/code&gt;，则&lt;code&gt;P[i]=v；D[i]=D[v]+weight(v,i);&lt;/code&gt;&lt;/p&gt;

&lt;table border=&#34;1&#34; style=&#34;width:100%;text-align:center;margin: 0;padding: 0&#34;&gt;&lt;tr&gt;&lt;td&gt;index&lt;/td&gt;&lt;td&gt;S&lt;/td&gt;&lt;td&gt;V0&lt;/td&gt;&lt;td&gt;V1&lt;/td&gt;&lt;td&gt;V2&lt;/td&gt;&lt;td&gt;V3&lt;/td&gt;&lt;td&gt;V4&lt;/td&gt;&lt;td&gt;V5&lt;/td&gt;&lt;td&gt;CHOOSE&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;起点&lt;/td&gt;&lt;td&gt;{V0}&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[0]=0/P[0]=0&lt;/td&gt;&lt;td&gt;D[1]=∞/P[1]=0&lt;/td&gt;&lt;td&gt;D[2]=10/P[2]=0&lt;/td&gt;&lt;td&gt;D[3]=∞/P[3]=0&lt;/td&gt;&lt;td&gt;D[4]=30/P[4]=0&lt;/td&gt;&lt;td&gt;D[5]=100/P[5]=0&lt;/td&gt;&lt;td&gt;D[2]最小&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;{V0,V2}&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[0]=0/P[0]=0&lt;/td&gt;&lt;td&gt;D[1]=∞/P[1]=0&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[2]=10/P[2]=0&lt;/td&gt;&lt;td&gt;D[3]=60/P[3]=2&lt;/td&gt;&lt;td&gt;D[4]=30/P[4]=0&lt;/td&gt;&lt;td&gt;D[5]=100/P[5]=0&lt;/td&gt;&lt;td&gt;D[4]最小&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;{V0,V2,V4}&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[0]=0/P[0]=0&lt;/td&gt;&lt;td&gt;D[1]=∞/P[1]=0&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[2]=10/P[2]=0&lt;/td&gt;&lt;td&gt;D[3]=50/P[3]=4&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[4]=30/P[4]=0&lt;/td&gt;&lt;td&gt;D[5]=90/P[5]=4&lt;/td&gt;&lt;td&gt;D[3]最小&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;{V0,V2,V4,V3}&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[0]=0/P[0]=0&lt;/td&gt;&lt;td&gt;D[1]=∞/P[1]=0&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[2]=10/P[2]=0&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[3]=50/P[3]=4&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[4]=30/P[4]=0&lt;/td&gt;&lt;td&gt;D[5]=60/P[5]=3&lt;/td&gt;&lt;td&gt;只剩D[5]&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;{V0,V2,V4,V3,V5}&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[0]=0/P[0]=0&lt;/td&gt;&lt;td&gt;D[1]=∞/P[1]=0&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[2]=10/P[2]=0&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[3]=50/P[3]=4&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[4]=30/P[4]=0&lt;/td&gt;&lt;td style=&#34;color:#FF0000;&#34;&gt;D[5]=60/P[5]=3&lt;/td&gt;&lt;td&gt;结束&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;从上表中可知，
以V0为起点至V5的最短路径为：
&lt;code&gt;P[5]=3&lt;/code&gt; -&amp;gt; &lt;code&gt;P[3]=4&lt;/code&gt; -&amp;gt; &lt;code&gt;P[4]=0&lt;/code&gt; -&amp;gt; &lt;code&gt;P[0]=0&lt;/code&gt;
即 &lt;code&gt;0&lt;/code&gt; -&amp;gt; &lt;code&gt;4&lt;/code&gt; -&amp;gt; &lt;code&gt;3&lt;/code&gt; -&amp;gt; &lt;code&gt;5&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JAVA基础整理</title>
      <link>https://boseman1024.github.io/2018/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 03 Jun 2018 21:47:14 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</guid>
      <description>

&lt;p&gt;&lt;code&gt;八大基本类型&lt;/code&gt;：
* 字节型（byte）-8位
* 短整型（short）-16位
* 整型（int）-32位
* 长整型（long）-64位
* 字符型（char）-16位
* 浮点型（float）-32位
* 双精度型（double）-64位
* 布尔型（boolean）-1位&lt;/p&gt;

&lt;p&gt;基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer x = 2;     // 装箱
int y = x;         // 拆箱
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;new Integer(123)&lt;/code&gt;与&lt;code&gt;Integer.valueOf(123)&lt;/code&gt;的区别在于，&lt;code&gt;new Integer(123)&lt;/code&gt;每次都会新建一个对象，而&lt;code&gt;Integer.valueOf(123)&lt;/code&gt;可能会使用缓存对象，因此多次使用&lt;code&gt;Integer.valueOf(123)&lt;/code&gt;会取得同一个对象的引用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译器会在自动装箱过程调用&lt;code&gt;valueOf()&lt;/code&gt;方法，因此多个&lt;code&gt;Integer&lt;/code&gt;实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer m = 123;
Integer n = 123;
System.out.println(m == n); // true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JVM会在常量池中缓存-128到127之间的整数，所以任何在-128到127之间的整数的地址都是相同的。 对于引用类型的变量，==和.equals()比较的都是其地址，除非该类对.equals()方法进行了重写，例如String类和Integer类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Integer a = 1;
Integer b = 2;
Integer c = 3;
Integer d = 3;
Integer e = 321;
Integer f = 321;
Long g = 3L;
System.out.println(c==d);//true
System.out.println(e==f);//false
System.out.println(c==(a+b));//true
System.out.println(c.equals(a+b));//true
System.out.println(g==(a+b));//true
System.out.println(g.equals(a+b));//false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;valueOf()&lt;/code&gt;方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接使用缓存池的内容。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static Integer valueOf(int i) {
    if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;对象变量&lt;/code&gt;:
一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
即任何对象变量的值都是对存储在另一个地方的一个对象的引用。
String为封装类，属于引用类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;构造器&lt;/code&gt;：
* 构造器与类同名
* 每个类可以有一个以上的构造器
* 构造器可以有0个、1个或者多个参数
* 构造器没有返回值
* 构造器总是伴随着new操作一起调用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;带标签的break语句&lt;/code&gt;：
用于跳出多重嵌套的循环语句。
标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;label:
while(condition){
    for(condition){
        if(condition){
            break label;//跳出最外层循环，打印end
        }
    }
}
System.out.println(&amp;quot;end&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;方法参数&lt;/code&gt;：
java总是采用按值调用，即方法得到的是所有参数值的一个拷贝，方法不能修改传递给它的任何参数变量的内容。
* 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）
* 一个方法可以改变一个对象参数的状态
* 一个方法不能让对象参数引用一个新的对象&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void add(int num){
    num += 100;
}
int money = 100;
add(money);
/*
num为100，是money的值拷贝。
方法执行后money仍然为100，
而num为200，且方法结束后被丢弃。
*/
Employee a = new Employee(&amp;quot;Jack&amp;quot;);
Employee b = new Employee(&amp;quot;Bob&amp;quot;);

public void raiseSalary(Employee x){
    x.salary += 1000;
}
raiseSalary(a);
/*
x为a值的拷贝，即a的引用对象。
所以x与a同时引用同一个对象。
x.salary+1000即a.salary+1000。
*/
public void swap(Employee x,Employee y){
    Employee temp = x;
    x = y;
    y = temp;
}

swap(a,b);
/*
a-&amp;gt;Jack
b-&amp;gt;Bob
x-&amp;gt;Bob
y-&amp;gt;Jack
即 a，b仍然引用原先的对象。
而 a，b的拷贝x，y交换引用对象，且方法结束时被丢弃。
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;初始化顺序&lt;/code&gt;：
　&lt;code&gt;静态代码块&lt;/code&gt;：static{}，加载类时执行，仅执行一次。
　&lt;code&gt;构造代码块&lt;/code&gt;：{}，每一次创建对象时执行，给所有对象进行统一初始化，是不同对象共同的初始化内容。
 　&lt;code&gt;执行优先级&lt;/code&gt;：静态代码块 &amp;gt; main()“main为static方法” &amp;gt; 构造代码块 &amp;gt; 构造方法&lt;/p&gt;

&lt;p&gt;存在&lt;code&gt;继承&lt;/code&gt;的情况下，&lt;code&gt;初始化顺序&lt;/code&gt;为：
* 父类（静态变量、静态语句块）
* 子类（静态变量、静态语句块）
* 父类（实例变量、普通语句块）
* 父类（构造函数）
* 子类（实例变量、普通语句块）
* 子类（构造函数）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;访问修饰符&lt;/code&gt;：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;访问修饰符&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;同类&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;同包&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;子类&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;不同包&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;public&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;protected&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;默认没有访问控制修饰符&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;private&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;✔&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;❌&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;类修饰符&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;　&lt;code&gt;final&lt;/code&gt;：
* 修饰的类不能被继承，没有子类
* final类中的方法自动成为final方法，但不包括域&lt;/p&gt;

&lt;p&gt;　&lt;code&gt;abstract&lt;/code&gt;：
* 抽象类不能被实例化
* 含有抽象方法的类必须被声明为抽象类，但抽象类不一定要有抽象方法
* 抽象类必须被子类继承，抽象方法必须被重写，非抽象方法则不必
* 抽象类可以包含具体数据和具体方法（不推荐）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;abstract class A{
    abstract void player();
    public void s(){
        System.out.println(&amp;quot;1&amp;quot;);
    }
}
class B extends A{
    @Override
    public void player(){
        System.out.println(&amp;quot;2&amp;quot;);
        super.s();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;覆盖（Override）&lt;/code&gt;存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;重载（Overload）&lt;/code&gt;存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。应该注意的是，返回值不同，其它都相同不算是重载。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;异常&#34;&gt;异常&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Throwable&lt;/code&gt;可以用来表示任何可以作为异常抛出的类，分为两种：&lt;code&gt;Error&lt;/code&gt;和 &lt;code&gt;Exception&lt;/code&gt;。
其中&lt;code&gt;Error&lt;/code&gt;用来表示&lt;code&gt;JVM&lt;/code&gt;无法处理的错误，&lt;code&gt;Exception&lt;/code&gt;分为两种：
* &lt;code&gt;检查异常&lt;/code&gt;：需要用&lt;code&gt;try{}catch(){}&lt;/code&gt;语句捕获并进行处理，并且可以从异常中恢复；
* &lt;code&gt;未检查异常&lt;/code&gt;：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序奔溃并且无法恢复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://naftjq.bn.files.1drv.com/y4mIn93zBdQu-j42tZHKYVBryrhCpRmU8CXOblKlLPDl7KjEP1SDkh7w-KhMZPnIw-ELRwY00Z6ISUKvm7sbWD4DpU8h_SZHDEU8wQ9nTRQXbjSJ6o-kjTgv1vei9ZJFmT8uWMe_zSY7V1j6wF4DB21zl5pcgaLyINoxq5lBTYCBp7nWZyOK8YCIDN1gnFHHdXEGkvasweBJNUVYDlpVPLMOA/Throwable.png&#34;&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://www.tianmaying.com/tutorial/Java-Exception&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Java 入门之异常处理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.importnew.com/7383.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Java 异常的面试问题及答案 -Part 1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;反射&#34;&gt;反射&lt;/h1&gt;

&lt;p&gt;每个类都有一个&lt;code&gt;Class&lt;/code&gt;对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的&lt;code&gt;.class&lt;/code&gt;文件，该文件内容保存着&lt;code&gt;Class&lt;/code&gt;对象。
类加载相当于&lt;code&gt;Class&lt;/code&gt;对象的加载。类在第一次使用时才动态加载到 JVM 中，可以使用&lt;code&gt;Class.forName(&amp;quot;com.mysql.jdbc.Driver&amp;quot;)&lt;/code&gt;这种方式来控制类的加载，该方法会返回一个&lt;code&gt;Class&lt;/code&gt;对象。
反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的&lt;code&gt;.class&lt;/code&gt;不存在也可以加载进来。
&lt;code&gt;Class&lt;/code&gt;和&lt;code&gt;java.lang.reflect&lt;/code&gt;一起对反射提供了支持，&lt;code&gt;java.lang.reflect&lt;/code&gt;类库主要包含了以下三个类：
* &lt;code&gt;Field&lt;/code&gt;：可以使用&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;set()&lt;/code&gt;方法读取和修改&lt;code&gt;Field&lt;/code&gt;对象关联的字段；
* &lt;code&gt;Method&lt;/code&gt;：可以使用&lt;code&gt;invoke()&lt;/code&gt;方法调用与&lt;code&gt;Method&lt;/code&gt;对象关联的方法；
* &lt;code&gt;Constructor&lt;/code&gt;：可以用&lt;code&gt;Constructor&lt;/code&gt;创建新的对象。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.sczyh30.com/posts/Java/java-reflection-1/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;深入解析 Java 反射（1）- 基础&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;泛型&#34;&gt;泛型&lt;/h1&gt;

&lt;p&gt;泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运行时不存在任何类型相关的信息。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;http://www.importnew.com/24029.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Java 泛型详解&lt;/a&gt;
&lt;a href=&#34;https://cloud.tencent.com/developer/article/1033693&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;10 道 Java 泛型面试题&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;接口&#34;&gt;接口&lt;/h1&gt;

&lt;p&gt;接口中的所有方法自动地属于public。
接口中的域自动地设为public static final。&lt;/p&gt;

&lt;h1 id=&#34;内部类&#34;&gt;内部类&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;双括号初始化&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ArrayList&amp;lt;String&amp;gt; friends = new ArrayList&amp;lt;&amp;gt;();
friends.add(&amp;quot;harry&amp;quot;);
friends.add(&amp;quot;tony&amp;quot;);
invite(friends);
//如果不再需要friends这个数组列表，可以作为一个匿名列表并为其添加元素。
invite(new ArrayList&amp;lt;String&amp;gt;(){{
    add(&amp;quot;harry&amp;quot;);add(&amp;quot;tony&amp;quot;);
    }
});
//外层括号建立了ArrayList的一个匿名子类，内层括号则是对象构造块。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;集合&#34;&gt;集合&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;类所有方法都是同步的,可以由两个线程安全地访问一个Vector对象，但由一个线程访问Vector代码要在同步操作上耗费大量的时间。
而&lt;code&gt;ArrayList&lt;/code&gt;方法不是同步的。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt;：
java中所有链表都是双向链表——即每个结点还存放着指向前驱结点的引用。
&lt;code&gt;LinkedList.add()&lt;/code&gt;方法将对象添加到链表尾部。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;List&amp;lt;String&amp;gt; staff = new LinkedList&amp;lt;&amp;gt;();
staff.add(&amp;quot;Amy&amp;quot;);
staff.add(&amp;quot;Bob&amp;quot;);
staff.add(&amp;quot;Carl&amp;quot;);
Iterator iter = staff.iterator();
String first = iter.next(); //访问第一个元素
String second = iter.next(); //访问第二个元素
iter.remove(); //删除最后访问的元素
/*
iter.remove(); //错误
iter.next();
iter.remove(); //正确
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Iterator&lt;/code&gt;还提供&lt;code&gt;ListIterator&lt;/code&gt;子接口，有两个方法：&lt;code&gt;previous()&lt;/code&gt;和&lt;code&gt;hasPrevious()&lt;/code&gt;，可以用来反向遍历链表。
&lt;code&gt;Add()&lt;/code&gt;方法再迭代器位置之前添加一个新对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//越过第一个元素，并在第二个元素之前添加“Juliet”
List&amp;lt;String&amp;gt; staff = new LinkedList&amp;lt;&amp;gt;();
staff.add(&amp;quot;Amy&amp;quot;);
staff.add(&amp;quot;Bob&amp;quot;);
staff.add(&amp;quot;Carl&amp;quot;);
ListIterator iter = staff.listIterator();
iter.next(); //越过链表第一个元素
iter.add(&amp;quot;Juliet&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;散列表用链表数组实现，每个列表被称为桶(bucket)。
散列表中对象的位置索引 = 散列码 % 桶的总数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Set&lt;/code&gt;是没有重复元素的元素集合。
由于散列将元素分散在表的各个位置上，所以访问它们的顺序是几乎随机的。
&lt;code&gt;HashSet&lt;/code&gt;的元素顺序是无序的。
&lt;code&gt;TreeSet&lt;/code&gt;是有序集合，排序由树结构（红黑树）完成。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;PriorityQueue（优先级队列）&lt;/code&gt;中的元素可按照任意顺序插入，却总是按照排序的顺序进行索引，并没有对所有元素进行排序。
其采用的数据结构称之为&lt;code&gt;堆&lt;/code&gt;，是一个可以自我调整的二叉树，对树进行添加和删除操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。
其迭代与&lt;code&gt;TreeSet&lt;/code&gt;的迭代不同，并不是按照元素的排列顺序访问，而删除总是删掉剩余元素中优先级数最小的那个元素。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;两个集的交集&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;Set&amp;lt;String&amp;gt; result = new HashSet&amp;lt;&amp;gt;(a);
result.retainAll(b);
//保留了在a中出现并且也在b中出现的元素。
//removeAll()同理。
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;线程&#34;&gt;线程&lt;/h1&gt;

&lt;p&gt;线程的六种状态：
* New（新创建）
* Runnable（可运行）
* Blocked（被阻塞）
* Waiting（等待）
* Timed waiting（计时等待）
* Terminated（被终止）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;线程优先级&lt;/code&gt;：优先级为MIN_PRIORITY(1)与MAX_PRIORITY(10)之间的任何值，NORM_PRIORITY被定义为5。
每当调度器决定运行一个新线程时，首先会在具有高优先级的线程中选择。如果有几个高优先级的线程没有进入非活动状态，低优先级的线程可能永远也不能执行。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;守护线程&lt;/code&gt;：守护线程的唯一用途是为其他线程提供服务，如计时线程。当只剩下守护线程时，虚拟机就退出了，由于如果只剩下守护线程，就没有必要继续运行程序了。&lt;/p&gt;

&lt;p&gt;一个线程执行一个任务的简单过程：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//Runnable接口
public interface Runnable{
    void run();
}
//实现线程类
class MyRunnable implements Runnable{
    public void run(){
        //code
    }
}
//创建线程类对象
Runnable r = new MyRunnable();
//由Runnable创建Thread对象
Thread t = new Thread(r);
//启动线程
t.start();
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;参考：
&lt;a href=&#34;https://github.com/CyC2018/Interview-Notebook&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Interview-Notebook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>二叉树总结及代码实现</title>
      <link>https://boseman1024.github.io/2018/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 27 May 2018 11:31:26 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid>
      <description>

&lt;h1 id=&#34;二叉树&#34;&gt;二叉树&lt;/h1&gt;

&lt;h3 id=&#34;完全二叉树&#34;&gt;完全二叉树：&lt;/h3&gt;

&lt;p&gt;每层右结点&amp;lt;=左结点&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://naeiag.bn.files.1drv.com/y4mw24pldelRnvMbpEKYgSuThzrUU7DnlcMeW7GfIjhuxY4sYwWYChAa4i2do0cR7V4IligQSyfnwJAsMkuSG2TzmlJ2MaZb00G05LHzmKjFL-MEk2eVzwWSpo_2Phel1AuRp9oICC9vIXtCBL5JXOvMYuox05WgYdCkRDV5iFl89l6hf8Njq70sa0bjZc8ylg5jVSRsO-UXrX1W4Bzdiv-gg/BinaryTree1.jpg&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;性质1&#34;&gt;性质1：&lt;/h3&gt;

&lt;p&gt;在二叉树的第&lt;code&gt;i&lt;/code&gt;层上至多有&lt;code&gt;2^(i-1)&lt;/code&gt;个结点（i&amp;gt;=1）。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;　　　层数i　　　&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;　　　每层最多结点数　　　&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^0=1&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^1=2&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^2=4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2^3=8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;性质2&#34;&gt;性质2：&lt;/h3&gt;

&lt;p&gt;深度为&lt;code&gt;k&lt;/code&gt;的二叉树至多有&lt;code&gt;2^k-1&lt;/code&gt;个结点。&lt;/p&gt;

&lt;p&gt;例：
深度&lt;code&gt;k=4&lt;/code&gt;时，由&lt;code&gt;2^k-1&lt;/code&gt;可得最大结点数为15=1+2+4+8。&lt;/p&gt;

&lt;h3 id=&#34;性质3&#34;&gt;性质3：&lt;/h3&gt;

&lt;p&gt;设：
* 度为0的结点个数为&lt;code&gt;n0&lt;/code&gt;
* 度为1的结点个数为&lt;code&gt;n1&lt;/code&gt;
* 度为2的结点个数为&lt;code&gt;n2&lt;/code&gt;
* 总共有多少结点为&lt;code&gt;N&lt;/code&gt;
* 二叉树分支总数为&lt;code&gt;B&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;则
&lt;code&gt;N&lt;/code&gt; = n0+n1+n2
&lt;code&gt;B&lt;/code&gt; = 2*n2+n2 （2*(A+B+C)+D）
&lt;code&gt;N&lt;/code&gt; = B+1&lt;/p&gt;

&lt;h3 id=&#34;性质4&#34;&gt;性质4：&lt;/h3&gt;

&lt;p&gt;具有n个结点的完全二叉树的深度为&lt;code&gt;[log2(n)]+1&lt;/code&gt;。
&lt;code&gt;[x]&lt;/code&gt;：不大于x的整数。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jweiag.bn.files.1drv.com/y4m_xyrWm6j7eraiwTfU1QqXQcB4gA7F-dKpNjLZlyJWr7euyekAMlMwl5WlJBpcVmJ0zA-eelIrlUVOnZMQnp4pKnAYRF3CWvKO3o8A5aXd1ro6UXdb1OqMv3aZ_4BENHue9Vgr3haZgn39gAIWXuOT_hDMxWleB-BbzHXDNGEo2o_PnQ8DexgET6woluyDOumdXGkyQe4sCdSfQJ_-DckBQ/BinaryTree2.jpg&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;性质5&#34;&gt;性质5：&lt;/h3&gt;

&lt;p&gt;设总结点数为n，结点从左往右，从上到下编号i。
* 若&lt;code&gt;i=1&lt;/code&gt;，则i结点是二叉树的根；若&lt;code&gt;i&amp;gt;1&lt;/code&gt;，则i的父结点为&lt;code&gt;[i/2]&lt;/code&gt;。
* 若&lt;code&gt;2\*i&amp;gt;n&lt;/code&gt;，则结点i无左结点；否则其左结点为&lt;code&gt;2\*i&lt;/code&gt;。
* 若&lt;code&gt;2\*i+1&amp;gt;n&lt;/code&gt;，则结点i无右结点；否则右结点为&lt;code&gt;2\*i+1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[x]&lt;/code&gt;：不大于x的整数。&lt;/p&gt;

&lt;h3 id=&#34;二叉树创建&#34;&gt;二叉树创建&lt;/h3&gt;

&lt;p&gt;根据先序遍历创建二叉树：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef struct BiTnode{
    char data;
    struct BiTnode *lchild;
    struct BiTnode *rchild;
}BiTNode,* BiTree;

void createBiTree(BiTree *T){
    char ch;
    scanf(&amp;quot;%c&amp;quot;,&amp;amp;ch);
    if(ch == &#39; &#39;){
        *T = NULL;
    }else{
        *T=(BiTNode *)malloc(sizeof(BiTNode));
        (*T)-&amp;gt;data= ch;
        createBiTree(&amp;amp;(*T)-&amp;gt;lchild);
        createBiTree(&amp;amp;(*T)-&amp;gt;rchild);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;遍历&#34;&gt;遍历&lt;/h2&gt;

&lt;h3 id=&#34;先序遍历&#34;&gt;先序遍历&lt;/h3&gt;

&lt;p&gt;访问根节点-&amp;gt;遍历左子树-&amp;gt;遍历右子树&lt;/p&gt;

&lt;h3 id=&#34;中序遍历&#34;&gt;中序遍历&lt;/h3&gt;

&lt;p&gt;遍历左子树-&amp;gt;访问根节点-&amp;gt;遍历右子树&lt;/p&gt;

&lt;h3 id=&#34;后序遍历&#34;&gt;后序遍历&lt;/h3&gt;

&lt;p&gt;遍历左子树-&amp;gt;遍历右子树-&amp;gt;访问根节点&lt;/p&gt;

&lt;p&gt;例：（ABC  DE G  F   ）
&lt;img src=&#34;https://jgeiag.bn.files.1drv.com/y4moFzuiwte-ELTa5X12es438n1NnIddzc_IlqOPrLH5ikweTCv53I74P1IsT3MoAQLOZ-DrO2Vzrhsqpi_mkcS9ho-OLFf_8jTjzM7jd_AfYyVPHbfbRE4UbpR4MVAQVrVVou3SoaxBSddKGPbhj72mOA7kxQB27tDV6kW6fDRLRhp8oPo2514GdIBxlv88fCBFJkv7Xrj0ZZTgtM0uxC5uQ/BinaryTree3.png&#34;&gt;
先序：ABCDEGF
中序：CBEGDFA
后序：CGEFDBA&lt;/p&gt;

&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;递归方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void preOrderTraverse(BiTree T){
    if(T){
        printf(&amp;quot;%c&amp;quot;,T-&amp;gt;data);
        preOrderTraverse(T-&amp;gt;lchild);
        preOrderTraverse(T-&amp;gt;rchild);
    }
}
void inOrderTraverse(BiTree T){
    if(T){
        inOrderTraverse(T-&amp;gt;lchild);
        printf(&amp;quot;%c&amp;quot;,T-&amp;gt;data);
        inOrderTraverse(T-&amp;gt;rchild);
    }
}
void postOrderTraverse(BiTree T){
    if(T){
        postOrderTraverse(T-&amp;gt;lchild);
        postOrderTraverse(T-&amp;gt;rchild);
        printf(&amp;quot;%c&amp;quot;,T-&amp;gt;data);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;非递归方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public void preOrderTraversal(TreeNode root) {
    Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
    stack.push(root);
    TreeNode node;
    while(!stack.empty()){
        node = stack.pop();
        if(node!=null){
            System.out.println(node.val);
            stack.push(node.right);
            stack.push(node.left);
        }
    }
}
public void inOrderTraversal(TreeNode root) {
    Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
    TreeNode node=root;
    while(node!=null||!stack.empty()){
        //所有左节点压入栈
        while(node!=null){
            stack.push(node);
            node = node.left;
        }
        if(!stack.empty()){
            node = stack.pop();
            System.out.println(node.val);
            //若有右右结点，将其压入栈
            node = node.right;
        }
    }
}
public void postOrderTraversal(TreeNode root) {
    Stack&amp;lt;TreeNode&amp;gt; stack = new Stack&amp;lt;TreeNode&amp;gt;();
    TreeNode node = root;
    TreeNode pre = null;
    while(node!=null||!stack.isEmpty()) {
        while(node!=null) {
            //将所有左节点压入栈
            stack.push(node);
            node = node.left;
        }
        if(!stack.isEmpty()){
            node = stack.pop();
            //若无右结点或右结点已被访问
            if(node.right==null||node.right==pre){
                //打印该节点
                System.out.println(node.val);
                //标记该已访问节点
                pre = node;
                node = null;
            }else{
                //将当前结点压入栈
                stack.push(node);
                node = node.right;
                //将当前节点的右结点压入栈
                stack.push(node);
                //访问当前节点的左节点
                node = node.left;
            }
        }
    }
}
//层级遍历
public void levelTraversal(TreeNode root) {
    Queue&amp;lt;TreeNode&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();
    queue.offer(root);
    while(!queue.isEmpty()){
        TreeNode node = queue.poll();
        System.out.println(node.val);
        if(node.left!=null){
            queue.offer(node.left);
        }
        if(node.right!=null){
            queue.offer(node.right);
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;森林&#34;&gt;森林&lt;/h1&gt;

&lt;h2 id=&#34;森林与二叉树的转换&#34;&gt;森林与二叉树的转换&lt;/h2&gt;

&lt;p&gt;例1：
&lt;img src=&#34;https://kweiag.bn.files.1drv.com/y4mBFC_TaX4ozCYYptF6uNtbtmAIJrB5GodlPsqTRABNaIfl-fmn90rjCm2E1ePBUeGF0emxn9VWFGBPkUXvxu_fz_VnnrA-VqJpNdJlk_4pprN--QGntUi2d1D9EfNHXzVwRvn2u0qh3j_vEU9Hk7CjNbkFt_lHTJBXS6NA7RH4qV2UYG6sY5XrkKtu6VGFyWGrSHMD0k6N3DAvFGliRmj_Q/tree2Binary1.png&#34;&gt;&lt;/p&gt;

&lt;p&gt;例2：
&lt;img src=&#34;https://kgeiag.bn.files.1drv.com/y4mFs5cHMf46GgmNsST0z1Dbn1PyHq-8h0Z5SRXrJe29OPLk81kzq1kVpcwlZudXNoImoFt1m9XW9yBpo2zdUGnPZEwXMacx1cqhfKqfazMqRsYLKY3paO6AxPr4LAaR2VdqZv1T0PthTsD39Ov8adgKNCpqlQ9YsbEJ_LmeUcm2QRHcqXZQ1UHOGMAGIvBRXrHQcAYi5syIQNoZwl5AsCheQ/tree2Binary2.png&#34;&gt;&lt;/p&gt;

&lt;h1 id=&#34;哈夫曼树&#34;&gt;哈夫曼树&lt;/h1&gt;

&lt;h3 id=&#34;定义&#34;&gt;定义：&lt;/h3&gt;

&lt;p&gt;带权路径长度WPL最小的二叉树称作最优二叉树或哈夫曼树。
例：
&lt;img src=&#34;https://kqeiag.bn.files.1drv.com/y4mjJ3jLSKJCuFnSwKp3hphJ_TlZlZOurEwkMLNaWZzwQiSoy4vfnHSRgFyCTBSShdrColdtdKyfpqZz26MPbZpZgzpFzgCAv5cCZS8wyf38C5YMLQUsKXt78Of-auspj_Fx800dwk1HGokozrZIypQ3cvtZELYqhSbJY31Hrym5IGsae4Tw2fdYvVNF2nYbZhcieiXMinibPanukl-Vnw0qg/huffman.png&#34;&gt;
(1)WPL=7*1+5*2+2*3+4*3=35
(2)WPL=7*2+5*2+2*2+4*2=36
则(1)为哈夫曼树。&lt;/p&gt;

&lt;h3 id=&#34;构造&#34;&gt;构造：&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://nqeiag.bn.files.1drv.com/y4mtY-hgF-E3b4LfCp8kGsWr6tHpDgkr77CYQqRql2VAYKIHxwlM6bG2BJ_RlVujCTRueBZKFa-LsyDor5p09hr2C9WUdCBAd_XR5XGiuOs7LFEs0d_Sul3gVK_LnirrKN6Wc_afQSAIMqQFg53IEByRISmaMsJeS5fpwHnVq3tiHGTrhM6PXlsYNqQE5WDPjFzT0d-Y1xzHnz9cGAf-PECeg/2huffman.png&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;哈夫曼编码&#34;&gt;哈夫曼编码：&lt;/h3&gt;

&lt;p&gt;左结点为0，右结点为1。&lt;/p&gt;

&lt;p&gt;例：
&lt;img src=&#34;https://kaeiag.bn.files.1drv.com/y4mTadIjaGMzRebBMob-kf3ecmDrYRCiqPZiINXzkdH5iuhTyM2k_Vq8F7QBvmR5GVyNOLzABDEDazSIvw0Vi88Uk41aATmcVLLHr2PpyyMRHpUuvp7C0fuD2zm3qgbsQxB_IFa9TgRN3GVx-DmR1SqO7ohs_oWHPGdoqmTrmzIzvlRO0npa2qigEuPhkbhwNFA8ZkgnUXQzaUO6KenUWLlvw/hufumancode.png&#34;&gt;
则编码为
* a（0）
* b（10）
* c（110）
* d（111）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>二维数组矩阵转置</title>
      <link>https://boseman1024.github.io/2018/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/</link>
      <pubDate>Tue, 01 May 2018 21:11:44 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/</guid>
      <description>

&lt;h1 id=&#34;对称矩阵&#34;&gt;对称矩阵&lt;/h1&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int symmetricTranslate(){
    printf(&amp;quot;==========对称矩阵=========\n&amp;quot;); 
    int col,row;
    int i,j;
    /**输入对称矩阵行数列数 
    scanf(&amp;quot;%d,%d&amp;quot;,&amp;amp;col,&amp;amp;row);
    int origin[row][col],result[row][col];
    for(i=0;i&amp;lt;col;i++){
        for(j=0;j&amp;lt;row;j++){
            printf(&amp;quot;列：%d,行：%d输入值&amp;quot;,col,row);
            scanf(&amp;quot;%d&amp;quot;,&amp;amp;value);
            origin[i][j] = value;
        }
    }
    **/ 
    //测试对称矩阵 
    col = 5;
    row = 5;
    int origin[5][5]={
        1,5,1,3,7,
        3,0,8,0,0,
        1,4,9,2,6,
        3,0,5,5,1,
        9,0,1,2,3
    };
    //int result[row][col];
    int result[5][5];
    for(i=0;i&amp;lt;row;i++){
        for(j=0;j&amp;lt;col;j++){
            printf(&amp;quot;%d &amp;quot;,origin[i][j]);
        }
        printf(&amp;quot;\n&amp;quot;);
    }
    printf(&amp;quot;==========对称矩阵转置=========\n&amp;quot;); 
    for(i=0;i&amp;lt;row;i++){
        for(j=0;j&amp;lt;col;j++){
            result[j][i] = origin[i][j];
        }
    }
    for(i=0;i&amp;lt;row;i++){
        for(j=0;j&amp;lt;col;j++){
            printf(&amp;quot;%d &amp;quot;,result[i][j]);
        }
        printf(&amp;quot;\n&amp;quot;);
    }
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;稀疏矩阵&#34;&gt;稀疏矩阵&lt;/h1&gt;

&lt;p&gt;矩阵数组构成：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;typedef struct{
    int row,col;
    int value;
}Element;
typedef struct{
    Element data[MAXSIZE+1];
    int rowNum,colNum,notZeroNum;
}EleArray;

//-----------------------

EleArray eleArray,result;
int row = 0,col = 0,notZeroNum = 0,value;
//测试数组：6行7列 
row = 6;
col = 7;
int box[6][7]={
    0,12,9,0,0,0,0,
    0,0,0,0,0,0,0,
    -3,0,0,0,0,14,0,
    0,0,24,0,0,0,0,
    0,18,0,0,0,0,0,
    15,0,0,-7,0,0,0
};
//printf(&amp;quot;输入稀疏矩阵行数，列数\n&amp;quot;);
//scanf(&amp;quot;%d,%d&amp;quot;,&amp;amp;row,&amp;amp;col);
eleArray.rowNum = row;
eleArray.colNum = col;  
int i,j;
for(i=0;i&amp;lt;row;i++){
    for(j=0;j&amp;lt;col;j++){
        //printf(&amp;quot;行：%d，列：%d，请输入数值：\n&amp;quot;,i,j);
        //scanf(&amp;quot;%d&amp;quot;,&amp;amp;value);
        value=box[i][j]; 
        if(value!=0){
            eleArray.data[notZeroNum].row = i;
            eleArray.data[notZeroNum].col = j;
            eleArray.data[notZeroNum].value = value;
            notZeroNum++;
        }
    }
}
eleArray.notZeroNum = notZeroNum;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;普通转置法&#34;&gt;普通转置法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int translate(EleArray *eleArray,EleArray *result){
    result-&amp;gt;rowNum = eleArray-&amp;gt;colNum;
    result-&amp;gt;colNum = eleArray-&amp;gt;rowNum;
    result-&amp;gt;notZeroNum = eleArray-&amp;gt;notZeroNum;
    int n;
    if(eleArray-&amp;gt;notZeroNum){
        int index=0;//转置后数组个数
        int col,notZeroIndex;//列数，非零序列 
        for(col=0;col&amp;lt;=eleArray-&amp;gt;colNum;col++){
            for(notZeroIndex=0;notZeroIndex&amp;lt;eleArray-&amp;gt;notZeroNum;notZeroIndex++){
                if(eleArray-&amp;gt;data[notZeroIndex].col==col){
                    result-&amp;gt;data[index].row = eleArray-&amp;gt;data[notZeroIndex].col;
                    result-&amp;gt;data[index].col = eleArray-&amp;gt;data[notZeroIndex].row;
                    result-&amp;gt;data[index].value = eleArray-&amp;gt;data[notZeroIndex].value;
                    index++;
                }
            }
        }
    }
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;快速转置法&#34;&gt;快速转置法&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-C&#34;&gt;int fastTranslate(EleArray *eleArray,EleArray *result){
    printf(&amp;quot;===========快速转置=========\n&amp;quot;);
    result-&amp;gt;rowNum = eleArray-&amp;gt;colNum;
    result-&amp;gt;colNum = eleArray-&amp;gt;rowNum;
    result-&amp;gt;notZeroNum = eleArray-&amp;gt;notZeroNum;
    if(eleArray-&amp;gt;notZeroNum){
        int num[eleArray-&amp;gt;colNum],cpot[eleArray-&amp;gt;colNum],col;
        for(col=0;col&amp;lt;eleArray-&amp;gt;colNum;col++){
            num[col]=0;
        }
        for(col=0;col&amp;lt;eleArray-&amp;gt;notZeroNum;col++){
            num[eleArray-&amp;gt;data[col].col]++;
        }
        cpot[0]=0;
        for(col=1;col&amp;lt;eleArray-&amp;gt;colNum;col++){
            cpot[col] = cpot[col-1]+num[col-1];
        }
        int index=0,notZeroIndex;
        for(notZeroIndex=0;notZeroIndex&amp;lt;eleArray-&amp;gt;notZeroNum;notZeroIndex++){
            col = eleArray-&amp;gt;data[notZeroIndex].col;
            index = cpot[col];
            result-&amp;gt;data[index].row = eleArray-&amp;gt;data[notZeroIndex].col;
            result-&amp;gt;data[index].col = eleArray-&amp;gt;data[notZeroIndex].row;
            result-&amp;gt;data[index].value = eleArray-&amp;gt;data[notZeroIndex].value;
            cpot[col]++;
            index++;
        }
    }
    return 1;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Mybatis：一对多关联查询及批量插入（注解方式）</title>
      <link>https://boseman1024.github.io/2018/mybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%8F%8A%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 01 May 2018 20:50:27 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/mybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%8F%8A%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/</guid>
      <description>

&lt;h1 id=&#34;一对多关联查询&#34;&gt;一对多关联查询&lt;/h1&gt;

&lt;p&gt;通过&lt;code&gt;@Results&lt;/code&gt;构造结果映射：
* &lt;code&gt;javaType&lt;/code&gt;：返回类型
* &lt;code&gt;property&lt;/code&gt;：指定属性
* &lt;code&gt;column&lt;/code&gt;：将作为指定参数传递给指定方法（即例中&lt;code&gt;selectMenuByRid&lt;/code&gt;方法）&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//角色mapper
public interface SysRoleMapper {
    @Select(&amp;quot;select * from sys_role&amp;quot;)
    @Results({
        @Result(property=&amp;quot;name&amp;quot;,column=&amp;quot;name&amp;quot;),
        @Result(property=&amp;quot;namezh&amp;quot;,column=&amp;quot;namezh&amp;quot;),
        @Result(property=&amp;quot;menus&amp;quot;,column=&amp;quot;id&amp;quot;,javaType=List.class,many=@Many(select=&amp;quot;com.kuma2x.xauth.mapper.SysMenuMapper.selectMenuByRid&amp;quot;))
    })
    List&amp;lt;SysRole&amp;gt; selectRoleByUId(int uid);
}

//菜单mapper
public interface SysMenuMapper {
    //通过角色id在角色菜单关联表中查询到该角色所拥有菜单权限
    @Select(&amp;quot;select * from sys_menu,sys_role_menu where sys_menu.id = sys_role_menu.mid and sys_role_menu.rid = #{rid}&amp;quot;)
    List&amp;lt;Integer&amp;gt; selectMenuByRid(int rid);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;批量插入&#34;&gt;批量插入&lt;/h1&gt;

&lt;p&gt;使用&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签可像XML语法一样书写。
通过&lt;code&gt;&amp;lt;foreach&amp;gt;&lt;/code&gt;迭代集合进行插入，注解中参数需通过&lt;code&gt;@Param&lt;/code&gt;指定参数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;foreach&lt;/code&gt;标签的属性主要有：
* &lt;code&gt;item&lt;/code&gt;：迭代时集合中每个元素的别名。
* &lt;code&gt;index&lt;/code&gt;：每个元素在集合中迭代序列。
* &lt;code&gt;collection&lt;/code&gt;：指定集合。
* &lt;code&gt;open&lt;/code&gt;：该语句的开始符。
* &lt;code&gt;separator&lt;/code&gt;：每次迭代的分隔符。
* &lt;code&gt;close&lt;/code&gt;：该语句的结束符。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&amp;lt;foreach collection=&amp;quot;list&amp;quot; index=&amp;quot;index&amp;quot; item=&amp;quot;item&amp;quot; open=&amp;quot;(&amp;quot; separator=&amp;quot;,&amp;quot; close=&amp;quot;)&amp;quot;&amp;gt;
    #{item}
&amp;lt;/foreach&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完整示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//向角色权限关联表中插入该角色所拥有的所有菜单权限
@Insert({
    &amp;quot;&amp;lt;script&amp;gt;&amp;quot;+
    &amp;quot;insert into sys_role_menu(rid,mid) values&amp;quot; +
    &amp;quot;&amp;lt;foreach collection=&#39;menus&#39; item=&#39;mid&#39; separator=&#39;,&#39;&amp;gt; &amp;quot;+
        &amp;quot;(#{id},#{mid})&amp;quot;+
    &amp;quot;&amp;lt;/foreach&amp;gt;&amp;lt;/script&amp;gt;&amp;quot;
})
int insertRoleMenu(@Param(&amp;quot;id&amp;quot;)int id,@Param(&amp;quot;menus&amp;quot;) List&amp;lt;Integer&amp;gt; menus);
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>