<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on KUMA2X</title>
    <link>https://boseman1024.github.io/posts/</link>
    <description>Recent content in Posts on KUMA2X</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 Nov 2018 20:21:33 +0000</lastBuildDate>
    
	<atom:link href="https://boseman1024.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>杂题</title>
      <link>https://boseman1024.github.io/2018/%E6%9D%82%E9%A2%98/</link>
      <pubDate>Wed, 07 Nov 2018 20:21:33 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E6%9D%82%E9%A2%98/</guid>
      <description>题目：
题目：
1000 瓶无色无味的药水，其中有一瓶毒药，10只小白鼠拿过来做实验。喝了无毒的药水第二天没事儿，喝了有毒的药水后第二天会死亡。如何在一天之内(第二天)找出这瓶有毒的药水？
解：
1000个瓶子可以用10位二进制数表示(0-1023)
那么10个老鼠可以分别代表一个二进制位
也就是说是为了找到这个10位二进制数每一位是0或者是1
为了方便我还是假设有1024个瓶子吧
老鼠1-10分别从低位到高位编码，那么：
老鼠01：选择第1, 3, 5&amp;hellip;1023瓶共512瓶药混在一块，给它喝
老鼠02：选择第1-2, 5-6, 9-10&amp;hellip;1021-1022瓶共512瓶药混在一块，给它喝
老鼠03：选择第1-4, 9-12, 17-20&amp;hellip;1017-1020瓶共512瓶药混在一块，给它喝
&amp;hellip;
老鼠10：选择第1-512瓶共512瓶药混在一块，给它喝
这样第二天10个老鼠有些会死，有些不会死，死代表1，活代表0，这样把10个老鼠排在一块就能有一个二进制数，就是毒药的序号</description>
    </item>
    
    <item>
      <title>Top Interview Questions-Medium-①</title>
      <link>https://boseman1024.github.io/2018/top-interview-questions-medium-1/</link>
      <pubDate>Sat, 29 Sep 2018 22:59:34 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/top-interview-questions-medium-1/</guid>
      <description>Design Insert Delete GetRandom O(1) 设计数据结构实现时间复杂度为O(1)的插入、删除、获取随机数 Design a data structure that supports all following operations in average O(1) time.
 insert(val): Inserts an item val to the set if not already present.
 remove(val): Removes an item val from the set if present.
 getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
  Example:
 // Init an empty set.</description>
    </item>
    
    <item>
      <title>Top Interview Questions-Easy-①</title>
      <link>https://boseman1024.github.io/2018/top-interview-questions-easy-1/</link>
      <pubDate>Fri, 28 Sep 2018 21:47:14 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/top-interview-questions-easy-1/</guid>
      <description>Design Shuffle an Array 打乱数组 Shuffle a set of numbers without duplicates.
Example:
 // Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);
// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();
// Resets the array back to its original configuration [1,2,3].
solution.reset();
// Returns the random shuffling of array [1,2,3].</description>
    </item>
    
    <item>
      <title>Top Interview Questions-Easy-②</title>
      <link>https://boseman1024.github.io/2018/top-interview-questions-easy-2/</link>
      <pubDate>Thu, 27 Sep 2018 15:08:22 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/top-interview-questions-easy-2/</guid>
      <description>Dynamic Programming Climbing Stairs 爬楼梯，实质为斐波那契数列 You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
 Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
 1 step + 1 step</description>
    </item>
    
    <item>
      <title>排序算法整理</title>
      <link>https://boseman1024.github.io/2018/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</link>
      <pubDate>Thu, 14 Jun 2018 13:56:22 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</guid>
      <description>冒泡排序 public static void Bubble(int num[]) { for(int i=0;i&amp;lt;num.length-1;i++) { for(int j=0;j&amp;lt;num.length-i-1;j++) { if(num[j]&amp;gt;num[j+1]) { int temp = num[j+1]; num[j+1] = num[j]; num[j] = temp; } } } }  选择排序 public static void Selection(int num[]) { for(int i=0;i&amp;lt;num.length;i++) { //最小元素的下标 int min = i; //找出最小元素 for(int j=i;j&amp;lt;num.length;j++) { if(num[j]&amp;lt;num[min]) { min = j; } } //交换元素 int temp = num[i]; num[i] = num[min]; num[min] = temp; } show(num); }  插入排序 直接插入排序 public static void StraightInsert(int num[]) { for(int i=1;i&amp;lt;num.</description>
    </item>
    
    <item>
      <title>JAVA虚拟机笔记</title>
      <link>https://boseman1024.github.io/2018/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 07 Jun 2018 20:40:26 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0/</guid>
      <description>JAVA内存区域 程序计数器 *程序计数器（Program Counter Register）*是当前线程所执行的字节码的行号指示器，通过计数器的值选取下一条需要执行的字节码指令（java方法）。 可参考《计算机系统组成》 每个线程都需要一个独立的程序计数器，各线程间计数器互不影响，独立储存，称之为“线程私有”的内存。
JAVA虚拟机栈 *JAVA虚拟机栈（Java Virtual Machine Stacks）*描述的是JAVA方法执行的内存模型：每个方法执行的同时会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈出栈的过程。 同时其也是线程私有，生命周期与线程相同。 其中局部变量表，存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用类型（reference类型，可能是指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型数据占用2个局部变量空间（slot），其余只占用1个。 局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，需要在帧中分配多大的局部变量空间时完全确定的，在方法执行期间不会改变局部变量表大小。
本地方法栈 *本地方法栈（Native Method Stack）*于虚拟机栈相似，但其为虚拟机使用到的Native方法服务。在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java虚拟机栈合二为一。
JAVA堆 *JAVA堆（JAVA Heap）*被所有线程共享的一块内存区域，在虚拟机启动时创建，被用于存放对象实例，是垃圾收集器管理的主要区域。
方法区 *方法区（Method Area）*与Java堆一样，是各个线程共享的内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。被称为永久代，垃圾回收行为在该区域是相对较少出现的。 *运行常量池（Runtime Constant Pool）*是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用。
直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是JAVA虚拟机规范中定义的内存区域。但这部分也被频繁使用，也可能导致OutOfMemoryError异常出现。直接内存的分配不受JAVA堆大小的限制，但是还是会受到本机总内存大小以及处理器寻址空间的限制。
对象的访问定位 使用句柄 JAVA堆中会划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含对象实例数据和类型数据各自的具体地址信息。 优点：稳定，对象被移动只会改变句柄中实例数据指针，而reference本身不需要修改。 直接指针 reference中存储的直接就是对象地址。 优点：速度更快，节省一次指针定位的时间开销。 垃圾收集器与内存分配策略 引用计数算法 判断对象是否存活的算法： 给对象添加一个引用计数器，每当有一个地方引用它，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就不可能再被使用。
但JAVA虚拟机中并未采用该算法来管理内存。 例：对象A和B都有字段instance，赋值令A.instance=B及B.instance=A，除此之外两个对象无任何引用，实际上两个对象已经不可能再被访问，但因为互相引用着对方，导致引用计数都不为0，引用计数算法无法通知GC收集器回收。但执行System.gc()时，A、B将被正常回收，说明虚拟机并未采用引用计数算法。
可达性分析算法 通过GC Roots对象作为起始点，向下搜索节点，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链项链时，证明此对象不可用。 如下图，obj5、obj6、obj7虽然互相关联，但到GC Roots不可达，所以将被判定为可回收对象。 JAVA中可作为GC Roots的对象包括以下几种： * 虚拟机栈（栈帧中的本地变量表）中引用的对象 * 方法区中类静态属性引用的对象 * 方法区中常量引用的对象 * 本地方法栈中Native方法引用的对象
引用强度 强引用 类似“Object obj = new Object()”这类的引用，只要强引用在，垃圾收集器永远不会回收掉被引用的对象。
软引用 有用但并非必需的对象。系统将要发生内存溢出异常之前，这些对象将被列入回收范围进行第二次回收。如果这次回收没有足够内存，才会抛出内存溢出异常。提供SoftReference类实现软引用。</description>
    </item>
    
    <item>
      <title>图总结及代码实现</title>
      <link>https://boseman1024.github.io/2018/%E5%9B%BE%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Thu, 07 Jun 2018 11:31:26 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E5%9B%BE%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid>
      <description>图 数组表示法 无向图 数组矩阵表示如下： 010101101000010101101011000101101110
有向图 数组矩阵表示如下： ∞5∞7∞∞∞∞4∞∞∞∞∞∞∞∞9∞∞5∞∞6∞∞∞5∞∞3∞∞∞1∞
图的遍历 深度优先搜索 其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 深度优先搜索的遍历访问顺序并不唯一。
假设以V1为起点， V1有两个邻接点V2与V3且都未被访问，则访问V2（或访问v3开始皆可，以下皆如此）； V2有三个邻接点V1、V4、V5，V1已被访问，V4与V5都未被访问，则访问V4； V4有两个邻接点V2与V8，只有V8未被访问，则访问V8； V8有两个邻接点V4与V5，V4已被访问，则访问V5； V5有两个邻接点V2与V8，且V2、V8都已被访问，则从头搜索V1的邻接点V2、V3，V2已被访问，则访问V3； V3有三个邻接点V1、V6、V7且未被访问，则访问V6； V6有两个邻接点V3与V7，V3已被访问，则访问V7。
则以V1为起点的深度优先搜索访问顺序为： V1-&amp;gt;V2-&amp;gt;V4-&amp;gt;V8-&amp;gt;V5-&amp;gt;V3-&amp;gt;V6-&amp;gt;V7
public void dfs(int[][] grid,int i,int j,int rows,int cols){ if(i&amp;lt;0||j&amp;lt;0||i&amp;gt;=rows||j&amp;gt;=cols||grid[i][j]==-1){return;} System.out.println(grid[i][j]); //标记已访问点 grid[i][j]=-1; dfs(grid,i,j+1,rows,cols); dfs(grid,i,j-1,rows,cols); dfs(grid,i+1,j,rows,cols); dfs(grid,i-1,j,rows,cols); }  广度优先搜索 类似于树的按层次遍历的过程，可先将图按层划分。 广度优先搜索的遍历访问顺序并不唯一。
假设以V1为起点，则可划分为下图： 第一层（V1）： V1有两个邻接点V2、V3，则先访问V2，再访问V3（或先访问V3，再访问V2皆可，以下皆如此）； 第二层(V2、V3)： V2有三个邻接点V1、V4、V5，V1已被访问，则访问V4、V5； V3有两个邻接点V6、V7且都未被访问，则访问V6、V7； 第三层（V4、V5、V6、V7）： V4有两个邻接点V2与V8，V2已被访问，则访问V8。
则以V1为起点的广度优先搜索访问顺序为： V1-&amp;gt;V2-&amp;gt;V3-&amp;gt;V4-&amp;gt;V5-&amp;gt;V6-&amp;gt;V7-&amp;gt;V8
最小生成树 在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 最小生成树中不存在回路。
可得数组矩阵： ∞615∞∞6∞5∞3∞15∞5645∞5∞∞2∞36∞∞6∞∞426∞
普里姆（Prim）算法 此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。
设： * 所有结点V={V1,V2,V3,V4,V5,V6} * 已选结点U={} * 剩余结点V-U * 代价最小的边MIN</description>
    </item>
    
    <item>
      <title>JAVA基础整理</title>
      <link>https://boseman1024.github.io/2018/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</link>
      <pubDate>Sun, 03 Jun 2018 21:47:14 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/java%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86/</guid>
      <description>八大基本类型： * 字节型（byte）-8位 * 短整型（short）-16位 * 整型（int）-32位 * 长整型（long）-64位 * 字符型（char）-16位 * 浮点型（float）-32位 * 双精度型（double）-64位 * 布尔型（boolean）-1位
基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
Integer x = 2; // 装箱 int y = x; // 拆箱  new Integer(123)与Integer.valueOf(123)的区别在于，new Integer(123)每次都会新建一个对象，而Integer.valueOf(123)可能会使用缓存对象，因此多次使用Integer.valueOf(123)会取得同一个对象的引用。
Integer x = new Integer(123); Integer y = new Integer(123); System.out.println(x == y); // false Integer z = Integer.valueOf(123); Integer k = Integer.valueOf(123); System.out.println(z == k); // true  编译器会在自动装箱过程调用valueOf()方法，因此多个Integer实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。
Integer m = 123; Integer n = 123; System.</description>
    </item>
    
    <item>
      <title>二叉树总结及代码实现</title>
      <link>https://boseman1024.github.io/2018/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Sun, 27 May 2018 11:31:26 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid>
      <description>二叉树 完全二叉树： 每层右结点&amp;lt;=左结点
性质1： 在二叉树的第i层上至多有2^(i-1)个结点（i&amp;gt;=1）。
   层数i　 每层最多结点数　     1 2^0=1   2 2^1=2   3 2^2=4   4 2^3=8    性质2： 深度为k的二叉树至多有2^k-1个结点。
例： 深度k=4时，由2^k-1可得最大结点数为15=1+2+4+8。
性质3： 设： * 度为0的结点个数为n0 * 度为1的结点个数为n1 * 度为2的结点个数为n2 * 总共有多少结点为N * 二叉树分支总数为B
则 N = n0+n1+n2 B = 2*n2+n2 （2*(A+B+C)+D） N = B+1
性质4： 具有n个结点的完全二叉树的深度为[log2(n)]+1。 [x]：不大于x的整数。
性质5： 设总结点数为n，结点从左往右，从上到下编号i。 * 若i=1，则i结点是二叉树的根；若i&amp;gt;1，则i的父结点为[i/2]。 * 若2\*i&amp;gt;n，则结点i无左结点；否则其左结点为2\*i。 * 若2\*i+1&amp;gt;n，则结点i无右结点；否则右结点为2\*i+1。</description>
    </item>
    
    <item>
      <title>二维数组矩阵转置</title>
      <link>https://boseman1024.github.io/2018/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/</link>
      <pubDate>Tue, 01 May 2018 21:11:44 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9F%A9%E9%98%B5%E8%BD%AC%E7%BD%AE/</guid>
      <description>对称矩阵 int symmetricTranslate(){ printf(&amp;quot;==========对称矩阵=========\n&amp;quot;); int col,row; int i,j; /**输入对称矩阵行数列数 scanf(&amp;quot;%d,%d&amp;quot;,&amp;amp;col,&amp;amp;row); int origin[row][col],result[row][col]; for(i=0;i&amp;lt;col;i++){ for(j=0;j&amp;lt;row;j++){ printf(&amp;quot;列：%d,行：%d输入值&amp;quot;,col,row); scanf(&amp;quot;%d&amp;quot;,&amp;amp;value); origin[i][j] = value; } } **/ //测试对称矩阵 col = 5; row = 5; int origin[5][5]={ 1,5,1,3,7, 3,0,8,0,0, 1,4,9,2,6, 3,0,5,5,1, 9,0,1,2,3 }; //int result[row][col]; int result[5][5]; for(i=0;i&amp;lt;row;i++){ for(j=0;j&amp;lt;col;j++){ printf(&amp;quot;%d &amp;quot;,origin[i][j]); } printf(&amp;quot;\n&amp;quot;); } printf(&amp;quot;==========对称矩阵转置=========\n&amp;quot;); for(i=0;i&amp;lt;row;i++){ for(j=0;j&amp;lt;col;j++){ result[j][i] = origin[i][j]; } } for(i=0;i&amp;lt;row;i++){ for(j=0;j&amp;lt;col;j++){ printf(&amp;quot;%d &amp;quot;,result[i][j]); } printf(&amp;quot;\n&amp;quot;); } return 1; }  稀疏矩阵 矩阵数组构成：</description>
    </item>
    
    <item>
      <title>Mybatis：一对多关联查询及批量插入（注解方式）</title>
      <link>https://boseman1024.github.io/2018/mybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%8F%8A%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Tue, 01 May 2018 20:50:27 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/mybatis%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%8F%8A%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/</guid>
      <description>一对多关联查询 通过@Results构造结果映射： * javaType：返回类型 * property：指定属性 * column：将作为指定参数传递给指定方法（即例中selectMenuByRid方法）
例：
//角色mapper public interface SysRoleMapper { @Select(&amp;quot;select * from sys_role&amp;quot;) @Results({ @Result(property=&amp;quot;name&amp;quot;,column=&amp;quot;name&amp;quot;), @Result(property=&amp;quot;namezh&amp;quot;,column=&amp;quot;namezh&amp;quot;), @Result(property=&amp;quot;menus&amp;quot;,column=&amp;quot;id&amp;quot;,javaType=List.class,many=@Many(select=&amp;quot;com.kuma2x.xauth.mapper.SysMenuMapper.selectMenuByRid&amp;quot;)) }) List&amp;lt;SysRole&amp;gt; selectRoleByUId(int uid); } //菜单mapper public interface SysMenuMapper { //通过角色id在角色菜单关联表中查询到该角色所拥有菜单权限 @Select(&amp;quot;select * from sys_menu,sys_role_menu where sys_menu.id = sys_role_menu.mid and sys_role_menu.rid = #{rid}&amp;quot;) List&amp;lt;Integer&amp;gt; selectMenuByRid(int rid); }  批量插入 使用&amp;lt;script&amp;gt;标签可像XML语法一样书写。 通过&amp;lt;foreach&amp;gt;迭代集合进行插入，注解中参数需通过@Param指定参数。
foreach标签的属性主要有： * item：迭代时集合中每个元素的别名。 * index：每个元素在集合中迭代序列。 * collection：指定集合。 * open：该语句的开始符。 * separator：每次迭代的分隔符。 * close：该语句的结束符。
&amp;lt;foreach collection=&amp;quot;list&amp;quot; index=&amp;quot;index&amp;quot; item=&amp;quot;item&amp;quot; open=&amp;quot;(&amp;quot; separator=&amp;quot;,&amp;quot; close=&amp;quot;)&amp;quot;&amp;gt; #{item} &amp;lt;/foreach&amp;gt;  完整示例：</description>
    </item>
    
    <item>
      <title>层级关系数据转树型结构JSON</title>
      <link>https://boseman1024.github.io/2018/%E5%B9%B3%E7%BA%A7json%E8%BD%AC%E5%B1%82%E7%BA%A7%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84json/</link>
      <pubDate>Tue, 01 May 2018 20:08:31 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/%E5%B9%B3%E7%BA%A7json%E8%BD%AC%E5%B1%82%E7%BA%A7%E6%A0%91%E5%9E%8B%E7%BB%93%E6%9E%84json/</guid>
      <description>原始数据结构如下：
[{ &amp;quot;id&amp;quot;: 0, &amp;quot;name&amp;quot;: &amp;quot;home&amp;quot;, &amp;quot;url&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/home&amp;quot;, &amp;quot;component&amp;quot;: &amp;quot;Gate&amp;quot;, &amp;quot;iconcls&amp;quot;: &amp;quot;el-icon-menu&amp;quot; }, { &amp;quot;id&amp;quot;: 1, &amp;quot;name&amp;quot;: &amp;quot;user&amp;quot;, &amp;quot;url&amp;quot;: &amp;quot;0&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;iconcls&amp;quot;: &amp;quot;el-icon-document&amp;quot; }, { &amp;quot;id&amp;quot;: 2, &amp;quot;name&amp;quot;: &amp;quot;User&amp;quot;, &amp;quot;url&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/user/user&amp;quot;, &amp;quot;component&amp;quot;: &amp;quot;user/User&amp;quot;, &amp;quot;parentid&amp;quot;: 1 }, { &amp;quot;id&amp;quot;: 3, &amp;quot;name&amp;quot;: &amp;quot;Role&amp;quot;, &amp;quot;url&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/user/role&amp;quot;, &amp;quot;component&amp;quot;: &amp;quot;user/Role&amp;quot;, &amp;quot;parentid&amp;quot;: 1 }, { &amp;quot;id&amp;quot;: 7, &amp;quot;name&amp;quot;: &amp;quot;Permission&amp;quot;, &amp;quot;url&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/user/permission&amp;quot;, &amp;quot;component&amp;quot;: &amp;quot;user/Permission&amp;quot;, &amp;quot;parentid&amp;quot;: 1 }, { &amp;quot;id&amp;quot;: 8, &amp;quot;name&amp;quot;: &amp;quot;Menu&amp;quot;, &amp;quot;url&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/user/menu&amp;quot;, &amp;quot;component&amp;quot;: &amp;quot;user/Menu&amp;quot;, &amp;quot;parentid&amp;quot;: 1 }]  通过递归的方式转换：</description>
    </item>
    
    <item>
      <title>SpringBoot整合Spring Security&#43;JWT</title>
      <link>https://boseman1024.github.io/2018/springboot%E9%9B%86%E6%88%90spring-security-jwt/</link>
      <pubDate>Mon, 16 Apr 2018 20:40:54 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/springboot%E9%9B%86%E6%88%90spring-security-jwt/</guid>
      <description>DEMO 准备 MAVEN依赖 在pom.xml引入所需依赖如下：
&amp;lt;parent&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.1.RELEASE&amp;lt;/version&amp;gt; &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt; &amp;lt;/parent&amp;gt; &amp;lt;!--SpringBoot--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Spring Security --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.security&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-security-test&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--JWT--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.jsonwebtoken&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;jjwt&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;0.9.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--Mybatis--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--MYSQL--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!--可选：druid连接池--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;druid&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.1.9&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;  基本配置 在application.yml中配置SpringBoot应用， 配置后在项目中可通过@Value(&amp;quot;${jwt.secret}&amp;quot;)的方式注入值。 application.yml配置如下：
spring: # 数据库配置 datasource: url: jdbc:mysql://localhost/xauth?</description>
    </item>
    
    <item>
      <title>JSON查询数据</title>
      <link>https://boseman1024.github.io/2018/json%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Fri, 30 Mar 2018 23:04:11 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/json%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</guid>
      <description>若原始数据结构如下：
var arr = [{ id:1, name:&#39;a&#39; },{ id:2, name:&#39;b&#39; }];  ①改变数据结构 可转换数据结构，把id变成key为：
var obj = {}; arr.forEach(function (v,i) { obj[v.id] = v; }); 或 for (let i = 0; i &amp;lt; arr.length;i++){ obj[arr[i].id] = arr[i] } obj = { 1:{ id:1, name:&#39;a&#39;, }, 2:{ id:2, name:&#39;b&#39; } };  之后就可根据id获取元素数据
obj[id].name  ②根据key查询元素 功能类似select name from json where id = 1
function getItem(arr,n,v) { for (var i = 0; i &amp;lt; arr.</description>
    </item>
    
    <item>
      <title>NEW YEAR 2018</title>
      <link>https://boseman1024.github.io/2018/new-year-2018/</link>
      <pubDate>Fri, 16 Feb 2018 00:00:57 +0000</pubDate>
      
      <guid>https://boseman1024.github.io/2018/new-year-2018/</guid>
      <description>HAPPY 2017 8 NEW YEAR. NEW YOU. Just kidding. You&amp;rsquo;re still the same. piece of shit you were yesterday. 
十一月 11月27日19点15分
记：
《人生的智慧》——叔本华
-人所展现的表象
「他们在别人头脑中的形象比起自己的本质存在更令他们牵肠挂肚。这种把非直接为我们存在的东西作为直接的存在来加以看重的愚蠢做法，人们称之为虚荣，以表示这种渴望、努力所具有的虚幻和空洞本质。同样，从上面的论述可以轻易看出：这种虚荣为了手段而忘记了目的，它和贪婪同属一类性质。」
「人们头脑里面的认识和见解，绝大部分都是虚假荒唐和黑白颠倒的。」
「我在这里谈论的这一源自人类本性的愚蠢，生发了三个主要芽条：好胜、虚荣和骄傲。虚荣和骄傲之间的差别在于：骄傲就是确信自己拥有某一方面的突出价值，但虚荣则尽力让别人确信自己拥有某一方面的突出价值；在大多数的情况下，伴随着虚荣的还有这样一个隐藏着的希望：通过唤起别人的确信，能够使自己真的拥有这一份确信。因为，骄傲是发自内在的、直接的自我敬重；而虚荣则是从外在、因而使间接地努力试图获取这一自我敬重。因此，虚荣使人健谈，但骄傲却使人沉默。但是，虚荣的人应该知道：要获得自己梦寐以求的别人高度的评价，那如果他保持沉默，而不是夸夸其谈——哪怕他的嘴里可以说出美妙、动听的话语——他将更加容易和更有把握地达到目的。」
「谦虚是美德——这一句话是蠢人地一项聪明的发明；因为根据这一说法每个人都要把自己说成像一个傻瓜似的，这就巧妙地把所有人都拉到同一个水平线上。这样做的结果就是在这世界上，似乎除了傻瓜之外，再没别样的人了。」
「因此，我认为，客观上，名誉是他人对我们的价值的看法；主观上，则是我们对于他人看法的顾忌。」
11月26日19点42分
Donut Hole.
记：
《人生的智慧》——叔本华
-基本的划分
「正如每个人都囿于自己的皮囊，每个人也同样囿于自己的意识。一个人只能直接活在自己的意识之中。因此，外在世界对他帮助不大。」
「一个人所能得到的属于他的快乐，从一开始就已经由这个人的个性规定了。一个人精神能力的范围尤其决定性地限定了他领略高级快乐的能力。如果这个人的精神能力相当有限，那么，所有来自外在的努力——别人或者运气所能为他做的一切——都不会使他超越只能领略平庸无奇、夹杂着动物性的快乐的范围。他只能享受感官的乐趣、低级的社交、庸俗的消费和闲适的家庭生活。」
「财富除了能满足人的真正、自然的需求以外，对于我们的真正幸福没有多大影响。相反，为了保管好偌大的财产，我们会有许多不可避免的操劳，它们打扰了我们舒适悠闲的生活。」
-人的自身
「使我们快乐或者忧伤的事物，不是那些客观、真实的事物，而是我们对这些事物的理解和把握。」
「对生活稍作考察就可以知道：痛苦和无聊是人类幸福的两个死敌，关于这一点，我可以作一个补充：每当我们感到快活，在我们远离上述的一个敌人的时候，我们也就接近了另一个敌人，反之亦然。所以说，我们的生活确实就是在着两者之中或强或弱地摇摆。」
「因此无论如何，我们不应该从他人哪里，或者从自身以外期望太多。一个人对另一个人所能做的只是极为有限。归根到底，每个人都孑然独立，这时候，关键的问题就是这单独的人是个什么样的人。」
「在这个世界上，卑劣和恶毒普遍占据着统治的地位，而愚蠢地嗓门叫喊得至为响亮，他们的话语也更有分量。」
「我们的现实生活在没有受到情欲的驱动时会变得无聊和乏味；一旦受到情欲的驱动，很快就会变得痛苦不堪。因此，只有那些思想禀赋超常的人才时幸运的，他们的智力超出了意欲所需要的程度。只有这种人才能够在过着实际生活的同时，还享有一种不带痛苦的精神生活。他们全副身心地沉浸在这种精神生活当中，乐此不疲。仅仅拥有闲暇，即智力不需要为意欲服务，并不足以使人们享有精神生活；为能享有精神生活，人们必须具备某种真正充裕有余的能力。只有具备了这种充裕有余的能力，才能有资格从事并不服务于意欲的纯粹精神上的活动。」
「根据个人精神思想能力参差不齐的充裕程度，而相应在现实生活的同时，还有着无数等级的思想生活：从仅仅只是收集和描绘昆虫、鸟类、矿物、钱币之类的精神乐趣，一直到创作出杰出的文学和哲学作品。类似的精神生活使我们得以避免低劣的社交，以及许许多多的危险、不幸、损失和纵欲。如果人们完全是在这个现实生活里追求幸福，那他们就会遭遇上述这些不好的东西。所以，例如，虽然我的哲学并没有给我带来具体的好处，但它却使我避免了许多的损失。但是，常人却寄希望于身外之物，寄望于从财产、地位、妻子、儿女、朋友、社会人群那里获取生活快乐；他把自己一生的幸福寄托在这些上面。因此一旦他失去了这些东西，或者对这些东西的幻想破灭，那他的幸福也就随之烟消云散了。为把这种情形表达清楚，我们可以这样说：这个人的重心在他的自身之外。」
「人是匮乏的儿子，他并不是自由发挥思想的人。因此，闲暇很快就成了普通大众的包袱。的确，如果人们不能通过各种幻想的、虚假的目标，以各式游戏消遣和爱好来填塞时间，到后，闲暇就会变成了痛苦。基于同样的原因，闲暇还会给人们带来危险，因为“当一个人无所事事的时候难以保持安静”是相当正确的。」
11月23日16点08分
这身体真没用。
11月22日12点45分
记：
《强风吹拂》——三浦紫苑
「不管跑不跑步，每个人都有自己的痛苦，同理，也有各自的喜悦。不论任何人，都有他必须面对的烦恼；即使明知愿望无法达成，也挣扎着向前进。
　既然不论去任何地方都一样，不如坚定立场，遵循内心的渴望坚持到最后。」
11月20日21点47分
结果还是绕回原点。
废人。
11月19日12点38分
记：
《斜阳》——太宰治
「我感到无论怎样努力，也活不下去般的忧虑。这就是那种叫做不安的感情吧，痛苦的浪潮一阵阵涌上心头，犹如白云匆匆飘过雷阵雨后的天空一般，将我的心脏忽而抽紧，忽而放松，我感到自己的脉搏凝滞了，呼吸微弱了，视野迷蒙了，全身的力量都从指尖消失了似的，无法继续编织下去了。」
「颓废？但是，不这样我就无法活下去。比起说这样的话责备我的人，反倒是那些对我说“你去死吧”的人更可爱吧。这样更爽快。但是，叫你去死的人绝无仅有，大家都是些自私自利、谨小慎微的伪君子。」
「我装作早熟，人人就都说我早熟。我装成懒汉，人人就说我是懒汉。我假装不会写小说，人人就说我不会写小说。我伪装成骗子，人们就说我是个骗子。我摆阔，人人就说我是有钱人。我表现得很冷淡，人人说我是个冷漠的家伙。然而，当我真的痛苦万分、发出呻吟时，人人却说我是佯装痛苦，无病呻吟。」
「人有生存的权利，同样，也应该有死的权力。」
「我还是一死了之的好。我没有所谓的生活能力，也没有本事和他人争夺金钱。我就连占别人便宜都做不到。和上原先生一起喝酒玩乐时，我也都是自己付自己的帐。上原先生认为这是贵族的廉价自尊，非常厌恶，但是，我并非是为了自尊才自己付帐的。我只是非常害怕用他辛苦工作赚来的钱，花在无聊的吃喝和抱女人上，我真的做不到。我总是说因为尊重上原先生的工作，那自然是谎言，其实我自己也不太清楚为何这么做。不知为什么，白吃白喝别人的，总会使我惧怕。尤其是对方用凭自己本事赚来的钱请我吃喝时，更叫我痛苦万分。」
《樱桃》——太宰治
「人这辈子，真是不容易。时时处处都会碰到枷锁，稍微一动弹，便会血流如注。」</description>
    </item>
    
  </channel>
</rss>